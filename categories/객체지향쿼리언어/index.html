
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="codexdawn">
    <title>Category: 객체지향쿼리언어 - codexdawn</title>
    <meta name="author" content="codexdawn">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="codexdawn">
<meta property="og:url" content="https://codexdawn.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4/index.html">
<meta property="og:site_name" content="codexdawn">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="codexdawn">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-3sspfygaapf5d6tbrnqmyrhdcstv0iwwmi4wor2yeip9c44sowy9gbdzyyjm.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            codexdawn
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/codexdawn"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/beherzt.dev"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/sim-jisung-3048872a/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:cloudkaiser@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/05/20/jpa-obj-query-3/"
                            aria-label=": jpa-obj-query-3"
                        >
                            jpa-obj-query-3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-20T10:59:56+00:00">
	
		    May 20, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Study/">Study</a>, <a class="category-link" href="/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4/">객체지향쿼리언어</a>, <a class="category-link" href="/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">자바ORM표준JPA프로그래밍</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="객체지향-쿼리-언어3"><a href="#객체지향-쿼리-언어3" class="headerlink" title="객체지향 쿼리 언어3"></a>객체지향 쿼리 언어3</h1><h2 id="1-Persistance-Context와-JPQL"><a href="#1-Persistance-Context와-JPQL" class="headerlink" title="1. Persistance Context와 JPQL"></a>1. Persistance Context와 JPQL</h2><h3 id="1-1-쿼리후-영속상태인-것과-아닌것"><a href="#1-1-쿼리후-영속상태인-것과-아닌것" class="headerlink" title="1-1. 쿼리후 영속상태인 것과 아닌것"></a>1-1. 쿼리후 영속상태인 것과 아닌것</h3><figure class="highlight java"><figcaption><span>영속상태구분</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select m form Member m <span class="comment">//엔티티조회 (영속성 관리됨)</span></span><br><span class="line">select o.address from Order o <span class="comment">//임베디드타입 조회 (영속성 관리 안됨)</span></span><br><span class="line">select m.id, m.username from Member m <span class="comment">//단순 필드조회 (영속성 관리 안됨)</span></span><br></pre></td></tr></table></figure>

<p>위 예제를 통해 알수있듯이, 조회한 엔티티만 영속성 컨텍스트에 관리가 됨. </p>
<h3 id="1-2-JPQL로-조회한-엔티티와-영속성-컨텍스트"><a href="#1-2-JPQL로-조회한-엔티티와-영속성-컨텍스트" class="headerlink" title="1-2. JPQL로 조회한 엔티티와 영속성 컨텍스트"></a>1-2. JPQL로 조회한 엔티티와 영속성 컨텍스트</h3><figure class="highlight java"><figcaption><span>영속상태구분</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">em.find(Member.class,<span class="string">&quot;m1&quot;</span>); <span class="comment">//회원1 조회 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//엔티티 쿼리 조회 결과가 회원1, 회원2</span></span><br><span class="line">List&lt;Member&gt; resultList = em.createQuery(<span class="string">&quot;select m from Member m&quot;</span>, Member.class).getResultList(); </span><br></pre></td></tr></table></figure>

<p>em.find로 회원1을 조회했는데, JPQL로 전체를 가져오는 List를 호출하였다. 그럼 위 조회 과정은 어떻게 될까?</p>
<blockquote><p>em.find 호출뒤, List 조회 했을경우 </p>
<ol>
<li>JPQL을 사용해서 조회 요청</li>
<li>JPQL은 SQL로 변환되어 DB에 조회 </li>
<li>조회한 결과와 영속성 컨텍스트를 비교 (em.find로 조회된값 : m1 ,조회한값 :m1,m2)</li>
<li>식별자 기준으로 m1은 이미 영속성관리에 있으므로 버리고, 기존에 영속성관리에 있던 m1이 반환대상이됨.</li>
<li>식별자 기준으로 m2는 영속성 컨텍스트에 없으므로, 영속성컨텍스트에 추가 </li>
<li>쿼리 결과인 m1,m2를 반환한다. 여기서 m1은 쿼리결과가 아니라 영속성 컨텍스트에 있던 엔티티임을 잊지말자! </li>
</ol>
</blockquote>

<p>여기서 알수있는 2가지 사실이있다.</p>
<ol>
<li>JPQL로 조회한 엔티티는 영속상태다. </li>
<li>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다. </li>
</ol>
<p>영속성 컨텍스트는 영속상태인 엔티티의 동일성을 보장한다. em.find이든 JPQL로 조회하든 영속성 컨텍스트가 같으면 동일한 엔티티를 반환함. </p>
<h3 id="1-3-find-VS-JPQL"><a href="#1-3-find-VS-JPQL" class="headerlink" title="1-3. find() VS JPQL"></a>1-3. find() VS JPQL</h3><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><ul>
<li>find 메서드는 엔티티를 영속성 컨텍스트에 먼저 찾고 없으면 DB에서 찾는다. 따라서 해당 엔티티가 영속성 컨텍스트에 존재하면 메모리에서 바로 찾으므로 성능상 이점이 있다. (그래서 1차캐시라 부름)</li>
</ul>
<h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4><ul>
<li>JPQL은 항상 디비를 조회한다.</li>
<li>JPQL로 조회한 엔티티는 영속상태다. (왜냐 DB 조회후,영속성컨텍스트에 집어넣기때문 )</li>
<li>영속성 컨텍스트에 이미 존재하는 엔티티가있으면 기존 엔티티를 반환함. </li>
</ul>
<h2 id="2-JPQL과-flush모드"><a href="#2-JPQL과-flush모드" class="headerlink" title="2. JPQL과 flush모드"></a>2. JPQL과 flush모드</h2><h3 id="2-1-쿼리와-플러시-모드"><a href="#2-1-쿼리와-플러시-모드" class="headerlink" title="2-1. 쿼리와 플러시 모드"></a>2-1. 쿼리와 플러시 모드</h3><ul>
<li>JPQL은 영속성 컨텍스트 고려하지 않고, DB를 먼저 조회함. 따라서 JPQL을 실행하기전에 영속성 컨텍스트의 내용을 DB에 반영해야함. 그렇지 않으면 상이한결과가 발생할수있음. </li>
<li>FlushMode는 두가지있음. AUTO,COMMIT 이다.<ul>
<li>AUTO : FlushMode를 따로 지정하지 않으면 기본값임. AUTO는 JPQL가 수행되면 자동 FLUSH시켜버림. </li>
<li>COMMIT : COMMIT모드면 말그대로 커밋시점에 FLUSH가 됨. 따라서 JPQL쿼리가 수행되도, FLUSH되지않음. </li>
</ul>
</li>
<li>FlushMode.COMMIT은 왜 씀? <ul>
<li>flush가 너무 빈번하게 일어나는 상황에서 이모드를 사용하면 쿼리시 발생하는 플러시 횟수를 줄여서 성능 최적화 가능함. </li>
</ul>
</li>
<li>JPA를 사용하지않고, JDBC를 직접 사용해서 SQL을 실행할때도 플러시모드는 고민해야함. JPA를 통하지않고 JDBC로 직접 실행하면 JPA는 JDBC가 실행한 쿼리를 인식할 방법이 없음. 따라서 별도 JDBC호출은 플러시 모드를 AUTO로설정해도 무의미함. 이때는 JDBC로 쿼리를 실행하기전에 em.flush를 호출해서 영속성 컨텍스트의 내용을 디비에 동기화 하는게 안점함. </li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/05/20/jpa-obj-query-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/05/08/jpa-obj-query-2/"
                            aria-label=": jpa-obj-query-2"
                        >
                            jpa-obj-query-2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-08T02:54:28+00:00">
	
		    May 08, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Study/">Study</a>, <a class="category-link" href="/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4/">객체지향쿼리언어</a>, <a class="category-link" href="/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">자바ORM표준JPA프로그래밍</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="객체지향-쿼리-언어2"><a href="#객체지향-쿼리-언어2" class="headerlink" title="객체지향 쿼리 언어2"></a>객체지향 쿼리 언어2</h1><h2 id="1-경로표현식"><a href="#1-경로표현식" class="headerlink" title="1. 경로표현식"></a>1. 경로표현식</h2><h3 id="1-1-경로표현식이란"><a href="#1-1-경로표현식이란" class="headerlink" title="1-1. 경로표현식이란?"></a>1-1. 경로표현식이란?</h3><ul>
<li>. 찍어서 객체그래프를 탐색하는 것 </li>
</ul>
<h3 id="1-2-경로표현식-특징"><a href="#1-2-경로표현식-특징" class="headerlink" title="1-2. 경로표현식 특징"></a>1-2. 경로표현식 특징</h3><ul>
<li>상태 필드(state field): 경로 탐색의 끝, 탐색X</li>
<li>단일 값 연관 경로: 묵시적 내부 조인(inner join) 발생, 탐색O<ul>
<li>@ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team)</li>
</ul>
</li>
<li>컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색X<ul>
<li>FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통 해 탐색 가능</li>
<li>@OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.orders)</li>
</ul>
</li>
</ul>
<h3 id="1-3-경로탐색을-사용한-묵시적-조인-시-주의사항"><a href="#1-3-경로탐색을-사용한-묵시적-조인-시-주의사항" class="headerlink" title="1-3. 경로탐색을 사용한 묵시적 조인 시 주의사항"></a>1-3. 경로탐색을 사용한 묵시적 조인 시 주의사항</h3><ul>
<li>항상 내부조인 걸림 </li>
<li>걸렉션은 경로 탐색이 안된다. (사이즈만 받을수있음) 따라서 컬렉션은 반드시 명시적 조인으로 별칭을 얻어서 경로탐색하도록 해야함<ul>
<li>select m.username from Team t join t.members m</li>
</ul>
</li>
<li>경로탐색은 주로 SELECT/WHERE 절에서만 하는데, 묵시적조인을 사용하면 SQL에서 FROM(JOIN) 절에 영향을 줌 </li>
</ul>
<h3 id="1-4-실무자의-조언"><a href="#1-4-실무자의-조언" class="headerlink" title="1-4. 실무자의 조언"></a>1-4. 실무자의 조언</h3><ul>
<li>가급적 묵시적 조인 하지말고 명시적 조인만 사용하도록 하자 (쿼리 튜닝 및 알아보기 힘듦)</li>
<li>조인은 sql튜닝에 가장 중요한 포인트(기승전 SQL)</li>
<li>묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움 </li>
</ul>
<h2 id="2-페치-조인-fetch-join"><a href="#2-페치-조인-fetch-join" class="headerlink" title="2. 페치 조인 (fetch join)"></a>2. 페치 조인 (fetch join)</h2><h3 id="2-1-페치-조인의-특징"><a href="#2-1-페치-조인의-특징" class="headerlink" title="2-1. 페치 조인의 특징"></a>2-1. 페치 조인의 특징</h3><ul>
<li>SQL join종류 아님 (sql 명령어 아님)</li>
<li>JPQL 성능 최적화를 위해 제공하는 기능 </li>
<li>연관된 엔티티나 컬렉션을 SQL 한번에 함께 조회 가능 (한방쿼리)</li>
<li>join fetch 명령어 사용 </li>
<li>페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로</li>
</ul>
<h3 id="2-2-엔티티-페치-조인"><a href="#2-2-엔티티-페치-조인" class="headerlink" title="2-2. 엔티티 페치 조인"></a>2-2. 엔티티 페치 조인</h3><ul>
<li>ManyToOne, OneToOne 관계에서 조회할때 이슈라고 생각해도됨. </li>
<li>회원-팀 예시 기준으로 회원을 조회하면서 연관된 팀도 함께 조회 (SQL 한방 쿼리)</li>
<li>SQL을 보면 회원 뿐만 아니라 팀(T.*)도 함께 SELECT</li>
<li>[JPQL]<ul>
<li>select m from Member m join fetch m.team</li>
</ul>
</li>
<li>[SQL]<ul>
<li>SELECT M.<em>, T.</em> FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID</li>
</ul>
</li>
</ul>
<p><img src="/images/jpa/jpql-11.png" alt="엔티티페치조인 예시"><br><img src="/images/jpa/jpql-12.png" alt="엔티티페치코드 예시"></p>
<p>[Q1] 그냥 Member 엔티티를 쿼리를 날리고, 비즈니스코드에서 Team정보를 조회하면?</p>
<figure class="highlight java"><figcaption><span>엔티티조회</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members =entityManager.createQuery(<span class="string">&quot;select m from Member m&quot;</span>, Member.class).getResultList();</span><br><span class="line"><span class="keyword">for</span> (Member member1 : members2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;member1.getUserName() = &quot;</span> + member1.getUserName() </span><br><span class="line">				+ <span class="string">&quot;/ teamName : &quot;</span> + member1.getTeam().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>–&gt; 위 처럼 비즈니스로직에서 Team정보를 호출하면 proxy상태이기때문에, 초기화처리로 각 멤버당 팀 정보를 디비를 통해 조회 해오게된다. 하지만 1차캐시에 등록된 그니까 영속성 관리가 되면 1차캐시 정보로 가져오게됨. </p>
<figure class="highlight plain"><figcaption><span>엔티티조회결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m *&#x2F; select</span><br><span class="line">            member0_.member_id as member_i1_0_,</span><br><span class="line">            member0_.age as age2_0_,</span><br><span class="line">            member0_.team_id as team_id4_0_,</span><br><span class="line">            member0_.userName as userName3_0_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m1&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m2&#x2F; teamName : Team1 &#x2F;&#x2F;여기서는 1차캐시로 조회된 정보 가져옴 </span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m3&#x2F; teamName : Team2</span><br></pre></td></tr></table></figure>

<p>[Q2] 위 쿼리에서 Team엔티티를 조인해서 조회하면 어떻게 될까? </p>
<figure class="highlight java"><figcaption><span>단순 조인시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members =entityManager.createQuery(<span class="string">&quot;select m from Member m join m.team&quot;</span>, Member.class).getResultList();</span><br><span class="line"><span class="keyword">for</span> (Member member1 : members2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;member1.getUserName() = &quot;</span> + member1.getUserName() </span><br><span class="line">				+ <span class="string">&quot;/ teamName : &quot;</span> + member1.getTeam().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>–&gt; 단순 조인만 했지만 프로젝션 상에서 팀정보가 없다.<br>어쨋든 위 상황에서는 프로젝션상에서 Team엔티티 정보가 없기때문에 Q1 상황과 동일한 결과로 나오게됨.<br>(참고) 글로벌 페치 전략을 아무리 EAGER로 강제해도 동일한 결과 나올수밖에 없음. 프록시 이슈는 동일하게 나올수밖에없더라.<br>(추론) 만약에 저기서 조회를 가능하게 하려면 프로젝션상에서 t를 받고, 프로젝션에 맞는 신규DTO를 만들어서 객체로 반환하면 해결되지않을까 싶음. </p>
<figure class="highlight plain"><figcaption><span>단순 조인시 결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m </span><br><span class="line">    join</span><br><span class="line">        m.team *&#x2F; select</span><br><span class="line">            member0_.member_id as member_i1_0_,</span><br><span class="line">            member0_.age as age2_0_,</span><br><span class="line">            member0_.team_id as team_id4_0_,</span><br><span class="line">            member0_.userName as userName3_0_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_ </span><br><span class="line">        inner join &#x2F;&#x2F;조인만 됫지 프로젝션상에서는 Team정보가 없다..-_-; </span><br><span class="line">            Team team1_ </span><br><span class="line">                on member0_.team_id&#x3D;team1_.team_id</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m1&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m2&#x2F; teamName : Team1</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m3&#x2F; teamName : Team2</span><br></pre></td></tr></table></figure>

<p>[Q3] 그럼 저렇게 N+1이 나면 어떻게 해결해야함?<br>–&gt; fetch join 하면 됨. </p>
<figure class="highlight java"><figcaption><span>조인페치시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members =entityManager.createQuery(<span class="string">&quot;select m from Member m join fetch m.team&quot;</span>, Member.class).getResultList();</span><br><span class="line"><span class="keyword">for</span> (Member member1 : members2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;member1.getUserName() = &quot;</span> + member1.getUserName() </span><br><span class="line">				+ <span class="string">&quot;/ teamName : &quot;</span> + member1.getTeam().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>단순 조인시 결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m </span><br><span class="line">    join</span><br><span class="line">        fetch m.team *&#x2F; select</span><br><span class="line">            member0_.member_id as member_i1_0_0_,</span><br><span class="line">            team1_.team_id as team_id1_3_1_,</span><br><span class="line">            member0_.age as age2_0_0_,</span><br><span class="line">            member0_.team_id as team_id4_0_0_,</span><br><span class="line">            member0_.userName as userName3_0_0_,</span><br><span class="line">            team1_.name as name2_3_1_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_ </span><br><span class="line">        inner join</span><br><span class="line">            Team team1_ </span><br><span class="line">                on member0_.team_id&#x3D;team1_.team_id</span><br><span class="line">member1.getUserName() &#x3D; m1&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m2&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m3&#x2F; teamName : Team2</span><br></pre></td></tr></table></figure>

<h3 id="2-3-컬렉션-페치-조인"><a href="#2-3-컬렉션-페치-조인" class="headerlink" title="2-3. 컬렉션 페치 조인"></a>2-3. 컬렉션 페치 조인</h3><ul>
<li>일대다,다대다 관계, 컬렉션 페치 조인 </li>
<li>[JPQL]<ul>
<li>select t from Team t join fetch t.members where t.name = ‘팀A’</li>
</ul>
</li>
<li>[SQL]<ul>
<li>SELECT T.<em>, M.</em> FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID WHERE T.NAME = ‘팀A’</li>
</ul>
</li>
</ul>
<p><img src="/images/jpa/jpql-13.png" alt="컬렉션페치조인 예시"><br><img src="/images/jpa/jpql-14.png" alt="컬렉션페치코드 예시"></p>
<h3 id="컬렉션-페치-조인-혹은-그냥-조인을-걸었는데-중복-발생"><a href="#컬렉션-페치-조인-혹은-그냥-조인을-걸었는데-중복-발생" class="headerlink" title="컬렉션 페치 조인 혹은 그냥 조인을 걸었는데 중복 발생?"></a>컬렉션 페치 조인 혹은 그냥 조인을 걸었는데 중복 발생?</h3><p>OneToMany특성상 쿼리 뻥튀기가 되었기때문에 중복 row발생된것임. 이걸 해결할라면 jpql의 distinct를 걸어주면 해결됨. </p>
<h4 id="JPQL에서의-distinct"><a href="#JPQL에서의-distinct" class="headerlink" title="JPQL에서의 distinct"></a>JPQL에서의 distinct</h4><ul>
<li>SQL의 distinct 처리를 명령함  </li>
<li>JPQL에서는 distinct 2가지 기능 제공 <ol>
<li>SQL distinct 를 추가시킴. </li>
<li>애플리케이션에서 엔티티 중복을 제거시킴. </li>
</ol>
</li>
</ul>
<p>[Q1] Member 컬렉션을 조인하면 어떻게 될까?</p>
<figure class="highlight java"><figcaption><span>컬렉션조인시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select t from Team t join t.members&quot;</span>, Team.class)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>컬렉션조인결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        t.members *&#x2F; select</span><br><span class="line">            team0_.team_id as team_id1_3_,</span><br><span class="line">            team0_.name as name2_3_ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        members0_.team_id as team_id4_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_1_,</span><br><span class="line">        members0_.age as age2_0_1_,</span><br><span class="line">        members0_.team_id as team_id4_0_1_,</span><br><span class="line">        members0_.userName as userName3_0_1_ </span><br><span class="line">    from</span><br><span class="line">        Member members0_ </span><br><span class="line">    where</span><br><span class="line">        members0_.team_id&#x3D;?</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2 &#x2F;&#x2F;컬렉션 조인시 요렇게 중복된 결과가 나오는걸 확인할수있음. 이럴때는 distinct를 걸어서 중복제거해야함. </span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        members0_.team_id as team_id4_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_1_,</span><br><span class="line">        members0_.age as age2_0_1_,</span><br><span class="line">        members0_.team_id as team_id4_0_1_,</span><br><span class="line">        members0_.userName as userName3_0_1_ </span><br><span class="line">    from</span><br><span class="line">        Member members0_ </span><br><span class="line">    where</span><br><span class="line">        members0_.team_id&#x3D;?</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure>

<p>[Q2] 컬렉션 조인을 페치하면 어떻게 될까?<br>–&gt; 쿼리는 fetch가 되서 한방쿼리가 되었지만, distinct처리 안해서 중복 엔티티 row발생함. </p>
<figure class="highlight java"><figcaption><span>컬렉션조인시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select t from Team t join fetch t.members&quot;</span>, Team.class)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>컬렉션조인결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        fetch t.members *&#x2F; select</span><br><span class="line">            team0_.team_id as team_id1_3_0_,</span><br><span class="line">            members1_.member_id as member_i1_0_1_,</span><br><span class="line">            team0_.name as name2_3_0_,</span><br><span class="line">            members1_.age as age2_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_1_,</span><br><span class="line">            members1_.userName as userName3_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_0__,</span><br><span class="line">            members1_.member_id as member_i1_0_0__ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2 &#x2F;&#x2F;fetch를하면 쿼리는 줄지만 distinct를 처리하지 않았기때문에 여전히 중복 발생 </span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure>

<p>[Q3] 위 쿼리에서 distinct를 걸면 해결되나?<br>–&gt; 해결됨</p>
<figure class="highlight java"><figcaption><span>컬렉션페치조인 distinct처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select distinct t from Team t join fetch t.members&quot;</span>, Team.class)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>컬렉션페치조인 distinct처리결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        distinct t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        fetch t.members *&#x2F; select</span><br><span class="line">            distinct team0_.team_id as team_id1_3_0_,</span><br><span class="line">            members1_.member_id as member_i1_0_1_,</span><br><span class="line">            team0_.name as name2_3_0_,</span><br><span class="line">            members1_.age as age2_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_1_,</span><br><span class="line">            members1_.userName as userName3_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_0__,</span><br><span class="line">            members1_.member_id as member_i1_0_0__ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure>

<p>[Q4] 컬렉션 페치 조인해서 페이징 적용하면 어떻게되나?<br>–&gt; 페이징 로직이 미적용되고, 메모리에 해당 엔티티들의 모든 row가 다 적재됨. (메모리 부하 발생 성능 다운됨.)</p>
<figure class="highlight java"><figcaption><span>컬렉션페치조인 페이징처리시도</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select distinct t from Team t join fetch t.members&quot;</span>, Team.class)</span><br><span class="line">                .setFirstResult(<span class="number">0</span>)</span><br><span class="line">                .setMaxResults(<span class="number">2</span>)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>컬렉션페치조인 페이징적용결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        distinct t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        fetch t.members *&#x2F; select</span><br><span class="line">            distinct team0_.team_id as team_id1_3_0_,</span><br><span class="line">            members1_.member_id as member_i1_0_1_,</span><br><span class="line">            team0_.name as name2_3_0_,</span><br><span class="line">            members1_.age as age2_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_1_,</span><br><span class="line">            members1_.userName as userName3_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_0__,</span><br><span class="line">            members1_.member_id as member_i1_0_0__ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id &#x2F;&#x2F;페이징 처리 로직 미적용됨. </span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;메모리 다 적재됫다고 경고떳음</span><br><span class="line">5월 08, 2021 3:11:40 오후 org.hibernate.hql.internal.ast.QueryTranslatorImpl list</span><br><span class="line">WARN: HHH000104: firstResult&#x2F;maxResults specified with collection fetch; applying in memory!</span><br><span class="line">5월 08, 2021 3:11:40 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PoolState stop</span><br><span class="line">INFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;~&#x2F;jpqlshop]</span><br></pre></td></tr></table></figure>

<p>–&gt; 페이징을 강제로 해결하려면 페치조인 걸었던것 제거하고 Team.members에 @BatchSize를 걸던지, 혹은 글로벌 설정에서 persistence.xml혹은 application.yml등에서 batchsize를 설정해야함. 보통 글로벌 설정으로 설정하고 시작한다고함. </p>
<figure class="highlight java"><figcaption><span>컬렉션페치조인 페이징처리 batchsize적용상태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////// Team.java /////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@BatchSize(size = 100)</span></span><br><span class="line"><span class="meta">@OneToMany(mappedBy = &quot;team&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">///////// 구분 /////////////</span></span><br><span class="line"></span><br><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select distinct t from Team t&quot;</span>, Team.class)</span><br><span class="line">                .setFirstResult(<span class="number">0</span>)</span><br><span class="line">                .setMaxResults(<span class="number">2</span>)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>컬렉션페치조인 페이징적용결과-batchsize적용했을때</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        distinct t </span><br><span class="line">    from</span><br><span class="line">        Team t *&#x2F; select</span><br><span class="line">            distinct team0_.team_id as team_id1_3_,</span><br><span class="line">            team0_.name as name2_3_ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ limit ?</span><br><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* load one-to-many entity.Team.members *&#x2F; select</span><br><span class="line">        members0_.team_id as team_id4_0_1_,</span><br><span class="line">        members0_.member_id as member_i1_0_1_,</span><br><span class="line">        members0_.member_id as member_i1_0_0_,</span><br><span class="line">        members0_.age as age2_0_0_,</span><br><span class="line">        members0_.team_id as team_id4_0_0_,</span><br><span class="line">        members0_.userName as userName3_0_0_ </span><br><span class="line">    from</span><br><span class="line">        Member members0_ </span><br><span class="line">    where</span><br><span class="line">        members0_.team_id in (</span><br><span class="line">            ?, ?</span><br><span class="line">        )</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure>

<h3 id="2-4-페치조인과-일반조인의-차이"><a href="#2-4-페치조인과-일반조인의-차이" class="headerlink" title="2-4. 페치조인과 일반조인의 차이"></a>2-4. 페치조인과 일반조인의 차이</h3><h4 id="일반-조인"><a href="#일반-조인" class="headerlink" title="일반 조인"></a>일반 조인</h4><ul>
<li>일반조인 실행시 연관된 엔티티를 함께 조회 안함 </li>
<li>[JPQL]<ul>
<li>select t from Team t join t.members m where t.name = ‘팀A’</li>
</ul>
</li>
<li>[SQL]<ul>
<li>SELECT T.* FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID  WHERE T.NAME = ‘팀A’</li>
</ul>
</li>
<li>JPQL은 결과를 반환할때 연관관계 고려안함</li>
<li>단지 select절에 지정한 엔티티만 조회한다.</li>
<li>따라서 Team엔티티만 조회할뿐, Member정보는 조회 안함</li>
</ul>
<h4 id="페치-조인"><a href="#페치-조인" class="headerlink" title="페치 조인"></a>페치 조인</h4><ul>
<li>페치 조인을 사용할때만 연관된 엔티티도 함께 조회 (즉시로딩됨)</li>
<li>페치 조인은 객체 그래프를 SQL한번에 조회하는 개념 </li>
<li>페치 조인은 연관된 엔티티를 함께 조회함</li>
<li>[JPQL]<ul>
<li>select t from Team t join fetch t.members where t.name = ‘팀A’</li>
</ul>
</li>
<li>[SQL]<ul>
<li>SELECT T.<em>, M.</em> FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID WHERE T.NAME = ‘팀A’</li>
</ul>
</li>
</ul>
<h3 id="2-5-페치-조인의-특징-과-한계"><a href="#2-5-페치-조인의-특징-과-한계" class="headerlink" title="2-5. 페치 조인의 특징 과 한계"></a>2-5. 페치 조인의 특징 과 한계</h3><ul>
<li>페치 조인 대상에서는 별칭을 줄수없다. (하이버네이트는 가능하지만 가급적 사용하지 말자)</li>
<li>둘 이상의 컬렉션은 페치 조인 할수 없다. (1:N:M의 관계로 가져오기때문에 관련된 모든 정보를 끌고오기때문에)</li>
<li>컬렉션을 페치조인하면 페이징 API를 사용할수 없다. <ul>
<li>1:1, N:1 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능 </li>
<li>1:N, N:M 같은 컬렉션은 강제로 페이징처리를 하면 페이징로직이 무시되고 해당 엔티티에 있는 모든 정보를 다 끌고옴. (하이버네이트에서 경고 로그 남기고 모든 row를 메모리에 올리는 불상사가 벌어짐.)</li>
<li>컬렉션은 그럼 페이징을 못하는가? 컬렉션 상태에서는 아니고 fetch join한 부분을 지우고 @BatchSize혹은 글로벌설정에서 batchsize를 설정하고 조회하면 페이징 처리는 가능 하지만 N+1을 완벽하게 해소되지 않은 상태지만 성능에는 큰 도움이됨. </li>
</ul>
</li>
<li>연관된 엔티티들을 SQL한번으로 조회 -&gt; 성능 최적화 </li>
<li>엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함 </li>
<li>실무에서는 글로벌 로딩전략은 모두 지연로딩으로 걸어두자</li>
<li>최적화 필요한곳만 페치 조인 적용 </li>
<li>페치조인을 사용해서 연관된 엔티티를 쿼리시점에 조회해서 지연로딩이 발생하지 않는데, 이때 준영속상태에서도 객체그래프를 탐색할수있다. 왜냐 1차캐시에 올라갔기때문에 </li>
</ul>
<h3 id="2-6-페치조인-정리"><a href="#2-6-페치조인-정리" class="headerlink" title="2-6. 페치조인 정리"></a>2-6. 페치조인 정리</h3><ul>
<li>모든것을 페치 조인으로 해결이 안될때가 있음. </li>
<li>페치 조인은 객체 그래프를 유지할때 사용하면 효과적 </li>
<li>여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치조인보다 일반 조인을 사용하고 필요한 데이터들만 프로젝션해서 DTO로 반환하는 것이 효과적</li>
</ul>
<h2 id="3-다형성-쿼리"><a href="#3-다형성-쿼리" class="headerlink" title="3. 다형성 쿼리"></a>3. 다형성 쿼리</h2><h3 id="3-1-TYPE"><a href="#3-1-TYPE" class="headerlink" title="3-1. TYPE"></a>3-1. TYPE</h3><ul>
<li>조회 대상을 특정 자식으로 한정 </li>
<li>예) 위 예제중 Item중에 Book, Movie를 조회해라</li>
<li>[JPQL]<ul>
<li>select i from Item i where type(i) IN (Book, Movie)</li>
</ul>
</li>
<li>[SQL]<ul>
<li>select i from i where i.DTYPE in (‘B’, ‘M’)</li>
</ul>
</li>
</ul>
<h3 id="3-2-TREAT-JPA-2-1"><a href="#3-2-TREAT-JPA-2-1" class="headerlink" title="3-2. TREAT (JPA 2.1)"></a>3-2. TREAT (JPA 2.1)</h3><ul>
<li>자바의 타입 캐스팅과 유사</li>
<li>상속 구조에서 부모타입을 특정 자식 타입으로 다룰때 사용 </li>
<li>FROM, WHERE, SELECT(하이버네이트 지원) 사용</li>
<li>예) 부모인 Item과 자식 Book이 있다.</li>
<li>[JPQL]<ul>
<li>select i from Item i where treat(i as Book).auther = ‘kim’</li>
</ul>
</li>
<li>[SQL]<ul>
<li>select i.* from Item i where i.DTYPE = ‘B’ and i.auther = ‘kim’</li>
</ul>
</li>
</ul>
<h2 id="4-엔티티-직접-사용"><a href="#4-엔티티-직접-사용" class="headerlink" title="4. 엔티티 직접 사용"></a>4. 엔티티 직접 사용</h2><p><img src="/images/jpa/jpql-15.png" alt="엔티티직접사용 예시"></p>
<ul>
<li>JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기 본 키 값을 사용</li>
<li>[JPQL]<ul>
<li>select count(m.id) from Member m //엔티티의 아이디를 사용</li>
<li>select count(m) from Member m //엔티티를 직접 사용</li>
</ul>
</li>
<li>[SQL] (JPQL 둘다 같은 다음 SQL 실행)<ul>
<li>select count(m.id) as cnt from Member m</li>
</ul>
</li>
</ul>
<p><img src="/images/jpa/jpql-16.png" alt="엔티티직접사용 기본키예시"><br><img src="/images/jpa/jpql-17.png" alt="엔티티직접사용 외래키예시"></p>
<h2 id="5-Named-쿼리"><a href="#5-Named-쿼리" class="headerlink" title="5. Named 쿼리"></a>5. Named 쿼리</h2><h3 id="5-1-Named쿼리-정적-쿼리"><a href="#5-1-Named쿼리-정적-쿼리" class="headerlink" title="5-1. Named쿼리 - 정적 쿼리"></a>5-1. Named쿼리 - 정적 쿼리</h3><ul>
<li>미리 정의해서 이름을 부여해두고 사용하는 JPQL</li>
<li>정적 쿼리</li>
<li>어노테이션, XML지원</li>
<li>애플리케이션 로딩 시점에 초기화 후 재사용 </li>
<li>애플리케이션 로딩 시점에 쿼리를 검증해줌 </li>
</ul>
<h3 id="5-2-Named쿼리-어노테이션-사용-방법"><a href="#5-2-Named쿼리-어노테이션-사용-방법" class="headerlink" title="5-2. Named쿼리 - 어노테이션 사용 방법"></a>5-2. Named쿼리 - 어노테이션 사용 방법</h3><p><img src="/images/jpa/jpql-18.png" alt="Named쿼리 어노테이션예시"></p>
<h3 id="5-3-Named쿼리-XML-사용방법"><a href="#5-3-Named쿼리-XML-사용방법" class="headerlink" title="5-3. Named쿼리 - XML 사용방법"></a>5-3. Named쿼리 - XML 사용방법</h3><p><img src="/images/jpa/jpql-19.png" alt="Named쿼리 XML예시"></p>
<h3 id="5-4-Named쿼리-환경에-따른-설정"><a href="#5-4-Named쿼리-환경에-따른-설정" class="headerlink" title="5-4. Named쿼리 환경에 따른 설정"></a>5-4. Named쿼리 환경에 따른 설정</h3><ul>
<li>XML이 항상 우선권을 가짐 </li>
<li>애플리케이션 운영 환경에 따라 다른 XML을 배포할수있다. </li>
</ul>
<h2 id="6-JPQL-벌크연산"><a href="#6-JPQL-벌크연산" class="headerlink" title="6. JPQL - 벌크연산"></a>6. JPQL - 벌크연산</h2><p><img src="/images/jpa/jpql-20.png" alt="벌크연산"><br><img src="/images/jpa/jpql-21.png" alt="벌크연산 예시"></p>
<h3 id="6-1-벌크연산시-주의"><a href="#6-1-벌크연산시-주의" class="headerlink" title="6-1. 벌크연산시 주의"></a>6-1. 벌크연산시 주의</h3><ul>
<li>벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리 (JPQL로 사용하니 당연한 부분)<ul>
<li>벌크 연산을 먼저 실행 </li>
<li>벌크 연산 수행 후 영속성 컨텍스트 초기화 </li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/05/08/jpa-obj-query-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/05/07/jpa-obj-query-1/"
                            aria-label=": jpa-obj-query-1"
                        >
                            jpa-obj-query-1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-07T11:42:32+00:00">
	
		    May 07, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Study/">Study</a>, <a class="category-link" href="/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4/">객체지향쿼리언어</a>, <a class="category-link" href="/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">자바ORM표준JPA프로그래밍</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="객체지향-쿼리-언어"><a href="#객체지향-쿼리-언어" class="headerlink" title="객체지향 쿼리 언어"></a>객체지향 쿼리 언어</h1><p>JPA는 다양한 쿼리 방법을 지원한다. JPQL,JPA Criteria, QueryDSL, 네이티브 SQL, JDBC API/MyBatis등과 같은 외부라이브러리 사용등<br>하지만 결론적으로 실무에서 자주 사용할것은, JPQL/QueryDSL 일것이다. 따라서 JPQL/QueryDSL 위주로 정리하도록 한다. </p>
<h2 id="1-JPQL"><a href="#1-JPQL" class="headerlink" title="1. JPQL"></a>1. JPQL</h2><h3 id="1-1-JPQL-특징"><a href="#1-1-JPQL-특징" class="headerlink" title="1-1. JPQL 특징"></a>1-1. JPQL 특징</h3><ul>
<li>JPQL은 객체지향 쿼리 언어이다. 따라서 테이블을 대상으로 쿼리하는것이 아니라, <strong>엔티티 객체를 대상</strong> 으로 쿼리한다.</li>
<li>JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다. (여러 DB방언 지원 및 ANSI표준까지 지원)</li>
<li>JPQL의 종착지는 SQL이다. SQL로 결국 변환됨.</li>
</ul>
<p><img src="/images/jpa/jpql-1.png" alt="실습 샘플 모델"></p>
<h3 id="1-2-JPQL-기본-문법"><a href="#1-2-JPQL-기본-문법" class="headerlink" title="1-2. JPQL 기본 문법"></a>1-2. JPQL 기본 문법</h3><p><img src="/images/jpa/jpql-2.png" alt="JPQL기본문법 구조1"></p>
<ul>
<li>엔티티와 속성은 대소문자 구분함. </li>
<li>jpql 키워드는 대소문자 구분안함.</li>
<li>반드시 엔티티 이름으로 사용해야함. (테이블이름 안됨)</li>
<li>별칭은 필수! </li>
</ul>
<p><img src="/images/jpa/jpql-3.png" alt="JPQL기본문법 구조2"><br><img src="/images/jpa/jpql-4.png" alt="JPQL기본문법 구조3"></p>
<figure class="highlight java"><figcaption><span>jpql-basic-1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members = entityManager.createQuery(<span class="string">&quot;select m from Member m&quot;</span>, Member.class)</span><br><span class="line">               .getResultList();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>jpql-basic-2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; paramResult = entityManager.createQuery(<span class="string">&quot;select m from Member m where m.userName = :userName&quot;</span>, Member.class)</span><br><span class="line">               .setParameter(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;m2&quot;</span>)</span><br><span class="line">               .getResultList();</span><br></pre></td></tr></table></figure>

<p>[주의] 아래와 같이 쿼리 짜지 말자! </p>
<figure class="highlight java"><figcaption><span>jpql-basic-3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//이런식으로 쿼리짜지말자. join걸어서 가져오는걸로 (가독성이 떨어짐 비추 무조건 명시적조인을 하자)</span></span><br><span class="line"><span class="comment">//그리고 JPQL에서는 fetch상태 자체가 무시됨.(LAZY로 걸어도 그냥 조인됨)</span></span><br><span class="line">List&lt;Team&gt; teams = entityManager.createQuery(<span class="string">&quot;select m.team from Member m&quot;</span>, Team.class)</span><br><span class="line">               				.getResultList();</span><br></pre></td></tr></table></figure>

<h3 id="1-3-프로젝션"><a href="#1-3-프로젝션" class="headerlink" title="1-3. 프로젝션"></a>1-3. 프로젝션</h3><p><img src="/images/jpa/jpql-5.png" alt="JPQL프로젝션"><br><img src="/images/jpa/jpql-6.png" alt="JPQL프로젝션-여러값조회"></p>
<p>[참고]</p>
<ul>
<li>엔티티프로젝션은 Persistance Context에 관리된다.</li>
<li>임베디드타입은 엔티티 타입이 아닌 값타입이다. 따라서 직접 조회한 값타입인 임베디드타입은 Persistance Context에 관리되지않는다.</li>
</ul>
<figure class="highlight java"><figcaption><span>jpql-projection</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MemberInfo&gt; memberInfos = entityManager</span><br><span class="line">                .createQuery(<span class="string">&quot;select new entity.MemberInfo(m.userName,m.age) from Member m&quot;</span>, MemberInfo.class)</span><br><span class="line">                .getResultList();</span><br></pre></td></tr></table></figure>

<h3 id="1-4-페이징-API"><a href="#1-4-페이징-API" class="headerlink" title="1-4. 페이징 API"></a>1-4. 페이징 API</h3><p>JPA의 페이징은 여러 DB방언의 페이징처리를 추상화 되어있다.</p>
<ul>
<li>setFirstResult(int startPosition) : 조회 시작 위치 (0부터시작)</li>
<li>setMaxResults(int maxResult) : 조회할 데이터수 </li>
</ul>
<figure class="highlight java"><figcaption><span>jpql-paging</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; memberList = entityManager.createQuery(<span class="string">&quot;select m from Member m join fetch m.team t order by m.age desc&quot;</span>, Member.class)</span><br><span class="line">                .setFirstResult(<span class="number">0</span>)</span><br><span class="line">                .setMaxResults(<span class="number">20</span>)</span><br><span class="line">                .getResultList();</span><br></pre></td></tr></table></figure>

<h3 id="1-5-조인"><a href="#1-5-조인" class="headerlink" title="1-5. 조인"></a>1-5. 조인</h3><p>기본적인 inner join / left (outer) join / cross join (세타조인) 이 지원된다. 기본적인 ANSI표준 join이 그대로 지원된다고 생각하면됨.</p>
<h4 id="조인-ON절"><a href="#조인-ON절" class="headerlink" title="조인 - ON절"></a>조인 - ON절</h4><ol>
<li>조인 대상 필터링<ul>
<li>SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = ‘A’</li>
<li>위 쿼리처럼 ON 절 뒤에 join하면서 필터작업을 미리 할수있는 기능  </li>
</ul>
</li>
<li>연관관계 없는 엔티티 외부 조인 (하이버네이트 5.1부터가능)<ul>
<li>보통 키값으로 조인을 하지만 전혀 관계없는 부분도 조인조건에 넣을수있음.</li>
<li>SELECT m, t FROM Member m LEFT JOIN Team t on m.username = t.name</li>
</ul>
</li>
</ol>
<h3 id="1-6-서브쿼리"><a href="#1-6-서브쿼리" class="headerlink" title="1-6. 서브쿼리"></a>1-6. 서브쿼리</h3><p><img src="/images/jpa/jpql-7.png" alt="JPQL서브쿼리"></p>
<figure class="highlight sql"><figcaption><span>서브쿼리-1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#나이가 평균보다 많은 회원 </span><br><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m </span><br><span class="line"><span class="keyword">where</span> m.age <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(m2.age) <span class="keyword">from</span> <span class="keyword">Member</span> m2) </span><br><span class="line"></span><br><span class="line">#한건이라도주문한고객</span><br><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="built_in">count</span>(o) <span class="keyword">from</span> <span class="keyword">Order</span> o <span class="keyword">where</span> m <span class="operator">=</span> o.member) <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">#팀A 소속인 회원</span><br><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> t <span class="keyword">from</span> m.team t <span class="keyword">where</span> t.name <span class="operator">=</span> ‘팀A<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#전체 상품 각각의 재고보다 주문량이 많은 주문들</span></span><br><span class="line"><span class="string">select o from Order o </span></span><br><span class="line"><span class="string">where o.orderAmount &gt; ALL (select p.stockAmount from Product p)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#어떤 팀이든 팀에 소속된 회원</span></span><br><span class="line"><span class="string">select m from Member m </span></span><br><span class="line"><span class="string">where m.team = ANY (select t from Team t)</span></span><br></pre></td></tr></table></figure>

<h4 id="JPA-서브쿼리-한계"><a href="#JPA-서브쿼리-한계" class="headerlink" title="JPA 서브쿼리 한계"></a>JPA 서브쿼리 한계</h4><ul>
<li>JPA는 WHERE/HAVING절만 서브쿼리 사용가능 </li>
<li>하이버네이트에서는 SELECT절에서 서브쿼리 사용가능</li>
<li>FROM 절 서브쿼리는 현재 JPQL에서는 불가능 <ul>
<li>조인으로 풀수있으면 해결하고 그래도 안되면 쿼리를 쪼개서 처리하거나 그래도 안되면 native쿼리로 처리 해야함. </li>
</ul>
</li>
</ul>
<h3 id="1-7-JPQL-타입표현"><a href="#1-7-JPQL-타입표현" class="headerlink" title="1-7. JPQL 타입표현"></a>1-7. JPQL 타입표현</h3><h4 id="JPQL-타입-표현"><a href="#JPQL-타입-표현" class="headerlink" title="JPQL 타입 표현"></a>JPQL 타입 표현</h4><ul>
<li>문자: ‘HELLO’, ‘She’’s’ </li>
<li>Boolean: TRUE, FALSE</li>
<li>숫자: 10L(Long), 10D(Double), 10F(Float)</li>
<li>ENUM: jpabook.MemberType.Admin (패키지명 포함) </li>
<li>엔티티 타입: TYPE(m) = Member (상속 관계에서 사용)</li>
</ul>
<h4 id="JPQL-논리연산-및-비교연산"><a href="#JPQL-논리연산-및-비교연산" class="headerlink" title="JPQL 논리연산 및 비교연산"></a>JPQL 논리연산 및 비교연산</h4><ul>
<li>EXISTS, IN</li>
<li>AND, OR, NOT</li>
<li>=, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt; BETWEEN, LIKE, IS NULL</li>
</ul>
<h4 id="JPQL-연산자-우선순위"><a href="#JPQL-연산자-우선순위" class="headerlink" title="JPQL 연산자 우선순위"></a>JPQL 연산자 우선순위</h4><ol>
<li>경로탐색연산(.)</li>
<li>수학연산 : 단항연산자(+,-),*,/,+,-</li>
<li>비교연산 : =,&gt;,&gt;=,&lt;,&lt;=,&lt;&gt;(다름),BETWEEN,LIKE,IN,IS NULL,IS EMPTY,EXIST </li>
<li>논리연산 : AND,OR,NOT</li>
</ol>
<h3 id="1-8-CASE-식"><a href="#1-8-CASE-식" class="headerlink" title="1-8. CASE 식"></a>1-8. CASE 식</h3><p><img src="/images/jpa/jpql-8.png" alt="CASE1"><br><img src="/images/jpa/jpql-9.png" alt="COALESCE/NULLIF"></p>
<h3 id="1-9-기본함수"><a href="#1-9-기본함수" class="headerlink" title="1-9. 기본함수"></a>1-9. 기본함수</h3><ul>
<li>concat, substring, trim, lower/upper, length, locate, abs, sqrt, mod, size, index(jpq전용)</li>
</ul>
<h4 id="사용자-정의-함수"><a href="#사용자-정의-함수" class="headerlink" title="사용자 정의 함수"></a>사용자 정의 함수</h4><p><img src="/images/jpa/jpql-10.png" alt="사용자정의함수"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/05/07/jpa-obj-query-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 codexdawn. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">codexdawn</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-ikbi0v8fyzuu91xv5rmpcrnwb4qinfgborzd5kejmj8wr6ibfra8oaxqshyg.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
