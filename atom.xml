<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>codexdawn</title>
  
  
  <link href="https://codexdawn.github.io/atom.xml" rel="self"/>
  
  <link href="https://codexdawn.github.io/"/>
  <updated>2021-08-09T05:00:18.149Z</updated>
  <id>https://codexdawn.github.io/</id>
  
  <author>
    <name>codexdawn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin-basic-4</title>
    <link href="https://codexdawn.github.io/2021/08/05/kotlin-basic-4/"/>
    <id>https://codexdawn.github.io/2021/08/05/kotlin-basic-4/</id>
    <published>2021-08-05T07:59:46.000Z</published>
    <updated>2021-08-09T05:00:18.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="코틀린-타입-시스템"><a href="#코틀린-타입-시스템" class="headerlink" title="코틀린 타입 시스템"></a>코틀린 타입 시스템</h1><blockquote><ul><li>null 이 될수있는 타입과 null을 처리하는 구문의 문법 </li><li>코틀린 원시 타입 소개와 자바 타입과 코틀린 원시 타입의 관계 </li><li>코틀린 컬렉션 소개와 자바 컬렉션과 코틀린 컬렉션의 관계</li></ul></blockquote><h2 id="Null-가능성"><a href="#Null-가능성" class="headerlink" title="Null 가능성"></a>Null 가능성</h2><h3 id="Null이-될수있는-타입"><a href="#Null이-될수있는-타입" class="headerlink" title="Null이 될수있는 타입"></a>Null이 될수있는 타입</h3><ul><li>기본적으로 모든 타입은 null 허용이 안됨.</li><li>타입에 null을 허용하려면 ? 를 타입뒤에 붙여야함. (ex&gt; val x:String? = null) </li></ul><h3 id="안전한-호출-연산자"><a href="#안전한-호출-연산자" class="headerlink" title="안전한 호출 연산자: ?"></a>안전한 호출 연산자: ?</h3><ul><li>?. 연산자는 null검사와 메소드 호출을 한번의 연산으로 수행한다. (ex&gt; s?.toUpperCase() =&gt; if(s != null) s.toUpperCase() else null)</li><li>값이 존재하면 값을 리턴하고, 없으면 Null을 리턴해준다. </li><li>?. 연산자를 사용하면 반환타입은 ?로 반환해야함. (ex&gt; val allCaps: String? = s?.toUpperCase())</li></ul><h3 id="엘비스-연산자"><a href="#엘비스-연산자" class="headerlink" title="엘비스 연산자 : ?:"></a>엘비스 연산자 : ?:</h3><ul><li>?:(엘비스연산자)는 null대신 사용할 디폴트값을 지정할때 편리하게 사용하는 연산자</li></ul><figure class="highlight kotlin"><figcaption><span>evis</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(s:<span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> t:String = s ?: <span class="string">&quot;&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe</span><span class="params">(s:<span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> = s?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><figcaption><span>evis-throw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(<span class="keyword">val</span> streetAddress:String, <span class="keyword">val</span> zipCode:<span class="built_in">Int</span>, <span class="keyword">val</span> city:String, <span class="keyword">val</span> country:String) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> address:Address?)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> company:Company?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printShippingLabel</span><span class="params">(person:<span class="type">Person</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> address = person.company?.address ?: <span class="keyword">throw</span> IlleagalArgumentException(<span class="string">&quot;No Address&quot;</span>)</span><br><span class="line">with (address) &#123;</span><br><span class="line">println(streetAddress)</span><br><span class="line">println(<span class="string">&quot;<span class="variable">$zipcode</span> <span class="variable">$city</span>, <span class="variable">$country</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">val</span> address = Address(<span class="string">&quot;ElvisStreet&quot;</span>, <span class="number">110</span>, <span class="string">&quot;Sanfrancico&quot;</span>, <span class="string">&quot;USA&quot;</span>)</span><br><span class="line">&gt;&gt; <span class="keyword">val</span> company = Company(<span class="string">&quot;Algo&quot;</span>, address)</span><br><span class="line">&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Dawn&quot;</span>, company)</span><br><span class="line"></span><br><span class="line">&gt;&gt; printShippingLabel(person)</span><br><span class="line">&gt;&gt;&gt; ElvisStreet </span><br><span class="line">&gt;&gt;&gt; <span class="number">110</span> Sanfrancico, USA</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printShippingLabel(Person(<span class="string">&quot;Zero&quot;</span>,<span class="literal">null</span>))</span><br><span class="line">&gt;&gt;&gt; java.lang.IlleagalArgumentException: No Adress </span><br></pre></td></tr></table></figure><h3 id="안전한-캐스트-as"><a href="#안전한-캐스트-as" class="headerlink" title="안전한 캐스트: as?"></a>안전한 캐스트: as?</h3><ul><li>as는 타입캐스트를 시켜주는 연산자이다. as?는 ?연산자 처럼 타입이 존재하지 않으면 null을 리턴해줌. </li><li>val otherPerson = o as? Person ?: return false</li></ul><h3 id="Null-아님을-단언"><a href="#Null-아님을-단언" class="headerlink" title="Null 아님을 단언: !!"></a>Null 아님을 단언: !!</h3><ul><li>해당 타입 뒤에 !! 연산자를 붙이면 null이 들어오면 안된다는 소리다. 들어오면 NullPointerException 예외발생 </li><li>val sNotNull:String = s!! //null 들어오면 예외발생 </li><li>!! 연산자를 한줄에 여러 단언문을 사용하는 부분은 피하라 (어디서 예외가 발생했는지 알길이 없다.) (ex&gt; person.company!!.address!!.country -&gt; 이런거하면 어디서 null예외가 떨어졌는지 모른다.)</li></ul><h3 id="let-함수"><a href="#let-함수" class="headerlink" title="let 함수"></a>let 함수</h3><ul><li>let 은 해당 값이 null이아니면 수행, 아니면 미수행 처리해주는 역할을 한다.</li><li>여러값이 null인지를 검사해야한다면, let호출을 중첩시킬수있다. 하지만 코드가 클린하지 못하기때문에, 그럴땐 if를 사용해서 모든값을 한꺼번에 검사하는편이 좋다. </li></ul><figure class="highlight kotlin"><figcaption><span>let</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendToEmail</span><span class="params">(email: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;Sending email to <span class="variable">$email</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">var</span> email: String? = <span class="string">&quot;yolo@ex.com&quot;</span></span><br><span class="line">&gt;&gt; email?.let &#123; sendToEmail(it)&#125;</span><br><span class="line">&gt;&gt;&gt; Sending email to <span class="symbol">yolo@</span>ex.com</span><br><span class="line"></span><br><span class="line">&gt;&gt; email = <span class="literal">null</span></span><br><span class="line">&gt;&gt; email?.let&#123;sendToEmail(it)&#125;</span><br><span class="line">&gt;&gt;&gt; 아무실행없음</span><br><span class="line"></span><br><span class="line"><span class="comment">//let 사용안한예 </span></span><br><span class="line"><span class="keyword">val</span> person:Person? = getTheBestPersonInTheWorld()</span><br><span class="line"><span class="keyword">if</span>(persion != <span class="literal">null</span>) sendToEmail(person.email)</span><br><span class="line"></span><br><span class="line"><span class="comment">//let 사용예</span></span><br><span class="line">getTheBestPersonInTheWorld()?.let&#123;sendEmailTo(it.email)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//위함수가 null을 반환한다면? 아무일도 일어나지 않는다.</span></span><br></pre></td></tr></table></figure><h3 id="나중에-초기화할-프로퍼티-lateinit"><a href="#나중에-초기화할-프로퍼티-lateinit" class="headerlink" title="나중에 초기화할 프로퍼티 : lateinit"></a>나중에 초기화할 프로퍼티 : lateinit</h3><ul><li>lateinit을 사용시 반드시 var로 사용해야함. val로 사용시 final 필드로 컴파일되어 반드시 초기값을 요구하게됨. </li><li>프로퍼티를 초기화하기전에 lateinit변수에 접근하면 lateinit property myService has not been initialized 라는 예외가 발생함 </li><li>lateinit은 의존관계주입 (DI) 프레임워크와 함께 사용하는 경우가 많음. </li></ul><figure class="highlight kotlin"><figcaption><span>lateinit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performAction</span><span class="params">()</span></span>: String = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myService:MyService</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">myService = MyService()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;foo&quot;</span>, myService.performAction())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="null이-될수있는-타입-확장"><a href="#null이-될수있는-타입-확장" class="headerlink" title="null이 될수있는 타입 확장"></a>null이 될수있는 타입 확장</h3><ul><li>null이 될수있는 확장함수는 안전한 호출(? 연산자) 없이 호출 가능 </li><li>null이 허용된 변수에 대한 안전한 호출 없이 let 을 호출하면 람다의 인자는 null이 될수있는 타입으로 추론됨. 따라서 안전한 호출을 위해 ?연산자를 반드시 사용해야함. </li></ul><h3 id="타입-파라미터의-null가능성"><a href="#타입-파라미터의-null가능성" class="headerlink" title="타입 파라미터의 null가능성"></a>타입 파라미터의 null가능성</h3><ul><li>제네릭타입 (타입 파라미터) 를 사용하게 되면 타입명끝에 ?가 없더라도 T가 null이 될수 있는 타입이다. </li></ul><figure class="highlight kotlin"><figcaption><span>generic</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printHashCode</span><span class="params">(t:<span class="type">T</span>)</span></span> &#123;</span><br><span class="line">println(t?.hashCode()) <span class="comment">//타입 파라미터 t는 무조건 안전한 호출을 통해서만 가져와야함.T의 타입은 Any?로 반드시 추론됨. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; printHashCode(<span class="literal">null</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="코틀린의-원시타입"><a href="#코틀린의-원시타입" class="headerlink" title="코틀린의 원시타입"></a>코틀린의 원시타입</h2><h3 id="원시타입-Int-Boolean-등"><a href="#원시타입-Int-Boolean-등" class="headerlink" title="원시타입 : Int, Boolean 등.."></a>원시타입 : Int, Boolean 등..</h3><ul><li>자바에서는 원시타입 , 참조타입으로 사용하지만 코틀린은 하나의 타입으로만 사용함 </li><li>코틀린은 하나의 타입으로만 사용하기때문에 늘 객체로 타입을 받지않고, 케바케로 자바로 컴파일시 원시타입 으로 줄지 참조타입으로 줄지 구분 해서 반환하게됨. (컬렉션과 같은 제네릭을 사용할경우는 객체로 나머지는 원시타입으로 저장)</li><li>코틀린에서는 오토박싱 처리 되는 부분이 불가능하다. 예를들면 Int형타입의 변수를 Long으로 변경하는것 처럼 자바에서는 되는 부분이 코틀린에서는 불가능하다. 이유는 타입안정성때문. 따라서 Int형타입을 Long으로 변경후 사용해야함.</li></ul><h3 id="Any-Any-최상위타입-Object"><a href="#Any-Any-최상위타입-Object" class="headerlink" title="Any,Any? : 최상위타입 (Object)"></a>Any,Any? : 최상위타입 (Object)</h3><ul><li>Any는 자바에서 Object타입이라 생각하면 됨. </li></ul><h3 id="Unit타입-코틀린의-void"><a href="#Unit타입-코틀린의-void" class="headerlink" title="Unit타입 : 코틀린의 void"></a>Unit타입 : 코틀린의 void</h3><ul><li>Unit타입은 자바의 void와 흡사한 기능을한다. </li><li>Unit과 void는 뭔차이인가? Unit은 void와 달리 타입 인자로 사용가능. (제네릭파라미터를 반환하는 함수를 오버라이드하면서 반환타입으러 Unit을 쓸때 유용함. )</li></ul><figure class="highlight kotlin"><figcaption><span>Unit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>:T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoResultProcessor</span>: <span class="type">Processor</span>&lt;<span class="type">Unit</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// process code </span></span><br><span class="line"><span class="comment">// Unit이기때문에 return 없음. </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다"><a href="#Nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다" class="headerlink" title="Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.."></a>Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다..</h3><ul><li>Nothing은 기본적으로 아무것도 포함하지 않음. 따라서 Nothing은 함수의 반환타입이나 반환타입으로 쓰일 타입 파라미터로만 쓸수있음. </li><li>Nothing을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제조건을 검사할수있음. </li></ul><h2 id="컬렉션과-배열"><a href="#컬렉션과-배열" class="headerlink" title="컬렉션과 배열"></a>컬렉션과 배열</h2><h3 id="컬렉션"><a href="#컬렉션" class="headerlink" title="컬렉션"></a>컬렉션</h3><ul><li>코틀린에서 컬렉션은 읽기전용 컬렉션 과 변경가능한 컬렉션 두가지를 나눠서 사용가능</li><li>코틀린에서는 가능하면 읽기전용 컬렉션을 디폴트로 사용하길 권장함. (일반적인 규약으로 지침함) 컬렉션을 변경해야할때만 변경가능한 버전을 사용하길 권장 </li><li>읽기전용 컬렉션이 항상 스레드 안전하지는 않다. 따라서 다중 스레드 환경에서는 데이터를 다루는경우, 그 데잍러를 적절히 동기화 하거나 동시 접근을 허용하는 데이터 구조를 활용해야함. </li></ul><h3 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h3><ul><li>배열상태에서 람다로 연산 수행 가능 (ex&gt; val squres = IntArray(5) {i -&gt; (i+1) * (i+1)})</li><li>filter,map 등의 처리도 가능함. </li><li>배열에도 똑같이 확장함수를 사용할수잇다. 다만 이런 함수가 반환하는 값은 배열이 아니라 리스트로 변환됨. </li><li>원시타입 배열 (int/long등) 도 제공함 </li><li>코들린의 Array는 자바 배열로 컴파일됨 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;코틀린-타입-시스템&quot;&gt;&lt;a href=&quot;#코틀린-타입-시스템&quot; class=&quot;headerlink&quot; title=&quot;코틀린 타입 시스템&quot;&gt;&lt;/a&gt;코틀린 타입 시스템&lt;/h1&gt;&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;null 이 될수있는 타입과 null</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="KotlinInAction" scheme="https://codexdawn.github.io/categories/KotlinInAction/"/>
    
    <category term="코틀린문법&amp;기초" scheme="https://codexdawn.github.io/categories/%EC%BD%94%ED%8B%80%EB%A6%B0%EB%AC%B8%EB%B2%95-%EA%B8%B0%EC%B4%88/"/>
    
    
    <category term="kotlin" scheme="https://codexdawn.github.io/tags/kotlin/"/>
    
    <category term="kotlininaction" scheme="https://codexdawn.github.io/tags/kotlininaction/"/>
    
    <category term="kotlin문법" scheme="https://codexdawn.github.io/tags/kotlin%EB%AC%B8%EB%B2%95/"/>
    
    <category term="코틀린 타입 시스템" scheme="https://codexdawn.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C/"/>
    
  </entry>
  
  <entry>
    <title>kotlin-basic-3</title>
    <link href="https://codexdawn.github.io/2021/07/24/kotlin-basic-3/"/>
    <id>https://codexdawn.github.io/2021/07/24/kotlin-basic-3/</id>
    <published>2021-07-24T05:19:04.000Z</published>
    <updated>2021-08-03T08:11:06.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="람다로-프로그래밍"><a href="#람다로-프로그래밍" class="headerlink" title="람다로 프로그래밍"></a>람다로 프로그래밍</h1><h2 id="코틀린의-람다는"><a href="#코틀린의-람다는" class="headerlink" title="코틀린의 람다는?"></a>코틀린의 람다는?</h2><ul><li>코틀린의 람다는 자바8의 문법과 거의 유사하다. </li><li>val sum = {x:Int, y:Int -&gt; x+y} 이 예시로 보면 자바의 약간의 차이점이라면 컬리브레이션을 전체로 감싼다는것이 특징임 </li></ul><figure class="highlight java"><figcaption><span>kotlin-lambda</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val people = listOf(Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>,<span class="number">37</span>))</span><br><span class="line">println(people.maxBy(it.age)) </span><br><span class="line"><span class="comment">// people.maxBy(&#123;p:Person -&gt; p.age&#125;) or people.maxBy()&#123;p:Person-&gt;p.age&#125; or people.maxBy()&#123;p -&gt; p.age&#125;</span></span><br></pre></td></tr></table></figure><h3 id="현재-영역에-있는-변수에-접근-변수-캡처링-클로저"><a href="#현재-영역에-있는-변수에-접근-변수-캡처링-클로저" class="headerlink" title="현재 영역에 있는 변수에 접근 (변수 캡처링? 클로저?)"></a>현재 영역에 있는 변수에 접근 (변수 캡처링? 클로저?)</h3><ul><li>자바에서도 람다에서 해당 메소드의 변수에 접근할수있게 도와주는 변수캡처링 (클로저)를 지원한다. </li><li>자바와 차이점은 자바8에서는 람다에서 접근하는 변수가 final(불변변수) 만 접근가능하지만, 코틀린은 불변이 아니어도 접근가능하다. </li></ul><figure class="highlight java"><figcaption><span>kotlin-변수캡쳐링</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">printMessageWithPrefix</span><span class="params">(message: Collection&lt;String&gt;, prefix:String)</span> </span>&#123;</span><br><span class="line">message.forEach &#123;</span><br><span class="line">println(<span class="string">&quot;$prefix $it&quot;</span>) <span class="comment">// 람다로 prefix 정보를 받았음 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">printProblemCounts</span><span class="params">(res:Collection&lt;String&gt;)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> clientError = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> serverError = <span class="number">0</span> </span><br><span class="line">res.forEach &#123;</span><br><span class="line"><span class="keyword">if</span>(it.startWith(<span class="string">&quot;4&quot;</span>)) &#123;</span><br><span class="line">clientError++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(it.startWith(<span class="string">&quot;5&quot;</span>)) &#123;</span><br><span class="line">serverError++ </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="멤버-참조-java-메소드-레퍼런스"><a href="#멤버-참조-java-메소드-레퍼런스" class="headerlink" title="멤버 참조 (java:메소드 레퍼런스)"></a>멤버 참조 (java:메소드 레퍼런스)</h3><ul><li>자바의 메소드 레퍼런스와 동일함 </li></ul><figure class="highlight java"><figcaption><span>kotlin-메소드레퍼런스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val people = listOf(Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>,<span class="number">37</span>))</span><br><span class="line">people.maxBy(Person::age)</span><br></pre></td></tr></table></figure><h2 id="컬렉션-함수형-API"><a href="#컬렉션-함수형-API" class="headerlink" title="컬렉션 함수형 API"></a>컬렉션 함수형 API</h2><ul><li>자바8에서 사용하던 stream의 filter,map 등 어느정도 문법이 유사함 (생각하는 문법이 거의 맞음)</li></ul><h3 id="filter-map-Collection-Map-사용"><a href="#filter-map-Collection-Map-사용" class="headerlink" title="filter/map, Collection Map 사용"></a>filter/map, Collection Map 사용</h3><figure class="highlight java"><figcaption><span>kotlin-stream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val people = listOf(Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>,<span class="number">37</span>))</span><br><span class="line">people.filter&#123; it.age &gt; <span class="number">30</span>&#125;</span><br><span class="line">people.map(People::name)</span><br><span class="line"><span class="comment">// people.filter&#123;it.age &gt; 30&#125;.map(People::name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Collection Map에서도 사용가능 </span></span><br><span class="line">val numbers = mapOf(<span class="number">0</span> to <span class="string">&quot;zero&quot;</span>, <span class="number">1</span> to <span class="string">&quot;one&quot;</span>)</span><br><span class="line">numbers.mapValues&#123;it.value.toUpperCase()&#125; <span class="comment">//filterValues,mapValues등도 사용가능 </span></span><br></pre></td></tr></table></figure><h3 id="all-any-count-find"><a href="#all-any-count-find" class="headerlink" title="all,any,count,find"></a>all,any,count,find</h3><ul><li>all: 해당 조건이 모든 엘리먼트가 만족하는 경우 true 아님 false리턴 (java8 : allMatch)</li><li>any: 해당 조건이 일부 엘리먼트가 하나라도 만족하는 경우 true 아님 false 리턴 (java8: anyMatch)</li><li>count: 갯수 리턴 </li><li>find: 해당 조건에 맞는 원소 하나라도 만족하면 해당 엘리먼트 리턴 없으면 null를 리턴함. (java8: findFirst)</li></ul><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><figure class="highlight java"><figcaption><span>kotlin-groupby</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val people = listOf(Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>,<span class="number">37</span>))</span><br><span class="line">people.groupBy&#123;it.age&#125;</span><br><span class="line"></span><br><span class="line">&gt; &#123;<span class="number">29</span>=[Person(name=Alice,age=<span class="number">29</span>)], <span class="number">37</span>=[Person(name=Bob,age=<span class="number">37</span>)]&#125;</span><br><span class="line"></span><br><span class="line">val list = listOf(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">list.groupBy(String::first)</span><br><span class="line">&gt; a=[a,ab], b=[b]</span><br></pre></td></tr></table></figure><h3 id="flatMap-flatten-중첩된-컬렉션의-안의-원소-처리"><a href="#flatMap-flatten-중첩된-컬렉션의-안의-원소-처리" class="headerlink" title="flatMap, flatten : 중첩된 컬렉션의 안의 원소 처리"></a>flatMap, flatten : 중첩된 컬렉션의 안의 원소 처리</h3><figure class="highlight java"><figcaption><span>kotlin-flatmap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(val title:String, val authors:List&lt;String&gt;)</span><br><span class="line">val books = listOf(Book(<span class="string">&quot;Thursday Next&quot;</span>, listOf(<span class="string">&quot;Jasper Fforde&quot;</span>)), Book(<span class="string">&quot;Mart&quot;</span>, listOf(<span class="string">&quot;Terry Pratchett&quot;</span>)), Book(<span class="string">&quot;Good Omens&quot;</span>, listOf(<span class="string">&quot;Terry Pratchett&quot;</span>, <span class="string">&quot;Neil Gaiman&quot;</span>)))</span><br><span class="line">books.flatMap&#123;it.authors&#125;.toSet()</span><br><span class="line">&gt; [Jasper Fforde,Terry Pratchett,Neil Gaiman]</span><br></pre></td></tr></table></figure><ul><li>리스트의 리스트가 있는데 모든 중첩된 리스트의 원소를 한 리스트로 모아야한다면 flatMap을 떠올리겠지만, 특별히 변환해야할 내용이 없다면 리스트의 리스트를 평평하게 펼치ㄱ만 하면됨. 그런경우에는 listOfLists.flatten() 처럼 flatten함수를 사용할수있음 </li></ul><h3 id="지연계산-lazy-컬렉션-연산"><a href="#지연계산-lazy-컬렉션-연산" class="headerlink" title="지연계산(lazy) 컬렉션 연산"></a>지연계산(lazy) 컬렉션 연산</h3><ul><li>앞서 map/filter 같은 함수는 컬렉션을 즉시(eager) 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다. </li><li>시퀀스(sequence)를 사용하면 중간 임시 컬렉션을 사용하지않고 컬렉션 연산이 가능하다. </li><li>시퀀스의 원소는 필요할때 계산된다. 따라서 중간 처리 결과를 저장하지 않고 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할수있다. </li><li>시퀀스 연산은 중간 연산(filter/map)과 최종 연산(toList)으로 나뉜다. (java8 stream과 방식이 유사)</li><li>최종연산을 수행하지 않고 중간연산만 수행하면 아무내용도 출력하지 않음. 이유는 최종연산이 호출될때 결과를 리턴하는 lazy 연산이기 때문.  </li></ul><figure class="highlight java"><figcaption><span>kotlin-lazy-sequence</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).asSequence()</span><br><span class="line">.map&#123;print(<span class="string">&quot;map($it)&quot;</span>); it * it&#125;</span><br><span class="line">.filter(print(<span class="string">&quot;filter($it)&quot;</span>) it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">.toList();</span><br><span class="line"></span><br><span class="line">-&gt; map(<span class="number">1</span>) filter(<span class="number">1</span>) filter(<span class="number">4</span>) map(<span class="number">3</span>) filter(<span class="number">9</span>) map(<span class="number">4</span>) filter(<span class="number">16</span>)</span><br></pre></td></tr></table></figure><h3 id="시퀀스-만들기"><a href="#시퀀스-만들기" class="headerlink" title="시퀀스 만들기"></a>시퀀스 만들기</h3><ul><li>generate sequence라고 생각하면됨. </li></ul><figure class="highlight java"><figcaption><span>kotlin-generate-sequence</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val naturalNumbers = generateSequence(<span class="number">0</span>) &#123;it + <span class="number">1</span>&#125;</span><br><span class="line">val numberTo100 = naturalNumbers.takeWhile( it &lt;= <span class="number">100</span>)</span><br><span class="line">numberTo100.sum()</span><br><span class="line"> </span><br><span class="line">fun File.isInsideHiddenDirectory() = generateSquence(<span class="keyword">this</span>) &#123;it.parentFile&#125;.any&#123;it.isHidden&#125; </span><br><span class="line">val file = File(<span class="string">&quot;/Users/ss/.HiddenDir/a.txt&quot;</span>)</span><br><span class="line">file.isInsideHiddenDirectory()</span><br></pre></td></tr></table></figure><h2 id="자바-함수형-인터페이스"><a href="#자바-함수형-인터페이스" class="headerlink" title="자바 함수형 인터페이스"></a>자바 함수형 인터페이스</h2><ul><li>람다 와 무명객체는 객체를 명시적으로 선언하는경우 메소드를 호출할때마다 새로운 객체가 생성됨. 람다는 다르다. 정의가 들어있는함수의 변수에 접근하지 않는 람다에 대응하는 무명객체를 메소드를 호출할때마다 반복사용함. </li><li>변수캡처링(클로저)를 활용하여 함수형 인터페이스를 호출하면 매번 인스턴스를 생성하고 호출하게됨. </li></ul><h3 id="코틀린에서-자바-함수형-인터페이스-활용방법"><a href="#코틀린에서-자바-함수형-인터페이스-활용방법" class="headerlink" title="코틀린에서 자바 함수형 인터페이스 활용방법"></a>코틀린에서 자바 함수형 인터페이스 활용방법</h3><figure class="highlight java"><figcaption><span>kotlin-sam-1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//객체식을 함수형 인터페이스 구현으로 넘김 </span></span><br><span class="line">postponeComputation(<span class="number">1000</span>, object: Runnable &#123;</span><br><span class="line"><span class="function">override fun <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">println(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//프로그램 전체에서 Runnable의 인스턴스는 단 하나만 만들어짐 </span></span><br><span class="line">postponeComputation(<span class="number">1000</span>) &#123;println(<span class="number">42</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//전역변수로 컴파일되므로 프로그램 안에 단 하난의 인스턴스만 존재함. </span></span><br><span class="line">val run = Runnable&#123;println(<span class="number">42</span>)&#125;</span><br><span class="line"><span class="function">fun <span class="title">handleComputation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">postponeComputation(<span class="number">1000</span>, run) <span class="comment">//모든 handleComputation 호출에 같은 객체를 사용함. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">handleComputaion</span><span class="params">(id:String)</span> </span>&#123; <span class="comment">//id 변수 캡처링 </span></span><br><span class="line">postponeComputation(<span class="number">1000</span>) &#123;println(id)&#125; <span class="comment">// handleComputation을 호출할때마다 새로운 Runnable인터페이스를 생성함. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SAM-생성자-람다를-함수형-인터페이스로-명시적으로-변경"><a href="#SAM-생성자-람다를-함수형-인터페이스로-명시적으로-변경" class="headerlink" title="SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경"></a>SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경</h3><ul><li>SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할수있게 컴파일러가 자동으로 생성한 함수다. </li><li>컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 SAM생성자를 사용할수있음. </li><li>SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다. SAM생성자는 그 함수형 인터페이스의 유일한 추상 메서드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다. </li></ul><figure class="highlight java"><figcaption><span>kotlin-sam-2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">createAllDoneRunnable</span><span class="params">()</span>:Runnable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Runnable&#123;println(<span class="string">&quot;All Done!&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">createAllDoneRunnable().run()</span><br><span class="line">All Done! </span><br></pre></td></tr></table></figure><h2 id="수신-객체-지정-람다-with와-apply"><a href="#수신-객체-지정-람다-with와-apply" class="headerlink" title="수신 객체 지정 람다 : with와 apply"></a>수신 객체 지정 람다 : with와 apply</h2><h3 id="with-함수"><a href="#with-함수" class="headerlink" title="with 함수"></a>with 함수</h3><figure class="highlight java"><figcaption><span>kotlin-with</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//normal</span></span><br><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">val result = StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (letter in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">result.append(letter)</span><br><span class="line">&#125;</span><br><span class="line">result.append(<span class="string">&quot;\n Now I Know Alphabet!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//with1 </span></span><br><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">val result = StringBuilder();</span><br><span class="line"><span class="keyword">return</span> with(result) &#123;</span><br><span class="line"><span class="keyword">for</span> (letter in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.append(letter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">append(<span class="string">&quot;\n Now I Know Alphabet!&quot;</span>)</span><br><span class="line"><span class="keyword">this</span>.toString()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//with2 </span></span><br><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span> </span>= with(StringBuilder()) &#123;</span><br><span class="line"><span class="keyword">for</span>(letter in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">append(letter)</span><br><span class="line">&#125;</span><br><span class="line">append(<span class="string">&quot;\n Now I Know Alphabet!&quot;</span>)</span><br><span class="line">toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply-함수"><a href="#apply-함수" class="headerlink" title="apply 함수"></a>apply 함수</h3><ul><li>with와 거의같지만, 유일한 차이는 자신에게 전달된 객체를 반환한다. <figure class="highlight java"><figcaption><span>kotlin-apply</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apply1</span></span><br><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span> </span>= StringBuilder().apply &#123;</span><br><span class="line"><span class="keyword">for</span>(letter in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">append(letter)</span><br><span class="line">&#125;</span><br><span class="line">append(<span class="string">&quot;\n Now I Know Alphabet!&quot;</span>)</span><br><span class="line">&#125;.toString()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;람다로-프로그래밍&quot;&gt;&lt;a href=&quot;#람다로-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;람다로 프로그래밍&quot;&gt;&lt;/a&gt;람다로 프로그래밍&lt;/h1&gt;&lt;h2 id=&quot;코틀린의-람다는&quot;&gt;&lt;a href=&quot;#코틀린의-람다는&quot; class=&quot;</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="KotlinInAction" scheme="https://codexdawn.github.io/categories/KotlinInAction/"/>
    
    <category term="코틀린문법&amp;기초" scheme="https://codexdawn.github.io/categories/%EC%BD%94%ED%8B%80%EB%A6%B0%EB%AC%B8%EB%B2%95-%EA%B8%B0%EC%B4%88/"/>
    
    
    <category term="kotlin" scheme="https://codexdawn.github.io/tags/kotlin/"/>
    
    <category term="kotlininaction" scheme="https://codexdawn.github.io/tags/kotlininaction/"/>
    
    <category term="kotlin문법" scheme="https://codexdawn.github.io/tags/kotlin%EB%AC%B8%EB%B2%95/"/>
    
    <category term="람다" scheme="https://codexdawn.github.io/tags/%EB%9E%8C%EB%8B%A4/"/>
    
  </entry>
  
  <entry>
    <title>kotlin-basic-2</title>
    <link href="https://codexdawn.github.io/2021/07/14/kotlin-basic-2/"/>
    <id>https://codexdawn.github.io/2021/07/14/kotlin-basic-2/</id>
    <published>2021-07-14T03:50:30.000Z</published>
    <updated>2021-07-14T10:10:36.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="코틀린-클래스-객체-인터페이스"><a href="#코틀린-클래스-객체-인터페이스" class="headerlink" title="코틀린 클래스/객체/인터페이스"></a>코틀린 클래스/객체/인터페이스</h1><h2 id="코틀린-인터페이스"><a href="#코틀린-인터페이스" class="headerlink" title="코틀린 인터페이스"></a>코틀린 인터페이스</h2><ul><li>자바8에서 제공하는 인터페이스와 유사한 부분이 많다. (default메서드 기능 /일반적인 인터페이스)</li><li>자바와달리 정의된 메서드를 구현체에서 구현메서드에 override 키워드를 반드시 넣어야함 </li><li>코틀린에서는 default 메서드를 구현할적에 Default 키워드를 안붙여도됨 </li><li>코틀린에서는 default 메서드는 자바8과 유사하다 override로 구현을 따로해도되고, interface상에 구현되어있는 default메서드 사용해도됨. 단, 이름과 시그니처가 같은 디폴트 구현이 2개이상이 있는경우는 반드시 override로 구현해줘야함. 안그러면 컴파일 에러발생함. </li><li>자바에서 상위 타입을 가져올때 super를 사용하는데, 코틀린에서는 super&lt;?&gt;로 구현해야함 </li></ul><figure class="highlight java"><figcaption><span>interface</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span> </span>&#123;</span><br><span class="line"><span class="function">fun <span class="title">click</span><span class="params">()</span> <span class="comment">//일반 메소드 정의</span></span></span><br><span class="line"><span class="function">fun <span class="title">showOff</span><span class="params">()</span> </span>= println(<span class="string">&quot;I&#x27;m clickable!&quot;</span>) <span class="comment">// 디폴트 메서드 구현 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Focusable</span> </span>&#123;</span><br><span class="line"><span class="function">fun <span class="title">setFocus</span><span class="params">(b: Boolean)</span> </span>= println(<span class="string">&quot;I $&#123;if(b) &quot;</span>got<span class="string">&quot; else &quot;</span>lost<span class="string">&quot;&#125; focus. &quot;</span>)</span><br><span class="line"><span class="function">fun <span class="title">showOff</span><span class="params">()</span> </span>= println(<span class="string">&quot;I&#x27;m focusable!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button: Clickable, Focusable &#123;</span><br><span class="line"><span class="function">override fun <span class="title">click</span><span class="params">()</span> </span>= println(<span class="string">&quot;I was clicked!&quot;</span>)</span><br><span class="line"><span class="function">override fun <span class="title">showOff</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">super</span>&lt;Clickable&gt;.showOff(); </span><br><span class="line"><span class="keyword">super</span>&lt;Focusable&gt;.showOff(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="open-final-abstarct-변경자-기본적으로-final"><a href="#open-final-abstarct-변경자-기본적으로-final" class="headerlink" title="open,final,abstarct 변경자: 기본적으로 final"></a>open,final,abstarct 변경자: 기본적으로 final</h2><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><ul><li>자바에서 클래스에 final은 상속을 금지하는 키워드이다. </li><li>상속을 허용하려면 open 키워드로 상속을 가능하도록 만들어야함. </li></ul><figure class="highlight java"><figcaption><span>open클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">open class RichButton:Clickable &#123;</span><br><span class="line"><span class="function">fun <span class="title">disable</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 이함수는 final 이다. 하위클래스가 이 메소드를 orverride할수없음.</span></span><br><span class="line"><span class="function">open fun <span class="title">animate</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//이함수는 open이다. 하위클래스가 override할수있음.</span></span><br><span class="line"><span class="function">override fun <span class="title">click</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 이 함수는 열려있는 메소드를 확장받은 메소드기때문에 기본적으로 open되어있음. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abstarct"><a href="#abstarct" class="headerlink" title="abstarct"></a>abstarct</h3><figure class="highlight java"><figcaption><span>abstract클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animated</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> fun <span class="title">animate</span><span class="params">()</span> <span class="comment">// 이 함수는 추상함수. 구현은 당연없다. 하위클래스에서 반드시 구현해야함. </span></span></span><br><span class="line"><span class="function">open fun <span class="title">stopAnimating</span><span class="params">()</span> </span>&#123; <span class="comment">// 추상클래스에 속했더라도 비추상함수는 기본적으로 final이지만, 원한다면 open으로 override를 허용할수있음. </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fun <span class="title">animateTwice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="가시성-변경자-기본적으로-공개-access-modifier"><a href="#가시성-변경자-기본적으로-공개-access-modifier" class="headerlink" title="가시성 변경자 : 기본적으로 공개 (access modifier)"></a>가시성 변경자 : 기본적으로 공개 (access modifier)</h3><ul><li>public, internal, protected, private 4가지 접근제어자로 구성되어있음. </li><li>자바와달리 default 접근제어자는 public이다</li><li>internal : 같은 모듈안에서만 볼수있음. (클래스멤버,최상위선언)</li><li>protected : 클래스멤버는 하위 클래스 안에서만 볼수있고, 최상위 선언은 적용안됨.</li><li>private: 클래스멤버는 같은 클래스안에서만 볼수있고, 최상위선언은 같은 파일안에서만볼수있음. </li></ul><h4 id="코틀린의-모듈"><a href="#코틀린의-모듈" class="headerlink" title="코틀린의 모듈?"></a>코틀린의 모듈?</h4><ul><li>gradle/maven/ant 등으로 컴파일되는 단위를 모듈이라함. (claim-api 모듈 / 포함되어있는 모듈까지 domain)</li></ul><h3 id="내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스"><a href="#내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" class="headerlink" title="내부 클래스와 중첩된 클래스 : 기본적으로 중첩 클래스"></a>내부 클래스와 중첩된 클래스 : 기본적으로 중첩 클래스</h3><ul><li>코틀린 내부에 클래스를 선언하면 기본적으로 중첩클래스가 됨 (자바에서는 static class로 선언해야 묵시적 참조가 사라지기때문)</li><li>내부클래스로 지정하면 바깥쪽 클래스에 대한 참조를 저장하게됨. (자바에서는 class 로 선언함. 코틀린에서는 inner키워드붙이고, this@참조할클래스 네임으로 바깥쪽 클래스의 참조를 확인할수있음.)</li></ul><h3 id="봉인된클래스-클래스-계층정의시-계층-확장-제한"><a href="#봉인된클래스-클래스-계층정의시-계층-확장-제한" class="headerlink" title="봉인된클래스 : 클래스 계층정의시 계층 확장 제한"></a>봉인된클래스 : 클래스 계층정의시 계층 확장 제한</h3><ul><li>코틀린에서는 봉인된클래스(sealed class)를 제공하는데, 이전장에서 Expr interface로 Num / Sum class를 구현하도록 하였었다. 하지만 Num/Sum 클래스만 들어온다는 보장이 안되기때문에, else문으로 포함된 클래스가 아니면 예외처리를하였는데, 이부분을 해소하려면 sealed class로 노출하는 클래스를 지정하면 된다. </li></ul><figure class="highlight java"><figcaption><span>sealed class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sealed <span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">class Num(val value:Int): Expr()</span><br><span class="line">class Sum(val left:Expr, val right:Expr):Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">eval</span><span class="params">(e: Expr)</span> : Int </span>= </span><br><span class="line">when(e) &#123;</span><br><span class="line">is Expr.Num -&gt; e.value</span><br><span class="line">is Expr.Sum -&gt; eval(e.right) + eval(e.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="코틀린-클래스-초기화-방법"><a href="#코틀린-클래스-초기화-방법" class="headerlink" title="코틀린 클래스 초기화 방법"></a>코틀린 클래스 초기화 방법</h2><h3 id="클래스-초기화"><a href="#클래스-초기화" class="headerlink" title="클래스 초기화"></a>클래스 초기화</h3><figure class="highlight java"><figcaption><span>class초기화방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//기본적인 주생성자 생성 및 초기화 </span></span><br><span class="line"><span class="function">open class <span class="title">User</span><span class="params">(val name:String)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">class TwitterUser(val name:String): User(name) &#123;&#125; //기반클래스의 주생성자를 가져올때</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secretive</span> <span class="title">private</span> <span class="title">constructor</span>() </span>&#123;&#125; <span class="comment">//유틸클래스에 선언하는 비공개생성자 (이렇게 비공개생성자 대신 최상위함수 혹은 object클래스(싱글톤)활용하자.) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//부생성자 생성법 및 확장 하였을때 사용방법 </span></span><br><span class="line">open <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">constructor(ctx: Context) &#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor(ctx:Context, attr: AttributeSet) &#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyButton: View &#123;</span><br><span class="line">constructor(ctx:Context):<span class="keyword">super</span>(ctx) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contructor(ctx:Context, attr:AttributeSet):<span class="keyword">super</span>(ctx,attr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor(xtx:Context) : <span class="keyword">this</span>(ctx,MY_STYLE) &#123; <span class="comment">// 2번째 부생성자에게 위임하도록함.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor(ctx:Context,attr:AttributeSet):<span class="keyword">super</span>(ctx,attr) &#123; <span class="comment">//상위클래스에 생성하도록 위임</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>클래스에 주생성자가 없다면 모든 부생성자는 반드시 상위클래스를 초기화하거나 다른생성자에게 생성을 위임해야함! </li></ul><h3 id="인터페이스에-선언된-프로퍼티-구현"><a href="#인터페이스에-선언된-프로퍼티-구현" class="headerlink" title="인터페이스에 선언된 프로퍼티 구현"></a>인터페이스에 선언된 프로퍼티 구현</h3><figure class="highlight java"><figcaption><span>interface프로퍼티구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">val name:String </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PrivateUser(ovveride val name:String):User </span><br><span class="line"></span><br><span class="line">class SubscribingUser(val email:String): User &#123;</span><br><span class="line">override val name:String </span><br><span class="line">get() = email.substringBefore(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FacebookUser(val accoutId:Int):User &#123;</span><br><span class="line">override val name = getFacebookName(accoutId) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(PrivateUser(<span class="string">&quot;test@js.com&quot;</span>).name) </span><br><span class="line">-&gt; test<span class="meta">@js</span>.com</span><br><span class="line">&gt;&gt;&gt; println(SubscribingUser(<span class="string">&quot;test@js.com&quot;</span>).name)</span><br><span class="line">-&gt; test </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임"><a href="#컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임" class="headerlink" title="컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임"></a>컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임</h2><h3 id="data-class"><a href="#data-class" class="headerlink" title="data class"></a>data class</h3><ul><li>data class는 toString, equals, hashCode 를 자동생성해줌 (롬복 @Data 와 유사함)</li><li>equals에서는 동등비교할때 ==을 사용하고 , 실제값을 비교할때는 ===(주소값까지 비교) </li><li>hashCode는 HashSet과 같은 Hash류들을 사용할때 객체의 해시코드로 먼저 비교해서 해시코드가 같은경우만 실제값을비교하도록 하는 부분 (Hash류 쓸때는 반드시 재정의하자)</li></ul><h3 id="클래스-위임-by-키워드-사용"><a href="#클래스-위임-by-키워드-사용" class="headerlink" title="클래스 위임 : by 키워드 사용"></a>클래스 위임 : by 키워드 사용</h3><ul><li>위임을 사용하는 목적은 코틀린은 기본적으로 final클래스로 확장이 불가능하게 되어있는데(open해야만 가능) 종종 이런 상속이 허용되지 않는 클래스에 새로운 동작을 추가해야할때가 있다. 이때 클래스 위임기능을 활용하면 됨. </li></ul><figure class="highlight java"><figcaption><span>위임방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CountingSet&lt;T&gt;(val innerSet:MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet &#123;</span><br><span class="line"><span class="keyword">var</span> objectsAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">add</span><span class="params">(e : T)</span>: Boolean </span>&#123;</span><br><span class="line">objectsAdded++</span><br><span class="line"><span class="keyword">return</span> innerSet.add(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ovveride fun <span class="title">addAll</span><span class="params">(c: Collection&lt;T&gt;)</span>:Boolean </span>&#123;</span><br><span class="line">objectsAdded += c.size</span><br><span class="line"><span class="keyword">return</span> innerSet.addAll(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val cset = CountingSet&lt;Int&gt;()</span><br><span class="line">cset.addAll(listOf(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">//HashSet이기본구현체라 중복제거되서 리스트저장됨 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="object키워드-클래스-선언과-인스턴스-생성"><a href="#object키워드-클래스-선언과-인스턴스-생성" class="headerlink" title="object키워드: 클래스 선언과 인스턴스 생성"></a>object키워드: 클래스 선언과 인스턴스 생성</h2><ul><li>object키워드를 사용하면 싱글턴을 정의할수있음</li><li>companion object는 동반객체라 불리는데, 팩토리 메소드를 담을때 쓰임 동반 객체 메소드에 접근할때는 동반 객체가 포함된 클래스의 이름을 사용할수있다. </li><li>객체 식은 자바의 무명내부클래스 대신 쓰임 <h3 id="object-사용방법"><a href="#object-사용방법" class="headerlink" title="object 사용방법"></a>object 사용방법</h3></li></ul><figure class="highlight java"><figcaption><span>object키워드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">object Payroll &#123;</span><br><span class="line">val allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">calculateSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(persiojn in allEmployees) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//object 활용방법 </span></span><br><span class="line">&gt;&gt;&gt; Payroll.allEmployees.add(Persion(..))</span><br><span class="line">&gt;&gt;&gt; Payroll.calculateSalary()</span><br><span class="line"></span><br><span class="line">object CaseInsentiveFileComparator: Comparator&lt;File&gt; &#123;</span><br><span class="line"><span class="function">override fun <span class="title">compare</span><span class="params">(file1:File,fil2:File)</span>:Int </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fil1.path.compareTo(fil2.path. ignoreCase=<span class="keyword">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; CaseInsentiveFileComparator.compare(File(<span class="string">&quot;/User&quot;</span>),File(<span class="string">&quot;/user&quot;</span>))</span><br><span class="line">-&gt; <span class="number">0</span> </span><br><span class="line">&gt;&gt;&gt; val files = listOf(File(<span class="string">&quot;/Z&quot;</span>), File(<span class="string">&quot;/a&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; files.sortedWith(CaseInsentiveFileComparator) -&gt; object클래스를 인자로 넘길수있음.  </span><br></pre></td></tr></table></figure><ul><li>object는 클래스안에서 객체를 선언할수있다. 그런 객체도 인스턴스는 단한개뿐(바깥클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 하나씩 따로 생기는것은 아니다.) 예를들어 Comparator클래스는 클래스 내부에 정의하는게 더 바람직함 </li></ul><h4 id="싱글턴과-의존관계-주입"><a href="#싱글턴과-의존관계-주입" class="headerlink" title="싱글턴과 의존관계 주입"></a>싱글턴과 의존관계 주입</h4><ul><li>싱글턴패턴은 대규모 소프트웨어 시스템에서는 객체 선언이 항상 적합하지않음. 이유는 객체 생성을 제어할 방법이 없고 생성자 파라미터를 지정할수 없기때문에 </li><li>생성을 제어할수없고 생성자 파라미터를 지정할수 없으므로 단위테스트를 하거나 시스템설정이 달라질때 객체를 대체하거나 의존관계를 바꿀수없음 따라서 자바와 마찬가지로 의존관계 주입 프레임워크(스프링,구글주스) 와 코틀린 클래스를 함께 사용해야함 </li></ul><h3 id="companion-object"><a href="#companion-object" class="headerlink" title="companion object"></a>companion object</h3><ul><li>코틀린은 static 키워드를 지원안함 </li><li>static이 없지만 패키지 수준의 최상위 함수 와 객체 선언을 활용함 (대부분 최상위함수 사용을 권장함)</li><li>최상위함수는 비공개 멤버에 접근할수없음 하지만 companion object를 사용하면 private접근자를 호출할수있음 </li><li>companion object는 생성자 팩토리 메서드를 만들어준다고 생각하면 됨. (of,tranfer같은작업들 메서드 선언 가능함)</li><li>companion object는 객체처럼 활용가능함 (ex&gt; companion object Loader {//…} =&gt; Person.Loader.fromJSON)</li><li>companion object는 확장함수로 확장가능하다. (ex&gt; fun Person.Companion.fromJSON(json:String):Person) </li></ul><h3 id="객체식-무명-내부-클래스를-다른-방식으로-작성"><a href="#객체식-무명-내부-클래스를-다른-방식으로-작성" class="headerlink" title="객체식 : 무명 내부 클래스를 다른 방식으로 작성"></a>객체식 : 무명 내부 클래스를 다른 방식으로 작성</h3><ul><li>object키워드는 싱글턴과 같은 객체를 정의하고 그 객체에 이름붙일때만 사용하지않는다. 무명객체를 정의할때도 object키워드를 사용함 </li><li>object클래스와 달리 무명객체는 싱글턴이 아님 객체식이 쓰일때마다 새로운 인스턴스가 생성됨!!! </li><li>자바의 무명클래스와 같이 객체식 안의 코드는 그 식이 포함된 함수의 변수에 접근할수있다. 자바는 final만 접근가능했지만, 객체식은 var/val 둘다 접근가능하다. </li></ul><figure class="highlight java"><figcaption><span>객체식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">countClicks</span><span class="params">(window:Window)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">window.addMouseListener(object: MouseAdapter() &#123;</span><br><span class="line"><span class="function">override fun <span class="title">mouseClicked</span><span class="params">(e:MouseEvent)</span> </span>&#123;</span><br><span class="line">clickCount++</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//.... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;코틀린-클래스-객체-인터페이스&quot;&gt;&lt;a href=&quot;#코틀린-클래스-객체-인터페이스&quot; class=&quot;headerlink&quot; title=&quot;코틀린 클래스/객체/인터페이스&quot;&gt;&lt;/a&gt;코틀린 클래스/객체/인터페이스&lt;/h1&gt;&lt;h2 id=&quot;코틀린-인터페이스</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="KotlinInAction" scheme="https://codexdawn.github.io/categories/KotlinInAction/"/>
    
    <category term="코틀린문법&amp;기초" scheme="https://codexdawn.github.io/categories/%EC%BD%94%ED%8B%80%EB%A6%B0%EB%AC%B8%EB%B2%95-%EA%B8%B0%EC%B4%88/"/>
    
    
    <category term="kotlin" scheme="https://codexdawn.github.io/tags/kotlin/"/>
    
    <category term="kotlininaction" scheme="https://codexdawn.github.io/tags/kotlininaction/"/>
    
    <category term="kotlin문법" scheme="https://codexdawn.github.io/tags/kotlin%EB%AC%B8%EB%B2%95/"/>
    
    <category term="클래스,객체,인터페이스" scheme="https://codexdawn.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>kotlin-basic-1</title>
    <link href="https://codexdawn.github.io/2021/07/13/kotlin-basic-1/"/>
    <id>https://codexdawn.github.io/2021/07/13/kotlin-basic-1/</id>
    <published>2021-07-13T07:56:35.000Z</published>
    <updated>2021-07-14T02:49:11.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-코틀린"><a href="#1-코틀린" class="headerlink" title="1. 코틀린?"></a>1. 코틀린?</h1><h2 id="코틀린-특징"><a href="#코틀린-특징" class="headerlink" title="코틀린 특징"></a>코틀린 특징</h2><ol><li>정적 타입 지정 언어 <ul><li>타입을 컴파일 시점에 컴파일러가 타입 검증을 해준다는 의미.</li><li>동적 타입 지정 언어는? 런타임 시점에서 타입 검증을 함. (runtime시점에 오류가 발견됨)</li></ul></li><li>함수형/객체지향 프로그래밍 지원 <ul><li>일급시민함수 <ul><li>함수를 변수에 저장하고, 인자로 다른 함수에 전달하고 함수에서 새로운 함수를 만들어 반환 할수있는 함수를 어디서든 적용가능한 개념 </li></ul></li><li>불변성 <ul><li>일단 만들어지면 내부 상태가 절대로 바뀌지않음. (기본 final처럼 불변으로 되어있음.)</li></ul></li><li>사이드이펙트 없음 <ul><li>불변성과 이어지는 맥락인데, input 과 output이 같다. 외부함수 혹은 다른 바깥환경에 영향받지 않고 입력한 함수 그대로 리턴해주는 개념 </li></ul></li></ul></li><li>안드로이드 및 서버 개발 지원 </li></ol><h2 id="코틀린-기초-문법"><a href="#코틀린-기초-문법" class="headerlink" title="코틀린 기초 문법"></a>코틀린 기초 문법</h2><h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><figure class="highlight java"><figcaption><span>함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//함수 기초 </span></span><br><span class="line"><span class="function">fun <span class="title">max</span><span class="params">(a: Int, b: Int)</span>: Int </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//한줄로 변경 가능 중괄호 제거 </span></span><br><span class="line"><span class="comment">//타입추론으로 리턴되는 타입을 생략해도 되지만 가급적 넣어주자. </span></span><br><span class="line"><span class="function">fun <span class="title">max</span><span class="params">(a:Int, b:Int)</span>:Int </span>= <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h3><ol><li>val <ul><li>자바에서 final임. 기본이 불변</li><li>val변수는 블록실행할때 정확하게 한번만 수행해야함. </li><li>val참조 자체는 불변이지만, 그 참조가 가리키는 객체의 내부값은 변경될수있음. </li></ul></li><li>var <ul><li>일반 자바변수와 동일 </li></ul></li></ol><figure class="highlight java"><figcaption><span>변수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 블록당 한번 초기화  </span></span><br><span class="line">val msg:String </span><br><span class="line"><span class="keyword">if</span>(valid()) &#123;</span><br><span class="line">msg = <span class="string">&quot;Success&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg = <span class="string">&quot;Fail&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 불변참조</span></span><br><span class="line">val list = arrayListOf(<span class="string">&quot;Java&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Kotlin&quot;</span>) <span class="comment">// 불변이지만 이렇게 값이 추가되거나 변경되는건 가능</span></span><br></pre></td></tr></table></figure><h3 id="클래스-amp-프로퍼티"><a href="#클래스-amp-프로퍼티" class="headerlink" title="클래스 &amp; 프로퍼티"></a>클래스 &amp; 프로퍼티</h3><figure class="highlight java"><figcaption><span>클래스&프로퍼티</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String,  //val로 하면 읽기전용(getter만 허용)</span><br><span class="line"><span class="keyword">var</span> isMarried:Boolean) <span class="comment">//var로하면 읽기/쓰기 모두 가능 (getter/setter 둘다가능)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//클래스 인스턴스 생성 </span></span><br><span class="line"><span class="keyword">var</span> person = Person(<span class="string">&quot;JS&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//커스텀 접근 </span></span><br><span class="line">class Rectangle(val height:Int, val width:Int) &#123;</span><br><span class="line">val isSquare:Boolean </span><br><span class="line">get() &#123;</span><br><span class="line"><span class="keyword">return</span> height == width </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="코틀린-소스코드-구조-디렉터리와-패키지"><a href="#코틀린-소스코드-구조-디렉터리와-패키지" class="headerlink" title="코틀린 소스코드 구조: 디렉터리와 패키지"></a>코틀린 소스코드 구조: 디렉터리와 패키지</h3><ul><li>코틀린도 자바와 동일하게 import한후 클래스 및 기타 정의 가능 </li><li>자바에서는 패키지 구조내에 클래스명과 동일한 클래스파일을 생성하는 소스구조지만, 코트린은 kt파일자체가 패키지라고 생각하면됨. (파일 내부에 여러 클래스 인터페이스 정의 가능)</li></ul><h3 id="enum-when"><a href="#enum-when" class="headerlink" title="enum / when"></a>enum / when</h3><figure class="highlight java"><figcaption><span>enum&when</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Color</span> (</span></span><br><span class="line">    val r: Int, val g: Int, val b: Int    </span><br><span class="line">) &#123;</span><br><span class="line">    RED(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), ORANGE(<span class="number">255</span>,<span class="number">165</span>,<span class="number">0</span>),</span><br><span class="line">    YELLOW(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),GREEN(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),</span><br><span class="line">    BLUE(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),INDIGO(<span class="number">75</span>,<span class="number">0</span>,<span class="number">130</span>),</span><br><span class="line">    VIORET(<span class="number">238</span>,<span class="number">130</span>,<span class="number">238</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function">fun <span class="title">rgb</span><span class="params">()</span> </span>= (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(Color.BLUE.rgb()) <span class="comment">// &gt;&gt;&gt; 255 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//when1 </span></span><br><span class="line"><span class="function">fun <span class="title">getWarmth</span><span class="params">(color: Color)</span> </span>= when (color) &#123;</span><br><span class="line">    Color.RED, Color.YELLOW, Color.ORANGE -&gt; <span class="string">&quot;warm&quot;</span> </span><br><span class="line">    Color.GREEN -&gt; <span class="string">&quot;natural&quot;</span></span><br><span class="line">    Color.BLUE, Color.INDIGO, Color.VIORET -&gt; <span class="string">&quot;cold&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//when2 -&gt; setOf컬렉션 사용으로 구분 </span></span><br><span class="line"><span class="function">fun <span class="title">mix</span><span class="params">(c1: Color, c2: Color)</span> </span>= when (setOf(c1,c2)) &#123;</span><br><span class="line">    setOf(RED,YELLOW) -&gt; ORANGE</span><br><span class="line">    setOf(YELLOW,BLUE) -&gt; GREEN</span><br><span class="line">    setOf(BLUE,VIORET) -&gt; INDIGO</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty Color&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//when3 -&gt; 인자없이 구분 </span></span><br><span class="line"><span class="function">fun <span class="title">mixOptimized</span><span class="params">(c1: Color, c2: Color)</span> </span>= when &#123;</span><br><span class="line">    (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; ORANGE</span><br><span class="line">    (c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt; GREEN</span><br><span class="line">    (c1 == BLUE &amp;&amp; c2 == VIORET) || (c1 == VIORET &amp;&amp; c2 == BLUE) -&gt; INDIGO</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty Color&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="스마트캐스팅-타입검사-및-타입-캐스트"><a href="#스마트캐스팅-타입검사-및-타입-캐스트" class="headerlink" title="스마트캐스팅 : 타입검사 및 타입 캐스트"></a>스마트캐스팅 : 타입검사 및 타입 캐스트</h3><figure class="highlight java"><figcaption><span>스마트캐스팅</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span></span></span><br><span class="line">class Num(val value:Int): Expr //Expr인터페이스구현 </span><br><span class="line">class Sum(val left:Expr, val right:Expr): Expr // Expr인터페이스로 Num/Sum 인자로 받을수있음 </span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">eval</span><span class="params">(e:Expr)</span>: Int </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(e is Num ) &#123;<span class="comment">//Num클래스인지 확인 </span></span><br><span class="line"><span class="comment">//val n = e as Num //명시적인 타입 캐스팅 </span></span><br><span class="line"><span class="comment">//return n.value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> e.value <span class="comment">//is로 검사한부분은 코틀린이 알아서 자동 캐스팅을 해줌. 그래서 명시적인 캐스팅을 할 필요가 없음</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(e is Sum) &#123;</span><br><span class="line">eval(e.right) + eval(e.left) <span class="comment">//return 생략가능 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown Expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-while-loop"><a href="#for-while-loop" class="headerlink" title="for/while loop"></a>for/while loop</h3><ol><li>while루프는 자바와 동일 </li><li>for <ul><li>자바처럼 기본형태의 for문은 없음 </li></ul></li></ol><figure class="highlight java"><figcaption><span>for문</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(num in <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;$&#123;fizzBuzz(num)&#125; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(num in <span class="number">100</span> downTo <span class="number">1</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;$&#123;fizzBuzz(num)&#125; \n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val binaryReps = TreeMap&lt;Char,String&gt;()</span><br><span class="line"><span class="keyword">for</span>(c in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">val binary = Integer.toBinaryString(c.toInt())</span><br><span class="line">binaryReps[c] = binary </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>((letter,binary) in binaryReps) &#123;</span><br><span class="line">println(<span class="string">&quot;$letter = $binary&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val list = arrayListOf(<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;1100&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>((index,element) in list.withIndex()) &#123;</span><br><span class="line">println(<span class="string">&quot;$index: $element&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="in-으로-컬렉션-혹은-범위의-원소-검사"><a href="#in-으로-컬렉션-혹은-범위의-원소-검사" class="headerlink" title="in 으로 컬렉션 혹은 범위의 원소 검사"></a>in 으로 컬렉션 혹은 범위의 원소 검사</h3><figure class="highlight java"><figcaption><span>in으로 range검사</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">isLetter</span><span class="params">(c:Char)</span> </span>= c in <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> || c in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="function">fun <span class="title">isNotDigit</span><span class="params">(c:Char)</span> </span>= c !in <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span></span><br><span class="line"><span class="function">fun <span class="title">recognize</span><span class="params">(c: Char)</span> </span>= when(c) &#123;</span><br><span class="line">    in <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="string">&quot;It&#x27;s digit!&quot;</span></span><br><span class="line">    in <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>, in <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;It&#x27;s letter!&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;I don&#x27;t know...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try, catch, finally"></a>try, catch, finally</h3><figure class="highlight java"><figcaption><span>try-catch-finally</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//java와 달리 코틀린은 함수에 throws 정의하는 명령어가 없음. </span></span><br><span class="line"><span class="function">fun <span class="title">readNumber</span><span class="params">(reader: BufferedReader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// java와 문법은 거의 흡사함 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        val line = reader.readLine()</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(line)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//try-catch return </span></span><br><span class="line">    val number = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">null</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//try-with-resoruce </span></span><br><span class="line">File(<span class="string">&quot;/home/aasmund/test.txt&quot;</span>).inputStream().use &#123;</span><br><span class="line"> val bytes = it.readBytes()</span><br><span class="line"> println(bytes.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="함수-정의-및-호출"><a href="#함수-정의-및-호출" class="headerlink" title="함수 정의 및 호출"></a>함수 정의 및 호출</h3><figure class="highlight java"><figcaption><span>joinTotring</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun&lt;T&gt; <span class="title">joinToString</span><span class="params">(collection:Cellection&lt;T&gt;, </span></span></span><br><span class="line"><span class="function"><span class="params">seperate:String = <span class="string">&quot;, &quot;</span>, // defalt값을 넣을수있음.  </span></span></span><br><span class="line"><span class="function"><span class="params">prefix:String = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">postfix:String = <span class="string">&quot;&quot;</span>)</span>:String </span>&#123;</span><br><span class="line"></span><br><span class="line">val result = StringBuilder(prefix)</span><br><span class="line"><span class="keyword">for</span>((index,element) in collection.withIndex()) &#123;</span><br><span class="line"><span class="keyword">if</span>(index &gt; <span class="number">0</span>) result.append(separate) <span class="comment">//두번째 원소부터 separate 붙임</span></span><br><span class="line">result.append(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result.append(postfix)</span><br><span class="line"><span class="keyword">return</span> result.toString() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; joinToString(collection, separate=<span class="string">&quot; &quot;</span>, prefix=<span class="string">&quot; &quot;</span>,postfix=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; joinToString(collection) <span class="comment">//기본설정된 파라미터로 출력됨 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="최상위-함수와-프로퍼티"><a href="#최상위-함수와-프로퍼티" class="headerlink" title="최상위 함수와 프로퍼티"></a>최상위 함수와 프로퍼티</h3><ul><li>kt파일 생성하고 클래스 생성없이 fun함수 하나만 걸어두면 정적메서드화됨 (유틸클래스처럼)</li><li>kt파일 생성하고 변수를 설정하면 정적 변수가 설정됨 (글로벌 변수가 됨)</li></ul><h3 id="확장함수-와-확장-프로퍼티"><a href="#확장함수-와-확장-프로퍼티" class="headerlink" title="확장함수 와 확장 프로퍼티"></a>확장함수 와 확장 프로퍼티</h3><ul><li>확장함수는 마치 어떤 클래스의 멤버 메서드 처럼 호출 가능하지만, 그 클래스 밖에서 선언된 함수다. </li><li>확장프로퍼티는 확장함수내에 getter/setter를 세팅하는 작업이다. </li></ul><figure class="highlight java"><figcaption><span>확장함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"></span><br><span class="line">fun String.lastChar(): Char = <span class="keyword">this</span>.get(<span class="keyword">this</span>.length-<span class="number">1</span>) <span class="comment">//this는 수신객체 (String 이다.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//확장프로퍼티</span></span><br><span class="line">val String.lastChar: Char </span><br><span class="line">get() = get(length-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> String.lastChar: Char</span><br><span class="line">get() = get(length-<span class="number">1</span>)</span><br><span class="line">set(value:Char) &#123;</span><br><span class="line"><span class="keyword">this</span>.setCharAt(length-<span class="number">1</span>,value) <span class="comment">//String의 setCharAt호출 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////import시켜서 사용하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> strings.lastChar <span class="comment">//확장함수를 마치 기존 멤버메서드처럼 import도 가능함. </span></span><br><span class="line"></span><br><span class="line">val c  <span class="string">&quot;Kotlin&quot;</span>.lastChar()</span><br><span class="line"></span><br><span class="line"><span class="comment">//joinToString 확장함수판! </span></span><br><span class="line">fun&lt;T&gt; Collection&lt;T&gt;.joinToString(seperate:String = <span class="string">&quot;, &quot;</span>, <span class="comment">// defalt값을 넣을수있음.  </span></span><br><span class="line">prefix:String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">postfix:String = <span class="string">&quot;&quot;</span>):String &#123;</span><br><span class="line"></span><br><span class="line">val result = StringBuilder(prefix)</span><br><span class="line"><span class="keyword">for</span>((index,element) in collection.withIndex()) &#123;</span><br><span class="line"><span class="keyword">if</span>(index &gt; <span class="number">0</span>) result.append(separate) <span class="comment">//두번째 원소부터 separate 붙임</span></span><br><span class="line">result.append(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result.append(postfix)</span><br><span class="line"><span class="keyword">return</span> result.toString() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="확장함수-참고"><a href="#확장함수-참고" class="headerlink" title="확장함수 참고"></a>확장함수 참고</h4><ul><li>자바에서 확장함수사용하려면  그냥 자바에서는 StringUtilKt.lastChar(“Kotlin”) 이런식으로 호출하면됨 (StringUtil.kt파일이 있을때)</li><li>이쯤되면 확장함수의 원리가 궁금한데, 확장함수는 그냥 유틸클래스 처럼 정적 함수로 구현되어있음 </li><li>정적함수 특성상 오버라이드가 안됨. (프로퍼티도 마찬가지!)</li><li>확장함수는 해당 클래스의 멤버변수를 접근할수있음!!</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-코틀린&quot;&gt;&lt;a href=&quot;#1-코틀린&quot; class=&quot;headerlink&quot; title=&quot;1. 코틀린?&quot;&gt;&lt;/a&gt;1. 코틀린?&lt;/h1&gt;&lt;h2 id=&quot;코틀린-특징&quot;&gt;&lt;a href=&quot;#코틀린-특징&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="KotlinInAction" scheme="https://codexdawn.github.io/categories/KotlinInAction/"/>
    
    <category term="코틀린문법&amp;기초" scheme="https://codexdawn.github.io/categories/%EC%BD%94%ED%8B%80%EB%A6%B0%EB%AC%B8%EB%B2%95-%EA%B8%B0%EC%B4%88/"/>
    
    
    <category term="kotlin" scheme="https://codexdawn.github.io/tags/kotlin/"/>
    
    <category term="kotlininaction" scheme="https://codexdawn.github.io/tags/kotlininaction/"/>
    
    <category term="kotlin문법" scheme="https://codexdawn.github.io/tags/kotlin%EB%AC%B8%EB%B2%95/"/>
    
  </entry>
  
  <entry>
    <title>couchbase-work-1</title>
    <link href="https://codexdawn.github.io/2021/07/07/couchbase-work-1/"/>
    <id>https://codexdawn.github.io/2021/07/07/couchbase-work-1/</id>
    <published>2021-07-07T06:45:34.000Z</published>
    <updated>2021-07-07T09:00:03.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CouchBase-삽질-도전기"><a href="#CouchBase-삽질-도전기" class="headerlink" title="CouchBase 삽질 도전기"></a>CouchBase 삽질 도전기</h1><h2 id="CouchBase"><a href="#CouchBase" class="headerlink" title="CouchBase ?"></a>CouchBase ?</h2><ul><li>기존적으로 json문서 지원 (RDBMS와 달리 스키마가 없어서 document db 라고 불림)<ul><li>key - value 형태 (key: string, value : json)</li></ul></li><li>cache db로 조회속도가 빠름 <ul><li>memcached 도 지원됨.</li></ul></li><li>SQL 지원해서 RDBMS사용하듯 사용할수는 있음 (N1QL)<ul><li>정확하게 말하면 SQL형태임 (where/group by /order by 등으로 )</li></ul></li><li>스키마리스 <ul><li>스카마가 없어서 유연하게 테이블 구성이 가능함 </li></ul></li><li>인덱싱 가능 <ul><li>N1QL로 인덱싱 조회 가능 (데이터양이 많음 인덱스사용 가능)</li></ul></li><li>확장성 (multi-master구조) <ul><li>엘라스틱서치처럼 master-slave구조가 아닌 multi-master구조임 </li><li>auto sharding지원 (각 shard마다 자동 동기화 진행 및 분산 처리 가능)</li><li>서버추가를 복잡한 과정없이 추가가능 </li></ul></li><li>다양한 언어 지원 <ul><li>JAVA/Python/PHP/RUBY 등 다양한 언어 지원</li></ul></li><li>Bucket ?<ul><li>Bucket은 RDBMS의 테이블이라고 생각하면 된다. </li></ul></li></ul><h2 id="CouchBase-세팅-방법-JAVA-Spring-Boot-기준"><a href="#CouchBase-세팅-방법-JAVA-Spring-Boot-기준" class="headerlink" title="CouchBase 세팅 방법 (JAVA/Spring Boot 기준)"></a>CouchBase 세팅 방법 (JAVA/Spring Boot 기준)</h2><h3 id="설정-및-사전세팅"><a href="#설정-및-사전세팅" class="headerlink" title="설정 및 사전세팅"></a>설정 및 사전세팅</h3><figure class="highlight plain"><figcaption><span>application-xxx.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  couchbase:</span><br><span class="line">    cluster:</span><br><span class="line">      contents-cluster:</span><br><span class="line">        userName: &#123;접속할 couchbase id&#125;</span><br><span class="line">        password: &#123;password&#125;</span><br><span class="line">        ip:</span><br><span class="line">          - &#123;ip주소&#125;</span><br><span class="line">        bucket:</span><br><span class="line">          - name: promotion-cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Bucket</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>BucketRouterName</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BucketRouterName</span> </span>&#123;</span><br><span class="line">    PROMOTION(<span class="string">&quot;promotion-cache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String bucket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ClusterRouterName</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ClusterRouterName</span> </span>&#123;</span><br><span class="line">    CONTENTS(<span class="string">&quot;contents-cluster&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>CouchbaseDatasource</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseDatasource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ip;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Bucket&gt; bucket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConnectionString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;,&quot;</span>,<span class="keyword">this</span>.ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>CouchbaseHolder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cache.couchbase&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,CouchbaseDatasource&gt; cluster = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CouchbaseDatasource <span class="title">getClient</span><span class="params">(ClusterRouterName clusterRouterName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.cluster.get(clusterRouterName.getCluster()), <span class="string">&quot;Map&lt;String, CouchbaseDatasource&gt; must not be null. Please check application.yml : cache.couchbase.cluster&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cluster.get(clusterRouterName.getCluster());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>CouchbaseConnector</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.couchbase.client.core.env.TimeoutConfig;</span><br><span class="line"><span class="keyword">import</span> com.couchbase.client.java.Cluster;</span><br><span class="line"><span class="keyword">import</span> com.couchbase.client.java.ClusterOptions;</span><br><span class="line"><span class="keyword">import</span> com.couchbase.client.java.env.ClusterEnvironment;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.couchbase.CouchbaseClientFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.couchbase.SimpleCouchbaseClientFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.couchbase.core.CouchbaseTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseConnector</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CouchbaseHolder couchbaseHolder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, CouchbaseTemplate&gt; couchbaseTemplate = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CONNECTION_TIMEOUT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CouchbaseConnector</span><span class="params">(CouchbaseHolder couchbaseHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.couchbaseHolder = couchbaseHolder;</span><br><span class="line">        <span class="keyword">this</span>.setCouchbaseTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCouchbaseTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ClusterEnvironment clusterEnvironment = ClusterEnvironment.builder()</span><br><span class="line">                .timeoutConfig(TimeoutConfig.connectTimeout(Duration.ofSeconds(CONNECTION_TIMEOUT))).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String clusterName : couchbaseHolder.getCluster().keySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> CouchbaseDatasource couchbaseDatasource = couchbaseHolder.getCluster().get(clusterName);</span><br><span class="line">            <span class="keyword">final</span> String userName = couchbaseDatasource.getUserName();</span><br><span class="line">            <span class="keyword">final</span> String password = couchbaseDatasource.getPassword();</span><br><span class="line"></span><br><span class="line">            Cluster cluster = Cluster.connect(couchbaseDatasource.getConnectionString(), ClusterOptions.clusterOptions(userName, password).environment(clusterEnvironment));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Bucket bucket : couchbaseDatasource.getBucket()) &#123;</span><br><span class="line">                <span class="keyword">final</span> CouchbaseClientFactory couchbaseClientFactory = <span class="keyword">new</span> SimpleCouchbaseClientFactory(cluster,bucket.getName(),<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">final</span> CouchbaseTemplate template = <span class="keyword">new</span> CouchbaseTemplate(couchbaseClientFactory,<span class="keyword">new</span> MappingCouchbaseConverter());</span><br><span class="line"></span><br><span class="line">                couchbaseTemplate.put(clusterName + bucket.getName(),template);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;couchbase datasource : &#123;&#125;&quot;</span>,couchbaseDatasource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CouchbaseTemplate <span class="title">getCouchbaseTemplate</span><span class="params">(<span class="keyword">final</span> ClusterRouterName clusterRouterName, <span class="keyword">final</span> BucketRouterName bucketRouterName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.couchbaseTemplate.get(clusterRouterName.getCluster() + bucketRouterName.getBucket()),</span><br><span class="line">                <span class="string">&quot;ClusterRouteName : &quot;</span> + clusterRouterName.getCluster() + <span class="string">&quot; or BucketRouteName : &quot;</span> + bucketRouterName.getBucket() + <span class="string">&quot; must not be null. Please check application.yml : cache.couchbase.cluster&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.couchbaseTemplate.get(clusterRouterName.getCluster() + bucketRouterName.getBucket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.couchbaseTemplate.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;couchbaseTemplate is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>CouchbaseConfig</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CouchbaseHolder.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CouchbaseHolder couchbaseHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CouchbaseConnector <span class="title">getCouchbaseConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CouchbaseConnector(couchbaseHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>CouchbaseClient</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.content.domain.configuration.cache.config.BucketRouterName;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.content.domain.configuration.cache.config.ClusterRouterName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CouchbaseClientApi</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">findOne</span><span class="params">(<span class="keyword">final</span> ClusterRouterName clusterRouterName, <span class="keyword">final</span> BucketRouterName bucketRouterName, <span class="keyword">final</span> String id, <span class="keyword">final</span> Class&lt;T&gt; entityClass)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wemakeprice.v.content.domain.configuration.cache.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.content.domain.configuration.cache.config.BucketRouterName;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.content.domain.configuration.cache.config.ClusterRouterName;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.content.domain.configuration.cache.config.CouchbaseConnector;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.content.domain.exception.etc.CouchbaseClientInitializeException;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.couchbase.core.CouchbaseTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseClient</span> <span class="keyword">implements</span> <span class="title">CouchbaseClientApi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CouchbaseConnector couchbaseConnector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CouchbaseTemplate <span class="title">getCouchbaseTemplate</span><span class="params">(<span class="keyword">final</span> ClusterRouterName clusterRouterName, <span class="keyword">final</span> BucketRouterName bucketRouterName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CouchbaseTemplate couchbaseTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            couchbaseTemplate = couchbaseConnector.getCouchbaseTemplate(clusterRouterName,bucketRouterName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Couchbase Initialize Error : &#123;&#125;&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CouchbaseClientInitializeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> couchbaseTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">findOne</span><span class="params">(<span class="keyword">final</span> ClusterRouterName clusterRouterName, <span class="keyword">final</span> BucketRouterName bucketRouterName, <span class="keyword">final</span> String id, <span class="keyword">final</span> Class&lt;T&gt; entityClass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getCouchbaseTemplate(clusterRouterName, bucketRouterName).findById(entityClass).one(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean ?"></a>InitializingBean ?</h3><ul><li>afterPropertiesSet() 메서드를 반드시 구현하게 되어있음 </li><li>BeanFactory에 의해 모든 property가 설정된뒤 실행되는 메소드 </li><li>주로 실행시점에 custom초기화 로직을 넣거나, 주입받은 property를 확인할때 사용함 </li></ul><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="ConfigurationProperties ?"></a>ConfigurationProperties ?</h3><ul><li>application.yml 과 같이 yml에 설정파일을 등록해두는데, ConfigurationProperties 사용하면 yml혹은 정의된 경로의 properties에 정의돈 property들을 가져와서 Bean으로 등록시켜줌. </li><li>spring boot 2.2 이상부터는 EnableConfigurationProperties를 사용할 필요가 없다고함. 컨테이너에서 알아서 등록해서 바인딩까지 해주는듯하다. 추가적으로 @Component 혹은 @Configuration 과 같은 애너테이션도 추가할 필요없음. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CouchBase-삽질-도전기&quot;&gt;&lt;a href=&quot;#CouchBase-삽질-도전기&quot; class=&quot;headerlink&quot; title=&quot;CouchBase 삽질 도전기&quot;&gt;&lt;/a&gt;CouchBase 삽질 도전기&lt;/h1&gt;&lt;h2 id=&quot;CouchBase</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="couchbase" scheme="https://codexdawn.github.io/categories/couchbase/"/>
    
    
    <category term="couchbase" scheme="https://codexdawn.github.io/tags/couchbase/"/>
    
    <category term="NoSQL" scheme="https://codexdawn.github.io/tags/NoSQL/"/>
    
    <category term="document db" scheme="https://codexdawn.github.io/tags/document-db/"/>
    
    <category term="memcached" scheme="https://codexdawn.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>jpa-work-1</title>
    <link href="https://codexdawn.github.io/2021/06/22/jpa-work-1/"/>
    <id>https://codexdawn.github.io/2021/06/22/jpa-work-1/</id>
    <published>2021-06-22T13:34:43.000Z</published>
    <updated>2021-06-22T14:03:42.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collection-Fetch에서-limit를-하니까-메모리를-다-올려버리네"><a href="#Collection-Fetch에서-limit를-하니까-메모리를-다-올려버리네" class="headerlink" title="Collection Fetch에서 limit를 하니까 메모리를 다 올려버리네?"></a>Collection Fetch에서 limit를 하니까 메모리를 다 올려버리네?</h1><p>오늘 업무를 하다가 JPA쪽 이슈를 발견하게 되었다. Collection Fetch 로 데이터 조회를 기존에 잘했었는데, 최대 20개 제한로직이 걸리는 바람에 기존 로직에서 limit를 걸게되었다. 그래서 아무생각없이 fetchJoin걸린상태에서 limit를 걸었더니.. Collection Fetch조인한상태에서 페이징 로직을 걸면 발생하는 연관된 모든 엔티티를 메모리에 다 올려버리는 경고 창이 뜨게 되었다. (크읍.. 처음봤다..) 대략 소스는 아래와 같다.</p><figure class="highlight java"><figcaption><span>문제의 코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//after limit 20 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SimilarBrandGroupEntity <span class="title">findByBrandCode</span><span class="params">(Long brandCode)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jpaQueryFactory</span><br><span class="line">           .selectFrom(QSimilarBrandGroupEntity.similarBrandGroupEntity)</span><br><span class="line">           .join(similarBrandEntity).fetchJoin()</span><br><span class="line">           .where(isEqualsBrandCode(brandCode), isUsableTrue())</span><br><span class="line">           .limit(<span class="number">20L</span>)</span><br><span class="line">.fetchOne();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>위 와 같이 하니까, </p><p><strong>HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!</strong> </p><p>위 문구와 함께 정상적으로 노출은되었지만, 성능에 지대한 영향을 끼칠수밖에 없는 이슈가 발생하기때문에 당장 고쳐야했다.<br>그래서 JPA공부한대로, Collection Fetch조인시 fetchJoin빼고, @BatchSize를 넣어봤지만, 쿼리는 한방에 나간것 같은데, 쿼리가 2방이 나갔다. 그것도 좀 이상한 쿼리가 나가서, 검색 해본 결과 대략 3가지 방법으로 줄여지게 되었음.  </p><ol><li>projection 처리 (해당 사용방법 채택)<ul><li>projection처리하는 방법이 여러가지 있는데, 가장 베스트는 @queryprojection으로 사용하는것이 베스트임.</li></ul></li><li>Native SQL <ul><li>@Query로 직접 쿼리 작성 </li></ul></li><li>collection fetchjoin하지 말고 반대기준으로 조회 <ul><li>ManyToOne쪽기준으로 조회 하면 정상적으로 된다고 함. </li></ul></li></ol><figure class="highlight java"><figcaption><span>해결 코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Long&gt; <span class="title">findSimilarBrandCodesByGroupBrandCode</span><span class="params">(Long brandCode)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jpaQueryFactory</span><br><span class="line">           .select(getSimilarBrandCodesProjection())</span><br><span class="line">           .from(similarBrandGroupEntity, similarBrandGroupEntity)</span><br><span class="line">           .join(similarBrandGroupEntity.brands, similarBrandEntity)</span><br><span class="line">           .where(isEqualsBrandCode(brandCode), isUsableTrue())</span><br><span class="line">           .limit(MAX_DISPLAY_BRAND_CODES)</span><br><span class="line">           .fetch()</span><br><span class="line">           ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@queryprojection은 아니지만 아래와같이 커스텀 프로젝션을 만들 수 있음. </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConstructorExpression&lt;Long&gt; <span class="title">getSimilarBrandCodesProjection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Projections.constructor(Long.class,similarBrandEntity.brandCode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>우선, projection으로 쿼리조회하면 영속성관리에 관리되지 못하지만, 일단 DTO조회는 가능하게됨. 딱히 영속성관리 받을 이유가 크게 없다면 그냥 projection으로 조회해서 가져오는편이 가장 깔끔하다. 늘 엔티티를 영속성 컨텍스트에 올리는것이 정석은 아니다. 경우에 따라서는 projection dto로 쿼리조회하는것이 성능상 이점이 될 수 있음. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Collection-Fetch에서-limit를-하니까-메모리를-다-올려버리네&quot;&gt;&lt;a href=&quot;#Collection-Fetch에서-limit를-하니까-메모리를-다-올려버리네&quot; class=&quot;headerlink&quot; title=&quot;Collecti</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="JPA" scheme="https://codexdawn.github.io/categories/JPA/"/>
    
    
    <category term="Java,JPA,Spring" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring/"/>
    
    <category term="JPA" scheme="https://codexdawn.github.io/tags/JPA/"/>
    
    <category term="Collection Fetch" scheme="https://codexdawn.github.io/tags/Collection-Fetch/"/>
    
    <category term="Fetch" scheme="https://codexdawn.github.io/tags/Fetch/"/>
    
  </entry>
  
  <entry>
    <title>jpa-transaction-second-cache</title>
    <link href="https://codexdawn.github.io/2021/06/13/jpa-transaction-second-cache/"/>
    <id>https://codexdawn.github.io/2021/06/13/jpa-transaction-second-cache/</id>
    <published>2021-06-13T11:56:54.000Z</published>
    <updated>2021-06-13T15:14:08.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="트랜잭션과-2차캐시"><a href="#트랜잭션과-2차캐시" class="headerlink" title="트랜잭션과 2차캐시"></a>트랜잭션과 2차캐시</h1><h2 id="1-트랜잭션과-락"><a href="#1-트랜잭션과-락" class="headerlink" title="1.트랜잭션과 락"></a>1.트랜잭션과 락</h2><h3 id="트랜잭션과-격리수준"><a href="#트랜잭션과-격리수준" class="headerlink" title="트랜잭션과 격리수준"></a>트랜잭션과 격리수준</h3><p>트랜잭션은 ACID라 하는 원자성,일관성,격리성,지속성을 보장해야한다.</p><blockquote><ul><li>원자성 : 트랜잭션내에서 실행한 작업들은 마치 하나의 작업인것처럼 모두 성공하든가 모두 실패해야함.</li><li>일관성 : 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야함. 예를들어 데이터베이스에서 정한 무결성 제약조건을 항상 만족해야함.</li><li>격리성 : 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리한다. 예를들어 동시에 같은 데이터를 수정하지 못하도록 해야한다. 격리성은 동시성과 관련된 성능 이슈로 인해 격리수준을 선택할수 있다.</li><li>지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그등을 사용해서 성공한 트랜잭션 내용을 복구해야한다. </li></ul></blockquote><p>트랜잭션은 원자성,일관성,지속성을 보장한다. 문제는 격리성인데 트랜잭션간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야한다. 이렇게 하면 동시성 처리 성능이 매주 나빠진다. 이런문제로 ANSI표준은 트랜잭션의 격리수준을 4단계로 나누어 정의했다. </p><blockquote><p>트랜잭션 격리수준 4가지 종류와 발생되는 문제점 </p><ul><li>READ UNCOMMITED(커밋되지 않은 읽기)<ul><li>DIRTY READ : 트랜잭션1이 데이터를 수정하고있는데, 커밋하지 않아도 트랜잭션2가 수정중인 데이터를 조회할수있다. 트랜잭션2가 DIRTY READ한 데이터를 사용하는데 트랜잭션1을 롤백하면 데이터 정합성에 심각한 문제가 발생할수있음.</li><li>NON-REPEATABLE READ : 트랜잭션1이 회원A를 조회중인데, 갑자기 트랜잭션2가 회원A를 수정하고 커밋하면 트랜잭션1이 다시 회원A를 조회했을때 수정된 데이터가 조회된다. </li><li>PHANTOM READ : 트랜잭션1이 10살이하의 회원을 조회했는데, 트랜잭션2가 5살 회원을 추가하고 커밋하면 트랜잭션1이 다시 10살 이하의 회원을 조회했을때 회원하나가 추가된 상태로 조회됨. 이처럼 반복조회시 결과 집합이 달라지는부분이 PHANTOM READ이다. </li></ul></li><li>READ COMMITED (컷밋된 읽기)<ul><li>NON-REPEATABLE READ</li><li>PHANTOM READ</li></ul></li><li>REPEATABLE READ (반복 가능한 읽기)<ul><li>PHANTOM READ</li></ul></li><li>SERIALIZABLE (직렬화 가능)</li></ul></blockquote><h3 id="낙관적-락과-비관적-락-기초"><a href="#낙관적-락과-비관적-락-기초" class="headerlink" title="낙관적 락과 비관적 락 기초"></a>낙관적 락과 비관적 락 기초</h3><h4 id="낙관적-락"><a href="#낙관적-락" class="headerlink" title="낙관적 락"></a>낙관적 락</h4><ul><li>이름그대로 트랜잭션 대부분은 충돌이 발생하지 않는다는 가정하는방법 </li><li>DB에서 제공하는 락기능을 사용하는게 아니라, JPA가 제공하는 버전관리 기능을 사용한다. (쉽게말해 애플리케이션이 제공하는 락 임.)</li><li>트랜잭션을 커밋하기 전까지는 트랜잭션 충돌을 알수없다. </li></ul><h4 id="비관적-락"><a href="#비관적-락" class="headerlink" title="비관적 락"></a>비관적 락</h4><ul><li>이름그대로 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는것. </li><li>이것은 데이터베이스 락기능을 사용함.</li><li>select for update구문이 대표적임.</li></ul><h4 id="두번의-갱신-분실-문제"><a href="#두번의-갱신-분실-문제" class="headerlink" title="두번의 갱신 분실 문제"></a>두번의 갱신 분실 문제</h4><p>A와B가 같은 콘텐츠를 수정한다고 가정하자. 둘이 동시에 제목이 같은 콘텐츠를 수정하는중에 A가 먼저 수정완료 버튼을 눌렀다. 잠시후 사용자 B가 수정완료 버튼을 눌렀다. 결과적으로 먼저 완료한 사용자A의 수정사항은 사라지고 나중에 완료한 사용자B의 수정사항만 남게된다. 이것이 두번의 갱신 분실 문제라 한다.<br>두번의 갱신 분실문제는 데이터베이스 트랜잭션의 범위를 넘어선다. 따라서 3가지 선택방법이 있다.</p><ol><li>마지막 커밋만 인정하기 <ul><li>사용자 A의 내용은 무시, 마지막 커밋한 B만 인정 </li></ul></li><li>최초 커밋만 인정하기<ul><li>A가 먼저 수정완료했기때문에, B가 수정완료하면 오류발생시킴</li></ul></li><li>충돌하는 갱신 내용 병합하기 <ul><li>A,B의 수정사항을 병합시킴 </li></ul></li></ol><p>기본은 보통 <strong>마지막 커밋만 인정하기</strong> 가 주로 사용됨. </p><h3 id="Version"><a href="#Version" class="headerlink" title="@Version"></a>@Version</h3><p>낙관적 락을 사용하려면 @Version 을 사용해서 버전관리기능을 추가해야함. </p><h4 id="Version의-적용가능-타입"><a href="#Version의-적용가능-타입" class="headerlink" title="@Version의 적용가능 타입"></a>@Version의 적용가능 타입</h4><ul><li>Long(long)</li><li>Integer(int)</li><li>Short(short)</li><li>TimeStamp</li></ul><h4 id="Version-의-특징"><a href="#Version-의-특징" class="headerlink" title="@Version 의 특징"></a>@Version 의 특징</h4><ul><li>@Version을 사용하면 <strong>최초커밋만 인정</strong> 하기가 적용됨. </li><li>엔티티의 값을 변경하면 무조건 증가됨. (단, 연관관계 필드는 외래 키를 관리하는 연관관계 주인필드를 수정할때만 버전이 증가됨.)</li><li>@Version으로 추가한 버전관리 필드는 JPA가 직접관리하므로 개발자가 임의로 수정한면 안됨. (벌크연산제외) 만약 버전 값을 강제로 증가하려면 특별한 락 옵션을 선택하면 됨.</li><li>벌크연산은 버전 증가를 무시함. 버전을 강제로 증가시키려면 강제로 version+1을 시켜야함.(수기 업데이트)</li></ul><h3 id="JPA락-사용"><a href="#JPA락-사용" class="headerlink" title="JPA락 사용"></a>JPA락 사용</h3><p>JPA를 사용할때 추천하는 전략은 READ COMMITED트랜잭션 격리수준 + 낙관적 버전 관리다. </p><h4 id="낙관적-락-1"><a href="#낙관적-락-1" class="headerlink" title="낙관적 락"></a>낙관적 락</h4><ol><li><p>NONE<br>@Version만 사용했을때 </p><ul><li>용도 : 조회한 엔티티를 수정할때 다른트랜잭션에 의해 변경되지 않아야함. 조회시점~수정시점까지 보장 </li><li>동작 : 엔티티를 수정할때 버전을 체크하면서 버전을 증가한다. 이때 디비의 버전값이 현재버전이 아니면 예외발생 </li><li>이점 : 두번의 갱신 분실 문제를 예방가능  </li></ul></li><li><p>OPTIMISTIC<br>@Version만사용했을때와 달리, 이옵션을 사용하면 한번 조회한 엔티티는 트랜잭션 종료시까지 다른 트랜잭션에서 변경하지 않음을 보장해줌. </p><ul><li>용도 : 조회시점~트랜잭션이 끝날때까지 조회한 엔티티가 변경되지않음을 보장 시켜줌</li><li>동작 : 트랜잭션을 커밋할때 버전정보 조회해서 현재 엔티티 버전과 같은지 검증해줌. 같지않으면 예외</li><li>이점 : 이 옵션은 DIRTY READ 와 NON-REPEATABLE READ가 방지됨 </li></ul></li></ol><p>EX&gt; Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC); </p><ol start="3"><li><p>OPTIMISTIC_FORCE_INCREMENT<br>낙관적 락을 사용하면서 버전정보를 강제로 증가 시킴 </p><ul><li>용도 : 논리적 단위의 엔티티 묶음을 관리 할 수 있다. 게시물의 첨부파일만 추가했을때 게시물의 버전은 증가하지 않는다. 해당 게시물은 물리적으로 변경되지 않았지만, 논리적으로 변경되었기때문에, 게시물 버전도 강제로 증가시키려면, 이옵션 사용하면됨. </li><li>동작 : 엔티티를 수정하지 않아도 트랜잭션을 커밋할때 버전정보 강제 증가 이때 데이터베이스의 버전이 엔티티버전과 다르면 예외가 발생. 추가로 엔티티를 수정하면 수정시 버전 업데이트가 발생한다. 따라서 총 2번의 버전증가가 될수있음.</li><li>이점 : 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전관리 할수있음. </li></ul></li></ol><h4 id="비관적-락-1"><a href="#비관적-락-1" class="headerlink" title="비관적 락"></a>비관적 락</h4><p>비관적 락의 특징 </p><ul><li>엔티티가 아닌 스칼라 타입을 조회해도 사용가능</li><li>데이터를 수정하는 즉시 트랜잭션 충돌을 감지 가능 </li></ul><p>비관적 락에서 발생하는 예외 </p><ul><li>javax.persistence.PessimisticLockException(JPA 예외)</li><li>org.springframework.dao.PessimisticLockingFailureException(스프링 예외 추상화)</li></ul><ol><li><p>PESSIMISTIC_WRITE<br>비관적 락이라면 보통 이 옵션을 뜻함. </p><ul><li>용도 : 디비에 쓰기락을 건다.</li><li>동작 : 디비에 select for update 를 사용해서 락건다.</li><li>이점 : NON-REPEATABLE READ를 방지. 락이 걸린 로우는 다른 트랜잭션이 수정못함</li></ul></li><li><p>PESSIMISTIC_READ<br>데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸때 사용 일반적으로 잘 사용안함. 대부분은 디비 방언에 의해 PESSIMISTIC_WRITE 옵션으로 동작</p><ul><li>MySQL : lock in share mode</li><li>PostgreSQL : for share </li></ul></li><li><p>PESSIMISTIC_FORCE_INCREMENT<br>비관적 락중에 유일하게 버전 정보 사용함. 비관적 락이지만 버전 정보를 강제로 증가 시킴. 하이버네이트는 nowait 를 지원하는 디비에 대해서 for update nowait 옵션을 적용</p><ul><li>오라클 : for update nowait </li><li>PostgreSQL : for update nowait</li><li>nowait를 지원하지 않으면 for update가 사용됨</li></ul></li></ol><h4 id="비관적-락과-타임아웃"><a href="#비관적-락과-타임아웃" class="headerlink" title="비관적 락과 타임아웃"></a>비관적 락과 타임아웃</h4><ul><li>비관적 락을 사용하면 락을 획득하기까지 트랜잭션이 무한정 기다림. 무한정 기다릴수없기에 타임아웃 시간을 줘서 적절하게 끊을수있음. 응답없으면 javax.persistence.LockTimeoutExcpetion발생함. </li></ul><p>EX&gt; properties.put(“javax.persistence.lock.timeout”, 10000); //HashMap으로사용. 10초 까지 대기 설정 </p><h2 id="2-2차-캐시"><a href="#2-2차-캐시" class="headerlink" title="2. 2차 캐시"></a>2. 2차 캐시</h2><h3 id="1차-캐시와-2차-캐시"><a href="#1차-캐시와-2차-캐시" class="headerlink" title="1차 캐시와 2차 캐시"></a>1차 캐시와 2차 캐시</h3><h5 id="1차캐시-특징"><a href="#1차캐시-특징" class="headerlink" title="1차캐시 특징"></a>1차캐시 특징</h5><ul><li>1차캐시는 같은 엔티티가 있으면 해당 엔티티를 그대로 반환함.따라서 1차캐시는 객체 동일성 (a == b)가 보장됨</li><li>1차캐시는 기본적으로 영속성 컨텍스트 범위의 캐시(컨테이너환경에서는 트랜잭션 범위의 캐시, OSIV를 적용하면 요청범위의 캐시.)</li></ul><h5 id="2차캐시-특징"><a href="#2차캐시-특징" class="headerlink" title="2차캐시 특징"></a>2차캐시 특징</h5><ul><li>2차캐시는 어플리케이션 범위의 캐시다. 따라서 어플리케이션이 종료될때까지 캐시가 유지됨. </li><li>2자캐시를 적용하면 엔티티 매니저를 통해 데이터를 조회할때 우선 2차캐시에서 찾고 없으면 디비를 뒤짐. (적절하게 사용하면 디비 조회를 획기적으로 줄임가능)</li><li>2차캐시는 영속성 유닛 범위의 캐시</li><li>2차캐시는 조회한 객체를 그대로 반환하지 않고, 복사본을 만들어서 반환</li><li>2차캐시는 디비 기본키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성(a == b)를 보장하지 않음. (이건 1차캐시도 동일한 사항)</li></ul><p>[참고]<br>김영한님 책에 1차캐시,2차캐시 동작방식에 대한 그림 있는데 햇깔리면 책 열어서 다시 보자! 그리고 실제로 적용하는 부분은 기록하지않았다. 나중에 필요할때 책을 참고하든지 구글링을해서 필요할때 참고하자.<br><a href="https://www.baeldung.com/hibernate-second-level-cache">baeldung 2차캐시 ehcache적용방법</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;트랜잭션과-2차캐시&quot;&gt;&lt;a href=&quot;#트랜잭션과-2차캐시&quot; class=&quot;headerlink&quot; title=&quot;트랜잭션과 2차캐시&quot;&gt;&lt;/a&gt;트랜잭션과 2차캐시&lt;/h1&gt;&lt;h2 id=&quot;1-트랜잭션과-락&quot;&gt;&lt;a href=&quot;#1-트랜잭션과-락&quot; c</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="자바ORM표준JPA프로그래밍" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    <category term="트랜잭션과 2차캐시" scheme="https://codexdawn.github.io/categories/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-2%EC%B0%A8%EC%BA%90%EC%8B%9C/"/>
    
    
    <category term="Java,JPA" scheme="https://codexdawn.github.io/tags/Java-JPA/"/>
    
    <category term="transaction" scheme="https://codexdawn.github.io/tags/transaction/"/>
    
    <category term="secondcache" scheme="https://codexdawn.github.io/tags/secondcache/"/>
    
    <category term="lock" scheme="https://codexdawn.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>jpa-performance-optimazation</title>
    <link href="https://codexdawn.github.io/2021/06/12/jpa-performance-optimazation/"/>
    <id>https://codexdawn.github.io/2021/06/12/jpa-performance-optimazation/</id>
    <published>2021-06-12T06:44:47.000Z</published>
    <updated>2021-06-12T12:31:56.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="고급주제와-성능최적화"><a href="#고급주제와-성능최적화" class="headerlink" title="고급주제와 성능최적화"></a>고급주제와 성능최적화</h1><h2 id="1-예외-처리"><a href="#1-예외-처리" class="headerlink" title="1. 예외 처리"></a>1. 예외 처리</h2><ul><li><p>JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스이다. 그리고 이 예외 클래스는 RuntimeExeption의 자식이다. 따라서 JPA예외는 모두 언체크 예외에 속함. </p></li><li><p>JPA표준예외는 크게 2가지로 나뉨 </p><ul><li>트랜잭션 롤백을 표시하는 예외 </li><li>트랜잭션 롤백을 표시하지 않는 예외 </li></ul></li><li><p>트랜잭션을 표시하는 예외는 심각한 예외이때문에 복구해선안됨. 이 예외가 발생하면 트랜잭션을 강제로 커밋해도 트랜잭션 커밋되지 않고 대신에 javax.persistence.RollbackException 예외가 발생함. </p></li></ul><p><a href="https://www.objectdb.com/api/java/jpa/exceptions">참고-objectdb-jpa exception정리</a></p><h3 id="트랜잭션-롤백시-주의사항"><a href="#트랜잭션-롤백시-주의사항" class="headerlink" title="트랜잭션 롤백시 주의사항"></a>트랜잭션 롤백시 주의사항</h3><ul><li>트랜잭션을 롤백하는건 db의 반영사항만 롤백하는것이지 숮어한 자바 객체까지 원상태로 복구 안해줌. (영속성 컨텍스트의 1차캐시에 그대로 남아있음.)</li><li>이 롤백된 영속성 컨텍스트를 그대로 사용하는건 굉장히 위험함. 따라서 이부분은 EntityManager.clear()를 호출해서 영속성 컨텍스트를 초기화 해야함. </li><li>스프링 프레임워크는 위 2가지 문제를 예방하기위해 영속성 컨텍스트 범위에 따라 다른방법을 사용함.<ul><li>기본전략 : 트랜잭션당 영속성 컨텍스트 전략 <ul><li>문제가 발생하면 트랜잭션 AOP종료시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료시킴 </li></ul></li><li>OSIV처럼 트랜잭션을 범위를 넓게 사용하는 경우 <ul><li>위 경우는 문제가 발생한 경우 다른 트랜잭션에서 문제가 되는 영속성 컨텍스트를 참조하는 경우 문제가 발생한다. </li><li>그래서 스프링에서는 문제 발생시 EntityManager.clear()를 자동호출하여 다른 트랜잭션이 문제가 되는 영속성 컨텍스트에 접근하지못하도록 막는다. </li></ul></li></ul></li></ul><h2 id="2-엔티티-비교"><a href="#2-엔티티-비교" class="headerlink" title="2. 엔티티 비교"></a>2. 엔티티 비교</h2><ul><li>영속성 컨텍스트 내부에는 1차캐시가 있는데, 1차캐시는 영속성 컨텍스트와 생명주기를 같이함. </li><li>영속성 컨텍스트를 통해 데이터를 저장하거나, 조회하면 1차 캐시에 엔티티가 저장됨. (1차캐시 덕분에 변경감지기능 과 db접근하지않고 1차캐시로 데이터 조회 바로 가능함)</li><li>같은 영속성 컨텍스트로 반환받은 엔티티는 항상 같은 엔티티 인스턴스를 반환함(단순 동등성이 아니라, 주소까지 같은 인스턴스임) </li></ul><h2 id="3-프록시-심화-주제"><a href="#3-프록시-심화-주제" class="headerlink" title="3. 프록시 심화 주제"></a>3. 프록시 심화 주제</h2><h3 id="em-getReference-호출-후-em-find-호출"><a href="#em-getReference-호출-후-em-find-호출" class="headerlink" title="em.getReference 호출 후 em.find 호출"></a>em.getReference 호출 후 em.find 호출</h3><ul><li>em.getReference를 호출하고 em.find를 호출하면 같은 엔티티로 보장됨.</li><li>그리고 처음 getReference로 프록시를 호출하고나서, em.find로 원본 엔티티를 조회해도 em.find로 가져온 엔티티는 처음 getReference로 호출한 프록시 객체 주소로 반환하게 됨. </li></ul><h3 id="em-find-호출후-em-getReference-호출"><a href="#em-find-호출후-em-getReference-호출" class="headerlink" title="em.find 호출후 em.getReference 호출"></a>em.find 호출후 em.getReference 호출</h3><ul><li>역시나 같은 엔티티 보장됨.</li><li>em.find로 호출했기때문에, 원본 엔티티를 리턴한다. 그리고 em.getReference를 호출하면 프록시 객체를 리턴할것 같지만, 원본 엔티티를 리턴하게됨. </li><li>이렇게 처음 호출한 엔티티를 그대로 리턴하는 이유는 엔티티 동일성 보장을 위한 장치라고 생각하면 될듯하다. </li></ul><h3 id="프록시-타입-비교"><a href="#프록시-타입-비교" class="headerlink" title="프록시 타입 비교"></a>프록시 타입 비교</h3><ul><li>instanceof로 무조건 비교해야함. (==비교 안됨.)</li></ul><h3 id="프록시-동등성-비교"><a href="#프록시-동등성-비교" class="headerlink" title="프록시 동등성 비교"></a>프록시 동등성 비교</h3><ul><li>equals 재정의해서 비교하면 됨. </li></ul><h2 id="4-성능-최적화"><a href="#4-성능-최적화" class="headerlink" title="4. 성능 최적화"></a>4. 성능 최적화</h2><h3 id="N-1-문제"><a href="#N-1-문제" class="headerlink" title="N+1 문제"></a>N+1 문제</h3><figure class="highlight java"><figcaption><span>Member-Order</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.EAGER)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;Orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="keyword">private</span> Member member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 주문-회원간 엔티티로 주문정보는 1:N,N:1 양방향 연관관계 매핑된 엔티티들이다. 특이점은 글로벌 페치전략을 즉시로딩으로 걸었다. </p><h4 id="즉시로딩과-N-1"><a href="#즉시로딩과-N-1" class="headerlink" title="즉시로딩과 N+1"></a>즉시로딩과 N+1</h4><p>위 코드를 em.find로 조회하면 어떤 쿼리가 나갈까?<br>select M.<em>, O.</em> FROM MEMBER M OUTER JOIN ORDERS O ON M.ID = O.MEMBER_ID<br>즉시로딩이기때문에 위와같이 한방쿼리로 나간다. 하지만 문제는 JPQL로 조회했을때다.<br>List<Member> members = em.createQuery(“select m from Member m”, Member.class).getResultList();<br>위 JPQL을 수행하면 즉시로딩과 지연로딩 전혀 신경쓰지않고, JPQL만 사용해서 SQL을 생성한다. 따라서 아래와 같은 쿼리가 나가게된다.<br>SELECT * FROM MEMBER<br>SQL의 실행결과로 회원 엔티티 정보를 애플리케이션에 로딩한다. 그런데말입니다. 회원 엔티티와 연관된 주문 컬렉션이 즉시 로딩으로 설정되어있으므로, JPA는 주문 컬렉션을 즉시로딩하려고 아래 SQL을 추가로 실행한다.<br>SELECT * FROM ORDERS WHERE MEMBER_ID = ?<br>이렇게 회원의 숫자에 따라서 N의 쿼리가 추가로 나가게되는데, 이부분을 N+1이슈라고 한다. </Member></p><h4 id="지연로딩과-N-1"><a href="#지연로딩과-N-1" class="headerlink" title="지연로딩과 N+1"></a>지연로딩과 N+1</h4><p>그렇다면 위 코드를 즉시로딩 대신 지연로딩으로 사용하면 N+1문제에서 해결할수있을까? 결론부터 말하면 NOPE! JPQL로 수행하면 원하는대로 쿼리는 하나만 출력될것이다. 하지만 주문 컬렉션을 실제로 사용했을때 프록시 객체에서 디비초기화를 요청하게 되기때문에, 역시나 회원 엔티티 숫자만큼 요청하게된다. </p><h4 id="페치-조인-사용-으로-N-1해결"><a href="#페치-조인-사용-으로-N-1해결" class="headerlink" title="페치 조인 사용 으로 N+1해결"></a>페치 조인 사용 으로 N+1해결</h4><ul><li>fetch join으로 한방쿼리 만들어서 출력가능.</li><li>위 예제기준으로는 1:N 조인을 했으므로 중복된 결과가 나올수있기때문에 JPQL의 DISTINCT를 사용해서 중복제거해야함. </li></ul><h4 id="하이버네이트-BatchSize"><a href="#하이버네이트-BatchSize" class="headerlink" title="하이버네이트 @BatchSize"></a>하이버네이트 @BatchSize</h4><ul><li>발생되는 컬렉션 객체위에 @BatchSize 를 설정하거나</li><li>application.yml에서 default_batch_size 를 설정해서 글로벌하게 설정할수 있음. </li></ul><h4 id="하이버네이트-Fetch-FetchMode-SUBSELECT"><a href="#하이버네이트-Fetch-FetchMode-SUBSELECT" class="headerlink" title="하이버네이트 @Fetch(FetchMode.SUBSELECT)"></a>하이버네이트 @Fetch(FetchMode.SUBSELECT)</h4><ul><li>BatchSize를걸었던것 처럼 컬렉션객체위에 선언하면 서브쿼리가 생성되서 사이즈만큼 where절 서브쿼리로 한방쿼리로 수행될수있음. </li></ul><h4 id="N-1정리"><a href="#N-1정리" class="headerlink" title="N+1정리"></a>N+1정리</h4><ul><li>즉시로딩은 가급적 사용하지말자!(즉시로딩은 성능 최적화가 어렵다.)</li><li>지연로딩으로 다 발라버리고, 성능 최적화가 필요한곳에 fetch join사용하자</li></ul><h3 id="읽기전용-쿼리의-성능-최적화"><a href="#읽기전용-쿼리의-성능-최적화" class="headerlink" title="읽기전용 쿼리의 성능 최적화"></a>읽기전용 쿼리의 성능 최적화</h3><p>엔티티가 영속성 컨텍스트에 관리되면 1차캐시부터 변경감지까지 얻을수있는 장점이 많지만, 영속성 컨텍스트는 변경감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용한다는 단점이 있다.</p><h4 id="스칼라-타입으로-조회-커스텀-프로젝션-설정"><a href="#스칼라-타입으로-조회-커스텀-프로젝션-설정" class="headerlink" title="스칼라 타입으로 조회 (커스텀 프로젝션 설정)"></a>스칼라 타입으로 조회 (커스텀 프로젝션 설정)</h4><ul><li>가장 확실한 방법임 (엔티티가 아닌 스칼라 타입으로 필드 조회 )</li><li>스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않음.</li></ul><h4 id="읽기전용-쿼리-힌트-사용"><a href="#읽기전용-쿼리-힌트-사용" class="headerlink" title="읽기전용 쿼리 힌트 사용"></a>읽기전용 쿼리 힌트 사용</h4><ul><li>query.setHint(“org.hibernate.readOnly”, true);</li><li>위 설정을 하면 읽기전용이기때문에 스냅샷에서 저장안함. (스냅샷이 없기때문에 변경감지같은 기능 못사용함.)</li></ul><h4 id="읽기전용-트랜잭션-사용"><a href="#읽기전용-트랜잭션-사용" class="headerlink" title="읽기전용 트랜잭션 사용"></a>읽기전용 트랜잭션 사용</h4><ul><li>@Transactional(readOnly = true)</li><li>위 옵션을 주면 스프링에서 entityManager 플러시 모드를 manual로 설정함. (강제로 flush를 호출하지않는한 플러시 발생안함.)</li><li>트랜잭션을 설사 커밋해도 플러시 안함 (등록,삭제,갱신등 안됨)</li><li>플러시할때 일어나는 스냅샷 비교같은 무거운 로직들을 수행안해서 성능이 향상됨. </li><li>트랜잭션을 시작했기때문에 트랜잭션시작, 로직수행,트랜잭션 커밋의 과정은 이뤄지지만, 단지 영속성 컨텍스트 플러시를 안할뿐이다. </li></ul><h4 id="트랜잭션-밖에서-읽기"><a href="#트랜잭션-밖에서-읽기" class="headerlink" title="트랜잭션 밖에서 읽기"></a>트랜잭션 밖에서 읽기</h4><ul><li>@Transactional(propagation= Propagation.NOT_SUPPORTED) </li><li>위 설정은 트랜잭션을 사용하지 않는것이다. 따라서 자연스럽게 커밋할일이없어짐. JPQL쿼리도 트랜잭션 없이 실행하면 플러시를 호출 안함.</li></ul><p>읽기 전용 데이터를 조회할때, 메모리 최적화하려면 스칼라 타입(커스텀 프로젝션)으로 조회등 위 내용대로 설정하면 됨.<br>(보통 읽기전용트랜잭션 + 읽기전용쿼리힌트 로 성능최적화를 많이 함.)</p><h3 id="배치처리"><a href="#배치처리" class="headerlink" title="배치처리"></a>배치처리</h3><p>배치 처리처럼 수천 수백만건의 데이터를 처리해야하는것이라면, 영속성 컨텍스트에 무자비하게 쌓이기때문에 메모리부족 현상이 발생할수있음. 2차캐시 사용한다면 2차캐시에 보관되지않도록 해야햠.</p><h4 id="JPA-등록배치"><a href="#JPA-등록배치" class="headerlink" title="JPA 등록배치"></a>JPA 등록배치</h4><ul><li>주기적으로 em.flush(), em.clear() 호출 (if(i % 100 == 0))</li></ul><h4 id="JPA-페이징-배치-처리"><a href="#JPA-페이징-배치-처리" class="headerlink" title="JPA 페이징 배치 처리"></a>JPA 페이징 배치 처리</h4><ul><li>페이징으로 100건씩 쿼리 조회하면서 em.flush,em.clear호출  </li></ul><h4 id="하이버네이트-Scroll사용"><a href="#하이버네이트-Scroll사용" class="headerlink" title="하이버네이트 Scroll사용"></a>하이버네이트 Scroll사용</h4><ul><li>하이버네이트는 scroll로 jdbc 커서를 지원함. (JPA는 커서 지원안함)</li><li>Session session = em.unwrap(Session.class); 을 사용해야함. </li><li>2차캐시 기능은 꺼야함(setCacheMode(CacheMode.IGNORE))</li></ul><h4 id="하이버네이트-무상태-세션-사용"><a href="#하이버네이트-무상태-세션-사용" class="headerlink" title="하이버네이트 무상태 세션 사용"></a>하이버네이트 무상태 세션 사용</h4><ul><li>영속성 컨텍스트 생성안함. 2차캐시도 사용안함</li><li>엔티티를 수정하려면 무상태 세션이 제공하는 update()메소드를 직접 호출해야함. </li></ul><h3 id="SQL-쿼리-힌트"><a href="#SQL-쿼리-힌트" class="headerlink" title="SQL 쿼리 힌트"></a>SQL 쿼리 힌트</h3><ul><li>JPA는 데이터베이스 SQL힌트기능이 없음 (하이버네이트를 직업 사용해야함.)</li><li>addQueryHint(“FULL (MEMBER)”) 이런식으로 힌트 추가 (하이버네이트 세션에서)</li></ul><h3 id="트랜잭션을-지원하는-쓰기지연-과-성능-최적화"><a href="#트랜잭션을-지원하는-쓰기지연-과-성능-최적화" class="headerlink" title="트랜잭션을 지원하는 쓰기지연 과 성능 최적화"></a>트랜잭션을 지원하는 쓰기지연 과 성능 최적화</h3><ul><li>hibernate.jdbc.batch_size 속성 사용 </li><li>위 설정으로 배치처리를하면 사이즈만큼 모아서 처리함. </li><li>하지만 같은 SQL일때만 유효하다. 중간에 다른 쿼리가 끼면 SQL배치를 다시 시작하게됨. </li></ul><h3 id="트랜잭션을-지원하는-쓰기지연과-애플리케이션-확장성"><a href="#트랜잭션을-지원하는-쓰기지연과-애플리케이션-확장성" class="headerlink" title="트랜잭션을 지원하는 쓰기지연과 애플리케이션 확장성"></a>트랜잭션을 지원하는 쓰기지연과 애플리케이션 확장성</h3><ul><li>트랜잭션을 지원하는 쓰기지연과 변경감지 기능으로 개발 편의성 장점을 얻었지만 진짜 찐장점은 데이터베이스 테이블 row에 lock이 걸리는 시간을 최소화 한다.</li><li>flush 하기 전까지는 등록,삭제,수정같은 트랜잭션이 발생안하기때문에 락이 안걸림. </li><li>트랜잭션 격리수준에 따라 다르지만 보통 많이 사용하는 커밋된 읽기 (Read Commited) 격리수준이나 그 이상에서는 데이터베이스에 현재 수정중인 데이터를 수정하려는 다른 트랜잭션은 락이 풀릴때까지 대기한다. </li><li>jpa는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다. 쿼리를 보내고 트랜잭션을 커밋하므로 결과적으로 디비에 락이 걸리는 시간을 최소화함. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;고급주제와-성능최적화&quot;&gt;&lt;a href=&quot;#고급주제와-성능최적화&quot; class=&quot;headerlink&quot; title=&quot;고급주제와 성능최적화&quot;&gt;&lt;/a&gt;고급주제와 성능최적화&lt;/h1&gt;&lt;h2 id=&quot;1-예외-처리&quot;&gt;&lt;a href=&quot;#1-예외-처리&quot; c</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="자바ORM표준JPA프로그래밍" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    <category term="고급주제와 성능최적화" scheme="https://codexdawn.github.io/categories/%EA%B3%A0%EA%B8%89%EC%A3%BC%EC%A0%9C%EC%99%80-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    
    
    <category term="Java,JPA" scheme="https://codexdawn.github.io/tags/Java-JPA/"/>
    
    <category term="jpa exception" scheme="https://codexdawn.github.io/tags/jpa-exception/"/>
    
    <category term="엔티티비교" scheme="https://codexdawn.github.io/tags/%EC%97%94%ED%8B%B0%ED%8B%B0%EB%B9%84%EA%B5%90/"/>
    
    <category term="프록시" scheme="https://codexdawn.github.io/tags/%ED%94%84%EB%A1%9D%EC%8B%9C/"/>
    
    <category term="N+1" scheme="https://codexdawn.github.io/tags/N-1/"/>
    
  </entry>
  
  <entry>
    <title>jpa-collection-etc</title>
    <link href="https://codexdawn.github.io/2021/06/10/jpa-collection-etc/"/>
    <id>https://codexdawn.github.io/2021/06/10/jpa-collection-etc/</id>
    <published>2021-06-10T08:41:35.000Z</published>
    <updated>2021-06-10T14:33:35.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="컬렉션과-부가기능"><a href="#컬렉션과-부가기능" class="headerlink" title="컬렉션과 부가기능"></a>컬렉션과 부가기능</h1><h2 id="1-컬렉션"><a href="#1-컬렉션" class="headerlink" title="1. 컬렉션"></a>1. 컬렉션</h2><p>JPA에서 컬렉션을 사용할때 2가지</p><ol><li>@OneToMany, @ManyToMany 를 사용해서 일대다 나 다대다 엔티티 관계를 매핑할때 </li><li>@ElementCollection을 사용해서 값 타입을 하나 이상 보관 할때 </li></ol><p>자바 컬렉션 인터페이스 특징</p><ol><li>Collection : 자바가 제공하는 최상위 컬렉션. 하이버네이트는 중복을 허용하고 순서를 보장하지 않는다고 가정</li><li>Set: 중복을 허용하지 않고,순서 보장안됨.</li><li>List: 순서가 있는 컬렉션. 순서를 보장하지만 중복 허용됨.</li><li>Map: Key,Value구조로 되어있는 특수한 컬렉션이다. (Map은 잘 활용안됨.)</li></ol><h3 id="Collection-List"><a href="#Collection-List" class="headerlink" title="Collection,List"></a>Collection,List</h3><p>Collection,List는 엔티티를 추가할때 중복된 엔티티가 있는지 비교하지않고, 단순히 저장만하면 된다. 따라서 엔티티를 추가해도 지연 로딩된 컬렉션을 초기화 하지 않는다. </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set은 엔티티를 추가할때 중복된 엔티티가 있는지 비교해야 한다. 따라서 엔티티를 추가할때 지연로딩된 컬렉션을 초기화한다.<br>(Set사용시, equals,hashcode 재정의 무조건 반드시 해야함!!! )</p><h3 id="OrderBy"><a href="#OrderBy" class="headerlink" title="@OrderBy"></a>@OrderBy</h3><p>@OrderBy는 모든 컬렉션에 사용가능 </p><figure class="highlight java"><figcaption><span>@OrderBy 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany(mappedBy=&quot;team&quot;)</span></span><br><span class="line"><span class="meta">@OrderBy(&quot;username desc, id asc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Member&gt; members = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column(name = &quot;member_name&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="keyword">private</span> Team team; </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Team findTeam = em.find(Team.class, team.getId()); </span><br><span class="line">findTeam.getMembers().size(); <span class="comment">//초기화 </span></span><br><span class="line"><span class="comment">//위 코드의 나갈쿼리는  아래와 같다. (정렬붙은것 확인됨)</span></span><br><span class="line"><span class="comment">//SELECT M.* FROM MEMBER M WHERE M.TEAM = ? ORDER BY M.MEMBER_NAME DESC, M.ID ASC </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-Converter"><a href="#2-Converter" class="headerlink" title="2. @Converter"></a>2. @Converter</h2><figure class="highlight java"><figcaption><span>@Converter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Convert(converter = BooleanToYnConverter.class)</span> </span><br><span class="line"><span class="comment">//글로벌 설정으로 하면 위 애너테이션 지워됨. </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> vip; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Converter</span></span><br><span class="line"><span class="comment">//@Converter(autoApply = true) 요렇게 하면 글로벌 설정으로 설정됨. </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanToYnConverter</span> <span class="keyword">implements</span> <span class="title">AttributeConverter</span>&lt;<span class="title">Boolean</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToDatabaseColumn</span><span class="params">(Boolean attribute)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (attribute != <span class="keyword">null</span> &amp;&amp; attribute) ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">convertToEntityAttribute</span><span class="params">(Strig dbData)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Y&quot;</span>.equals(dbData); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-엔티티-그래프"><a href="#3-엔티티-그래프" class="headerlink" title="3. 엔티티 그래프"></a>3. 엔티티 그래프</h2><p>엔티티를 조회할때 연관된 엔티티를 함께 조회 하려면 글로벌페치전략을 Eager로 설정하거나, Lazy로딩해서 fetch조인 사용하기도한다. 하지만 페치조인을 사용하면 JPQL을 중복해서 작성하는 경우가 많다. </p><ul><li>select o from Orders o where o.status = ?  </li><li>selet o from Order o join fetch o.member where o.status = ?</li><li>select o from Orders join fetch o.orderItems where o.status = ?<br>위와같이 상황에 따라 각기 다른 쿼리를 직접 개발해야함. </li></ul><p>엔티티그래프를 사용하면 엔티티를 조회하는 시점에 함께 조회할 연관된엔티티를 선택할수있다. 그래서 아래쿼리만 작성하면 연관된 엔티티도 같이 끌고옴.</p><ul><li>select o from Orders o where o.status = ?  </li></ul><p>엔티티그래프 기능은 엔티티 조회시점에 연관된 엔티티 들을 함께 조회하는 기능이다.  </p><figure class="highlight java"><figcaption><span>엔티티그래프 사용방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NamedEntityGraph(name = &quot;Order.withMember&quot;, attributeNodes = &#123;</span></span><br><span class="line"><span class="meta">@NamedAttributeNode(&quot;member&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne(fetch=LAZY, optional=false)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;member_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Member member; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//em.find 사용 </span></span><br><span class="line">EntityGraph g = em.getEntityGraph(<span class="string">&quot;Order.withMember&quot;</span>);</span><br><span class="line"></span><br><span class="line">Map hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">hints.put(<span class="string">&quot;javax.persistence.fetchgraph&quot;</span>, g);</span><br><span class="line"></span><br><span class="line">Order order = em.find(Order.class, orderId, hints); </span><br></pre></td></tr></table></figure><h3 id="subgraph"><a href="#subgraph" class="headerlink" title="subgraph"></a>subgraph</h3><figure class="highlight java"><figcaption><span>서브그래프 사용방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NamedEntityGraph(name = &quot;Order.withAll&quot;, attributeNodes = &#123;</span></span><br><span class="line"><span class="meta">@NamedAttributeNode(&quot;member&quot;),</span></span><br><span class="line"><span class="meta">@NamedAttributeNode(value=&quot;orderItems&quot;, subgraph = &quot;orderItems&quot;)</span></span><br><span class="line"><span class="meta">&#125;, </span></span><br><span class="line"><span class="meta">subgraphs = @NamedSubgraph(name= &quot;orderItems&quot;, attributeNodes = &#123;</span></span><br><span class="line"><span class="meta">@NamedAttributeNode(&quot;item&quot;)</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne(fetch=LAZY, optional=false)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;member_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Member member; </span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany(mappedBy=&quot;order&quot;, cascade = CascadeType.ALL)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GenerateValue</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne(fetch = LAZY)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;item_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Item item; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//em.find 사용 </span></span><br><span class="line">EntityGraph g = em.getEntityGraph(<span class="string">&quot;Order.withAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">Map hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">hints.put(<span class="string">&quot;javax.persistence.fetchgraph&quot;</span>, g);</span><br><span class="line"></span><br><span class="line">Order order = em.find(Order.class, orderId, hints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//jpql 사용 </span></span><br><span class="line">List&lt;Orders&gt; result = em.createQuery(<span class="string">&quot;select o from Orders o where o.id = :orderId&quot;</span>, Orders.class)</span><br><span class="line">.setParameter(<span class="string">&quot;orderId&quot;</span>, orderId)</span><br><span class="line">.setHint(<span class="string">&quot;javax.persistence.fetchgraph&quot;</span>, em.getEntityGraph(<span class="string">&quot;Order.withAll&quot;</span>))</span><br><span class="line">.getResultList(); </span><br></pre></td></tr></table></figure><h4 id="엔티티그래프-사용시-참고"><a href="#엔티티그래프-사용시-참고" class="headerlink" title="엔티티그래프 사용시 참고!!"></a>엔티티그래프 사용시 참고!!</h4><p>em.find를 사용하면 연관관계 매핑시 optional=true로 걸면 inner Join으로 필수관계가 자동으로 매핑되지만, JPQL에서 엔티티그래프를 사용하면 항상 외부조인으로 잡힌다. 따라서 내부조인을 사용하고 싶으면 아래와 같이 내부조인을 명시시켜줘야함.<br>select o from Orders o join fetch o.member where o.id = :orderId</p><h3 id="엔티티그래프-정리"><a href="#엔티티그래프-정리" class="headerlink" title="엔티티그래프 정리"></a>엔티티그래프 정리</h3><ol><li>ROOT에서 시작 <ul><li>엔티티그래프는  항상 조회하는 엔티티의 ROOT에서 시작해야함. Order엔티티를 조회하는데 Member부터 시작하는 엔티티그래프를 사용하면 안됨.</li></ul></li><li>이미 로딩된 엔티티<ul><li>다음처럼 영속성 컨텍스트에 이미 로딩되어있으면 엔티티그래프 적용안됨.<br>Orders order1 = em.find(Orders.class, orderId); //이미 조회<br>hints.put(“javax.persistence.fetchgraph”, em.getEntityGraph(“Order.withMember”));<br>Orders order2 = em.find(Orders.class, orderId, hints); //이미 로딩되었기 때문에 엔티티그래프 적용X </li></ul></li><li>fetchgraph vs loadgraph <ul><li>fetchgraph는 선택한 엔티티속성만 가져옴 </li><li>loadgraph는 글로벌 페치전략이 EAGER전략으로 설정된 연관관계도 포함해서 함께 조회한다고함. </li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;컬렉션과-부가기능&quot;&gt;&lt;a href=&quot;#컬렉션과-부가기능&quot; class=&quot;headerlink&quot; title=&quot;컬렉션과 부가기능&quot;&gt;&lt;/a&gt;컬렉션과 부가기능&lt;/h1&gt;&lt;h2 id=&quot;1-컬렉션&quot;&gt;&lt;a href=&quot;#1-컬렉션&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="자바ORM표준JPA프로그래밍" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    <category term="컬렉션과 부가기능" scheme="https://codexdawn.github.io/categories/%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC-%EB%B6%80%EA%B0%80%EA%B8%B0%EB%8A%A5/"/>
    
    
    <category term="Java,JPA" scheme="https://codexdawn.github.io/tags/Java-JPA/"/>
    
    <category term="collection" scheme="https://codexdawn.github.io/tags/collection/"/>
    
    <category term="entity graph" scheme="https://codexdawn.github.io/tags/entity-graph/"/>
    
    <category term="converter" scheme="https://codexdawn.github.io/tags/converter/"/>
    
  </entry>
  
  <entry>
    <title>jpa-webapp-persistence</title>
    <link href="https://codexdawn.github.io/2021/06/05/jpa-webapp-persistence/"/>
    <id>https://codexdawn.github.io/2021/06/05/jpa-webapp-persistence/</id>
    <published>2021-06-05T11:27:18.000Z</published>
    <updated>2021-06-05T12:33:13.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="웹-애플리케이션과-영속성-관리"><a href="#웹-애플리케이션과-영속성-관리" class="headerlink" title="웹 애플리케이션과 영속성 관리"></a>웹 애플리케이션과 영속성 관리</h1><h2 id="1-트랜잭션-범위의-영속성-컨텍스트"><a href="#1-트랜잭션-범위의-영속성-컨텍스트" class="headerlink" title="1. 트랜잭션 범위의 영속성 컨텍스트"></a>1. 트랜잭션 범위의 영속성 컨텍스트</h2><h3 id="1-1-스프링-컨테이너의-기본-전략"><a href="#1-1-스프링-컨테이너의-기본-전략" class="headerlink" title="1-1. 스프링 컨테이너의 기본 전략"></a>1-1. 스프링 컨테이너의 기본 전략</h3><p>스프링 컨테이너는 <strong>트랜잭션 범위의 영속성 컨텍스트</strong> 전략을 기본으로 사용한다. 보통 스프링에서 비즈니스 로직을 시작하는 서비스 계층에 @Transactional 어노테이션을 선언해서 트랜잭션을 시작한다. 이 어노테이션이 선언되면 Spring의 트랜잭션 AOP가 먼저 동작한다.</p><blockquote><p>스프링 트랜잭션 생명주기 (@Transactional선언된 메서드 일 경우)</p><ol><li>스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작</li><li>대상 메소드가 종료되면 트랜잭션을 커밋하면서 종료한다.<ul><li>이때 트랜잭션을 커밋하면서 JPA는 먼저 영속성 컨텍스트를 플러시 해서 변경내용을 DB에 반영하고 DB 트랜잭션을 컷밋한다. </li><li>따라서, 영속성 컨텍스트의 변경내용이 DB에 정상반영된다. 만약 예외 발생하면 트랜잭션 롤백하고 종료되고, 플러시 호출은 안됨. </li></ul></li></ol></blockquote><figure class="highlight java"><figcaption><span>transactional lifecycle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloService</span>() </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PersistenceContext</span> <span class="comment">//엔티티매니저 주입 </span></span><br><span class="line">EntiryManager em; <span class="comment">//?왜했지? </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span> Repository1 repo1; </span><br><span class="line"><span class="meta">@Autowired</span> Repository2 repo2; </span><br><span class="line"></span><br><span class="line"><span class="comment">//트랜잭션 시작 </span></span><br><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">repo1.hello(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//member는 영속상태다. </span></span><br><span class="line">Member member = repo2.findMember();</span><br><span class="line"><span class="keyword">return</span> member; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//트랜잭션 종료</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository1</span> </span>&#123;</span><br><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line">EntityManager em; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">em.xxx(); <span class="comment">//A. 영속성 컨텍스트 접근 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository2</span> </span>&#123;</span><br><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line">EntityManager em; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">findMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> em.find(Member.class, <span class="string">&quot;m1&quot;</span>); <span class="comment">//B. 영속성 컨텍스트 접근 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위 코드의 트랜잭션 생명주기는 어떻까?</p><ol><li>HelloService.logic 메서드에 @Transactional이 선언되었으므로, 스프링 트랜잭션 AOP에 의해 트랜잭션 시작 </li><li>repo2.findMember를 통해 조회한 Member엔티티는 트랜잭션 범위에 있으므로 영속성 컨텍스트 관리를 받는다. 따라서 영속상태임.</li><li>@Transactional 선언한 메서드가 정상 종료되면 트랜잭션을 커밋하는데, 이때 영속성 컨텍스트를 종료한다. 영속성 컨텍스트가 사라졋으므로 조회한 엔티티(member)는 이제부터 준영속 상태가 된다.</li><li>서비스 메서드가 끝나면서 트랜잭션과 영속성 컨텍스트가 종료되었다. 따라서 컨트롤러에 반환된 member엔티티는 준영속상태로 관리된다. </li></ol><h3 id="트랜잭션이-같으면-같은-영속성-컨텍스트를-사용한다"><a href="#트랜잭션이-같으면-같은-영속성-컨텍스트를-사용한다" class="headerlink" title="트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다."></a>트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.</h3><p>위 코드의 2개의 repository 로 접근한 A,B는 같은 트랜잭션에서 수행됨에따라, A,B는 비록 다른 엔티티매니저 이지만, 같은 영속성 컨텍스트를 사용하게 된다.</p><h3 id="트랜잭션이-다르면-다른-영속성-컨텍스트를-사용한다"><a href="#트랜잭션이-다르면-다른-영속성-컨텍스트를-사용한다" class="headerlink" title="트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다."></a>트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.</h3><p>위 코드에서 여러 스레드에서 동시에 요청이와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다. 좀 더 들어가면 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티스레드 환경에서 안전하다. </p><h2 id="2-준영속-상태와-지연로딩"><a href="#2-준영속-상태와-지연로딩" class="headerlink" title="2. 준영속 상태와 지연로딩"></a>2. 준영속 상태와 지연로딩</h2><h3 id="준영속-상태와-지연로딩"><a href="#준영속-상태와-지연로딩" class="headerlink" title="준영속 상태와 지연로딩"></a>준영속 상태와 지연로딩</h3><p>준영속 상태의 가장 골치아픈 문제는 지연로딩 기능이 동작하지 않는다. 예를들어 뷰를 렌더링할때 연관된 엔티티도 함께 사용해야 하는데 연관된 엔티티를 지연 로딩으로 설정해서 프록시 객체로 조회했다고 가장하자. 아직 초기화 하지 않은 프록시객체를 사용하려고 초기화를 시도함. 하지만 준영속 상태에서는 영속성 컨텍스트가 없으므로 지연로딩을 할수 없다. 이때 지연로딩을 시도하면 문제가 발생함. (LazyInitializationException 예외 발생)</p><h4 id="준영속-상태의-지연로딩-문제를-해결하는-방법-2가지"><a href="#준영속-상태의-지연로딩-문제를-해결하는-방법-2가지" class="headerlink" title="준영속 상태의 지연로딩 문제를 해결하는 방법 2가지"></a>준영속 상태의 지연로딩 문제를 해결하는 방법 2가지</h4><ol><li>뷰가 필요한 엔티티를 미리 로딩해두는 방법 <ul><li>글로벌 패치 전략 수정 </li><li>JPQL fetch join </li><li>강제로 초기화 </li></ul></li><li>OSIV를 사용해서 엔티티를 항상 영속상태로 유지하는 방법 </li></ol><h4 id="1-글로벌-페치-전략-수정"><a href="#1-글로벌-페치-전략-수정" class="headerlink" title="1. 글로벌 페치 전략 수정"></a>1. 글로벌 페치 전략 수정</h4><p>글로벌 페치 전략을 Lazy로딩 상태에서 Eager로 수정하면 쿼리를 조인해서 한꺼번에 가져오게된다.<br>하지만 즉시로딩을 전략을 사용하게되면 치명적인 단점 2가지가 존재한다.</p><blockquote><p>글로벌 페치 전략에 즉시로딩을 사용시 단점 </p><ol><li>사용하지 않는 엔티티를 로딩한다. <ul><li>말그대로 의도와 다르게 하나의 엔티티만 사용하고싶은데, 즉시로딩 전략상 조인된 테이블을 한꺼번에 가져와야하기때문에 </li></ul></li><li>N+1 문제 유발 <ul><li>JPA가 JPQL을 분석해서 SQL을 생성할때는 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용한다. </li><li>select o from Order o -&gt; JPQL을 수행하면 실제로 select * from Order만 나가는게 아니라 Member테이블의 정보도 같이 조회 해야한다. 즉시로딩으로 정보를 가져와야하기때문에</li></ul></li></ol></blockquote><h4 id="2-JPQL-fetch-join-사용"><a href="#2-JPQL-fetch-join-사용" class="headerlink" title="2. JPQL fetch join 사용"></a>2. JPQL fetch join 사용</h4><p>fetch join하게되면 한방쿼리로 만들어줘서, 미리 로딩시키는 효과를 볼수있음. (N+1문제도 자연스럽게 해결됨.)</p><h4 id="3-강제로-초기화"><a href="#3-강제로-초기화" class="headerlink" title="3. 강제로 초기화"></a>3. 강제로 초기화</h4><p>서비스 로직에서 orderRepository.findOrder(id) 호출후 order.getMember().getName()까지 호출해서 프록시 객체를 강제로 초기화 시켜둔다.<br>이런 강제로 초기화 작업을 해주기 위해서는 프록시 초기화를 담당하는 계층이 필요하다. 그 계층이 FACADE계층이다. </p><blockquote><p>FACADE 계층의 역할과 특징 </p><ul><li>프리젠테이션 계층과 도메인 모델 계층간의 논리적 의존성 분리를 해줌.</li><li>프리젠테이션 꼐층에서 필요한 프록시 객체를 초기화 한다.</li><li>서비스 계층을 호출해서 비즈니스 로직을 실행한다.</li><li>리포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾는다. </li></ul><p>FACADE 계층 사용시 주의점 </p><ul><li>프록시를 초기화하라면 영속성컨텍스트가 필요하므로 FACADE에서 @Transactional이 선언되어야함. (서비스도 호출하고 리포지토리도 호출하기 때문)</li></ul></blockquote><p>하지만 위 3가지 방법으로 지연로딩에서 VIEW에서 호출하기 전에 데이터를 미리 담아두는 방법을 사용해도, 결국 준영속 상태에서 초기화 이슈에 대한 예외발생은 발생할수밖에없음. 이런 부분을 해결하기 위해서는 OSIV를 적용해야함.  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;웹-애플리케이션과-영속성-관리&quot;&gt;&lt;a href=&quot;#웹-애플리케이션과-영속성-관리&quot; class=&quot;headerlink&quot; title=&quot;웹 애플리케이션과 영속성 관리&quot;&gt;&lt;/a&gt;웹 애플리케이션과 영속성 관리&lt;/h1&gt;&lt;h2 id=&quot;1-트랜잭션-범위</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="자바ORM표준JPA프로그래밍" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    <category term="웹 애플리케이션과 영속성 관리" scheme="https://codexdawn.github.io/categories/%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/"/>
    
    
    <category term="Java,JPA" scheme="https://codexdawn.github.io/tags/Java-JPA/"/>
    
    <category term="webapp" scheme="https://codexdawn.github.io/tags/webapp/"/>
    
    <category term="persistence context" scheme="https://codexdawn.github.io/tags/persistence-context/"/>
    
  </entry>
  
  <entry>
    <title>jpa-query-custom-repository</title>
    <link href="https://codexdawn.github.io/2021/06/02/jpa-query-custom-repository/"/>
    <id>https://codexdawn.github.io/2021/06/02/jpa-query-custom-repository/</id>
    <published>2021-06-02T11:44:52.000Z</published>
    <updated>2021-06-02T12:07:59.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QueryDSL-삽질기-Custom-CustomImpl-Repository-설정-삽질"><a href="#QueryDSL-삽질기-Custom-CustomImpl-Repository-설정-삽질" class="headerlink" title="QueryDSL 삽질기! (Custom / CustomImpl Repository 설정 삽질)"></a>QueryDSL 삽질기! (Custom / CustomImpl Repository 설정 삽질)</h1><h2 id="사건의-발단"><a href="#사건의-발단" class="headerlink" title="사건의 발단"></a>사건의 발단</h2><p>오늘 근무하다가 동료가 QueryDSL관련 오류가 있다고해서 같이 확인하게되었는데, 결국 동료가 발견하게되었다.<br>사건의 발단은 QueryDSL과 Spring Data JPA를 같이 사용하기 위해서는 사용하는 interface/구체클래스에 Custom/CustomImpl 네이밍을 맞추는것을 국룰로 정해놨다. 근데 동료분께서 Impl쪽 구체클래스에 xxxxCustomsImpl로 s를 붙여넣고 말았다. 근데 문제는 쿼리가 의도한 쿼리가 안나가고 Spring Data JPA쿼리로 나가버리는것이었다. </p><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h2><ul><li>Custom/CustomImpl은 Spring DATA JPA 네이밍 쿼리가 먹도록 설계되어있다. 그래서 국룰로 정하라는것이었다. </li><li>네이밍이 안맞아서 interface의 정의한 쿼리 네이밍을 가져와서 쿼리로 작성한것으로 판단되었다. 근데 네이밍을 좀 이상하게 지어도 나가는것보면, 그냥 기본쿼리로 나가는것으로 확인되어진다. </li></ul><p><a href="https://jojoldu.tistory.com/372">jojoldu JPA 정리</a><br><a href="https://docs.spring.io/spring-data/jpa/docs/2.1.3.RELEASE/reference/html/#repositories.custom-implementations">Spring Data JPA 공식문서</a></p><h2 id="해결방법"><a href="#해결방법" class="headerlink" title="해결방법"></a>해결방법</h2><ul><li>절대로 QueryDSL 에서 Custom/CustomImpl의 클래스 네이밍은 오타 내지말자! (삽질의 시작이 될수 있음.)</li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>Custom/CustomImpl 도 Spring Data JPA 네임드쿼리가 적용됨.(repository interface만 되는줄 알았음.)</li><li>Custom/CustomImpl 의 클래스 네이밍은 절대로 오타내지말자! </li><li>CustomImpl의 오타가 났음에도 불구하고 기본 조회 쿼리가 나간것 확인해보면 interface정의한 부분에서 메서드 네임을 인식한것으로 확인되어짐. (조금 이상하게 날려도 나가긴 나갔음. 하지만 아예 이상하게 날리면 Spring DATA Jpa에서 네임드 쿼리 인식이 안된다고 오류 밷어냄.)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QueryDSL-삽질기-Custom-CustomImpl-Repository-설정-삽질&quot;&gt;&lt;a href=&quot;#QueryDSL-삽질기-Custom-CustomImpl-Repository-설정-삽질&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="QueryDSL" scheme="https://codexdawn.github.io/categories/QueryDSL/"/>
    
    <category term="Spring Data JPA" scheme="https://codexdawn.github.io/categories/Spring-Data-JPA/"/>
    
    <category term="Spring Boot" scheme="https://codexdawn.github.io/categories/Spring-Boot/"/>
    
    
    <category term="QueryDSL" scheme="https://codexdawn.github.io/tags/QueryDSL/"/>
    
    <category term="Java,JPA,Spring" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring/"/>
    
    <category term="Custom Repository" scheme="https://codexdawn.github.io/tags/Custom-Repository/"/>
    
  </entry>
  
  <entry>
    <title>java8-chaptor3</title>
    <link href="https://codexdawn.github.io/2021/05/20/java8-chaptor3/"/>
    <id>https://codexdawn.github.io/2021/05/20/java8-chaptor3/</id>
    <published>2021-05-20T14:08:15.000Z</published>
    <updated>2021-05-21T14:50:28.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chaptor3-람다-표현식"><a href="#Chaptor3-람다-표현식" class="headerlink" title="Chaptor3. 람다 표현식"></a>Chaptor3. 람다 표현식</h1><h2 id="3-1-람다란"><a href="#3-1-람다란" class="headerlink" title="3-1. 람다란?"></a>3-1. 람다란?</h2><p>람다는 메서드로 전달할수 있는 익명함수를 단순화 한것 </p><h3 id="람다의-특징"><a href="#람다의-특징" class="headerlink" title="람다의 특징"></a>람다의 특징</h3><ul><li>익명 : 보통의 메서드와 달리 익명이라표현 </li><li>함수 : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 <strong>함수</strong> 라고 부름. 단, 메서드와 동일하게 파라미터, 바디, 반환형식 간으한 예외 리스트를 포함함.</li><li>전달 : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할수 있음. </li><li>간결성 : 익명 클래스처럼 많은 자질 구레한 코드를 구현할 필요가 없음. </li></ul><h2 id="3-2-함수형-인터페이스"><a href="#3-2-함수형-인터페이스" class="headerlink" title="3-2. 함수형 인터페이스"></a>3-2. 함수형 인터페이스</h2><p>함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다! </p><figure class="highlight java"><figcaption><span>함수형인터페이스들</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PrivilegedAction</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-람다-활용"><a href="#3-3-람다-활용" class="headerlink" title="3-3. 람다 활용"></a>3-3. 람다 활용</h2><figure class="highlight java"><figcaption><span>processFile메서드를 람다로 변환 과정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;data.txt&quot;</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1단계-동작-파라미터화를-기억하라"><a href="#1단계-동작-파라미터화를-기억하라" class="headerlink" title="1단계: 동작 파라미터화를 기억하라!"></a>1단계: 동작 파라미터화를 기억하라!</h3><p>위 코드는 파일에서 한번에 한줄만 읽을수 있음. 한번에 두줄을 읽거나 가장 자주 사용되는 단어를 반환하려면 어떻게 해야할까?<br>결론은 동작파라미터화를 사용하는것이다. 아래 코드처럼 작성이 되어야할것이다. </p><figure class="highlight java"><figcaption><span>processFile메서드를 람다로 변환 과정-동작파라미터화1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); </span><br></pre></td></tr></table></figure><h3 id="2단계-함수형-인터페이스를-이용해서-동작-전달"><a href="#2단계-함수형-인터페이스를-이용해서-동작-전달" class="headerlink" title="2단계: 함수형 인터페이스를 이용해서 동작 전달!"></a>2단계: 함수형 인터페이스를 이용해서 동작 전달!</h3><figure class="highlight java"><figcaption><span>processFile메서드를 람다로 변환 과정-동작파라미터화2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BufferedReaderProcessor</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">process</span><span class="params">(BufferedReader b)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3단계-동작실행"><a href="#3단계-동작실행" class="headerlink" title="3단계: 동작실행!"></a>3단계: 동작실행!</h3><figure class="highlight java"><figcaption><span>processFile메서드를 람다로 변환 과정-동작파라미터화3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;data.txt&quot;</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> p.process(br);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4단계-람다-전달"><a href="#4단계-람다-전달" class="headerlink" title="4단계: 람다 전달!"></a>4단계: 람다 전달!</h3><figure class="highlight java"><figcaption><span>processFile메서드를 람다로 변환 과정-동작파라미터화4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String oneLine = processFile((BufferedReader br) -&gt; br.readLine());</span><br><span class="line">String twoLine = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine());</span><br></pre></td></tr></table></figure><h2 id="3-4-함수형-인터페이스-사용"><a href="#3-4-함수형-인터페이스-사용" class="headerlink" title="3-4. 함수형 인터페이스 사용"></a>3-4. 함수형 인터페이스 사용</h2><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><figure class="highlight java"><figcaption><span>Predicate사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">List&lt;T&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(T s: list) &#123;</span><br><span class="line"><span class="keyword">if</span>(p.test(s)) &#123;</span><br><span class="line">results.add(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();</span><br><span class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings, noneEmptyStringPredicate); </span><br></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight java"><figcaption><span>Consumer사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(T i: list) &#123;</span><br><span class="line">c.accept(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), (Integer i) -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><figure class="highlight java"><figcaption><span>Function사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; f)</span> </span>&#123;</span><br><span class="line">List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span>(T s: list) &#123;</span><br><span class="line"> result.add(f.apply(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; stringLength = map(Arrays.asList(<span class="string">&quot;lambdas&quot;</span>,<span class="string">&quot;in&quot;</span>,<span class="string">&quot;action&quot;</span>),((String s) -&gt; s.length()));</span><br></pre></td></tr></table></figure><h4 id="기본형-특화"><a href="#기본형-특화" class="headerlink" title="기본형 특화"></a>기본형 특화</h4><p>자바의 모든형식은 참조형과 기본형으로 나눌수있음. </p><blockquote><p>참조형 : Byte, Integer, Object..<br>기본형 : int,double,long,char..<br>기본형을 참조형으로 변환하는 부분을 박싱(boxing)이라고 하고, 참조형을 기본형으로 변호나하는 동작을 언박싱(unboxing)이라고함. 자바에서는 이런 박싱/언박싱을 자동으로 해주는데, 이를 오토박싱이라함.<br>하지만 이런 변환과정은 비용이 소모됨. 박싱한 값은 기본형으로 감싸는 래퍼며 힙에 저장됨. 따라서 박싱한 값은 메모리를 더 소비하며 기본형을 가져올때도 메모리를 탐색하는 과정이 필요함. </p></blockquote><p>자바8에서는 이런 박싱/언박싱 되는 부분을 위해서 함수형인터페이스로 아예 제공하고있음.<br>예를들면 int파라미터를 받는 부분을 boolean으로 변환시켜주는 Predicate는 IntPredicate이런식으로 아예 기본클래스로 제공하고있음.<br>더 자세한 부분은 아래 참고 </p><p><img src="/images/java8/java-2.png" alt="오토박싱지원되는 함수형인터페이스"></p><p><img src="/images/java8/java-3.png" alt="람다와 함수형인터페이스 관계 예제"></p><blockquote><p>예외,람다,함수형 인터페이스 관계<br>함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않는다. 즉, 예외를 던지는 람다 표현식을 만드려면 확인된 예외를 선언하는 함수형 인터페이스를 직접 정의하거나 람다를 try/catch블록으로 감싸야함</p><p>@FunctionalInterface<br>public interface BufferedReaderProcessor {<br>    String process(BufferedReader b) throws IOException;<br>}<br>BufferedReaderProcessor p = (BufferedReader br) -&gt; br.readLine();</p><p>위와같이 지난 예제에서 동작파라미터화를 통해 BufferedReaderProcessor를 만들어서 예외처리까지 가능하도록 만들었었다. 하지만 이부분은 함수형 인터페이스의 Function&lt;T,R&gt;의 형태를 사용하고 있기 때문에 아래와같이 더 간단한 람다표현식으로 변경시켜서 명시적으로 확인된 예외를 체크할수있다. </p><p>Function&lt;BufferedReader, String&gt; f =<br>  (BufferedReader b) -&gt; {<br>    try {<br>      return b.readLine();<br>    }<br>    catch(IOException e) {<br>      throw new RuntimeException(e);<br>    }<br>  };</p></blockquote><h2 id="3-5-형식-검사-형식-추론-제약"><a href="#3-5-형식-검사-형식-추론-제약" class="headerlink" title="3-5. 형식 검사, 형식 추론, 제약"></a>3-5. 형식 검사, 형식 추론, 제약</h2><h3 id="지역-변수-사용"><a href="#지역-변수-사용" class="headerlink" title="지역 변수 사용"></a>지역 변수 사용</h3><p>람다 표현식에는 익명함수가 하는 것처럼 자유 변수(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용 할수 있다. 이와 같은 동작을 람다 캡처링이라고 부른다. 람다는 인스턴스 변수와 정적 변수를 캡처(자신의 바디에서 참조할수 있도록) 할수 있다. 하지만 지역 변수는 명시적으로 final로 선언되어 있어야 하거나 실질적으로 final 로 선언된 변수와 똑같이 사용되어야 한다. </p><h4 id="지역변수의-제약"><a href="#지역변수의-제약" class="headerlink" title="지역변수의 제약"></a>지역변수의 제약</h4><p>지역 변수에 왜 이런 제약이 필요할까?</p><ul><li>인스턴스 변수 와 지역변수는 태생적으로 다름. 인스턴수 변수는 힙에 저장되지만, 지역변수는 스택에 쌓임 </li><li>만약 람다에서 지역 변수에 바로 접근 할수 있다는 가정하에 람다가 스레드에서 실행된다면, 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당변수에 접근하려 할 수 있다. </li><li>위 와 같은 이유로 자바는 원래 변수에 접근을 허용하는것이 아니라, 자유 지역 변수의 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로 지역변수에는 한 번만 값을 할당해야 한다는 제약이 생긴것이다. </li></ul><blockquote><p>클로저????<br>원칙적으로 클로저란 함수의 비지역 변수를 자유롭게 참조할수있는 함수의 인스턴스를 가르킨다. 클로저는 클로저 외부에 정의된 변수의값에 접근하고, 갑을 바꿀수 있다. 다만 람다와 익명 클래스는 람다가 정의된 메서드의 지역변수의 값은 바꿀수없다. 람다가 정의된 메서드의 지역변수값은 final 변수여야한다. 위에 설명하였지만 지역 변수값은 스택에 쌓이기때문에 자신을 정의한 스레드와 생존을 같이 해야 하며, 따라서 지역변수는 final이어야한다. 가변 지역 변수를 새로운 스레드에서 캡처할수있다면 안전하지 않은 동작을 수행할 가능성이 생긴다.(인스턴스 변수는 스레드가 공유하는 힙에 존재하므로 특별한 제약이 없다.)</p></blockquote><h2 id="3-6-메서드-레퍼런스"><a href="#3-6-메서드-레퍼런스" class="headerlink" title="3-6. 메서드 레퍼런스"></a>3-6. 메서드 레퍼런스</h2><h3 id="메서드-레퍼런스를-만드는-방법"><a href="#메서드-레퍼런스를-만드는-방법" class="headerlink" title="메서드 레퍼런스를 만드는 방법"></a>메서드 레퍼런스를 만드는 방법</h3><ol><li>정적 메서드 레퍼런스 <ul><li>Integer::parInt </li></ul></li><li>다양한 형식의 인스턴스 메서드 레퍼런스<ul><li>String::length</li></ul></li><li>기존 객체의 인스턴스 메서드 레퍼런스 <ul><li>Transaction a1 = new Transaction(); void getValue() {}; a1::getValue </li></ul></li></ol><h4 id="생성자-레퍼런스"><a href="#생성자-레퍼런스" class="headerlink" title="생성자 레퍼런스"></a>생성자 레퍼런스</h4><figure class="highlight java"><figcaption><span>생성자레퍼런스 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>; <span class="comment">//디폴트 생성자</span></span><br><span class="line">Apple a1 = c1.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//위 예제는 아래와 같음 </span></span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; <span class="keyword">new</span> Apple();</span><br><span class="line">Apple a1 = c1.get(); </span><br><span class="line"></span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = Apple::<span class="keyword">new</span>; <span class="comment">//Apple(Integer weight) 생성자 함수 </span></span><br><span class="line">Apple a2 = c2.get(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//위 예제는 아래와 같음 </span></span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = (Integer weight) -&gt; <span class="keyword">new</span> Apple(weight);</span><br><span class="line">Apple a2 = c2.get(<span class="number">110</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//map과 같은 메서드를 이용해서 Apple생성자로 전달 가능 </span></span><br><span class="line">List&lt;Integer&gt; weights = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">List&lt;Apple&gt; apples = map(weights, Apple::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">map</span><span class="params">(List&lt;Integer&gt; list, Function&lt;Integer, Apple&gt; f)</span> </span>&#123;</span><br><span class="line">List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Integer e : list) &#123;</span><br><span class="line">result.add(f.apply(e));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-람다-표현식을-조합할수-있는-유용한-메서드"><a href="#3-7-람다-표현식을-조합할수-있는-유용한-메서드" class="headerlink" title="3-7. 람다 표현식을 조합할수 있는 유용한 메서드"></a>3-7. 람다 표현식을 조합할수 있는 유용한 메서드</h2><h3 id="Comparator-조합"><a href="#Comparator-조합" class="headerlink" title="Comparator 조합"></a>Comparator 조합</h3><figure class="highlight java"><figcaption><span>Comparator 조합</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight);</span><br><span class="line"><span class="comment">//역정렬 가능 </span></span><br><span class="line">inventory.sort(comparing(Apple::getWeight).reversed());</span><br><span class="line"></span><br><span class="line">inventory.sort(comparing(Apple::getWeight)</span><br><span class="line">.reversed() <span class="comment">//무게를 내림차순으로 정렬</span></span><br><span class="line">.thenComparing(Apple::getCountry)); <span class="comment">// 두 사과의 무게가 같음 국가별로 정렬 (2차 정렬)</span></span><br></pre></td></tr></table></figure><h3 id="Predicate-조합"><a href="#Predicate-조합" class="headerlink" title="Predicate 조합"></a>Predicate 조합</h3><figure class="highlight java"><figcaption><span>Predicate 조합</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>)</span><br><span class="line">   .or(a -&gt; <span class="string">&quot;green&quot;</span>.equals(a.getColor()));</span><br></pre></td></tr></table></figure><h3 id="Function-조합"><a href="#Function-조합" class="headerlink" title="Function 조합"></a>Function 조합</h3><figure class="highlight java"><figcaption><span>Predicate 조합</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//andThen</span></span><br><span class="line">Function&lt;Integer,Integer&gt; f = x -&gt; x + <span class="number">1</span>; </span><br><span class="line">Function&lt;Integer,Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer,Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>); <span class="comment">//4반환 f먼저 계산하고 g계산 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//compose </span></span><br><span class="line">Function&lt;Integer,Integer&gt; f = x -&gt; x + <span class="number">1</span>; </span><br><span class="line">Function&lt;Integer,Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer,Integer&gt; h = f.compose(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>); <span class="comment">//3반환 g먼저 계산하고 f계산</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Letter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addHeader</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;From Raoul, Mario and Alan: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addFooter</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text + <span class="string">&quot; Kind regards&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">checkSpelling</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text.replaceAll(<span class="string">&quot;labda&quot;</span>, <span class="string">&quot;lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//header추가 -&gt; 스펠링체크 -&gt; footer추가 순으로 파이프라이닝을 만들수있음. (메서드체이닝)</span></span><br><span class="line">Function&lt;String, String&gt; addHeader = Letter::addHeader;</span><br><span class="line">Function&lt;String, String&gt; transformationPipeline</span><br><span class="line">  = addHeader.andThen(Letter::checkSpelling)</span><br><span class="line">             .andThen(Letter::addFooter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//스펠링체크는 제낄수있음. </span></span><br><span class="line">Function&lt;String, String&gt; addHeader = Letter::addHeader;</span><br><span class="line">Function&lt;String, String&gt; transformationPipeline</span><br><span class="line">  = addHeader.andThen(Letter::addFooter);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chaptor3-람다-표현식&quot;&gt;&lt;a href=&quot;#Chaptor3-람다-표현식&quot; class=&quot;headerlink&quot; title=&quot;Chaptor3. 람다 표현식&quot;&gt;&lt;/a&gt;Chaptor3. 람다 표현식&lt;/h1&gt;&lt;h2 id=&quot;3-1-람다란&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Java8InAction" scheme="https://codexdawn.github.io/categories/Java8InAction/"/>
    
    
    <category term="Java8" scheme="https://codexdawn.github.io/tags/Java8/"/>
    
    <category term="람다 표현식" scheme="https://codexdawn.github.io/tags/%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D/"/>
    
    <category term="lambda" scheme="https://codexdawn.github.io/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>jpa-obj-query-3</title>
    <link href="https://codexdawn.github.io/2021/05/20/jpa-obj-query-3/"/>
    <id>https://codexdawn.github.io/2021/05/20/jpa-obj-query-3/</id>
    <published>2021-05-20T10:59:56.000Z</published>
    <updated>2021-05-20T12:42:11.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체지향-쿼리-언어3"><a href="#객체지향-쿼리-언어3" class="headerlink" title="객체지향 쿼리 언어3"></a>객체지향 쿼리 언어3</h1><h2 id="1-Persistance-Context와-JPQL"><a href="#1-Persistance-Context와-JPQL" class="headerlink" title="1. Persistance Context와 JPQL"></a>1. Persistance Context와 JPQL</h2><h3 id="1-1-쿼리후-영속상태인-것과-아닌것"><a href="#1-1-쿼리후-영속상태인-것과-아닌것" class="headerlink" title="1-1. 쿼리후 영속상태인 것과 아닌것"></a>1-1. 쿼리후 영속상태인 것과 아닌것</h3><figure class="highlight java"><figcaption><span>영속상태구분</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select m form Member m <span class="comment">//엔티티조회 (영속성 관리됨)</span></span><br><span class="line">select o.address from Order o <span class="comment">//임베디드타입 조회 (영속성 관리 안됨)</span></span><br><span class="line">select m.id, m.username from Member m <span class="comment">//단순 필드조회 (영속성 관리 안됨)</span></span><br></pre></td></tr></table></figure><p>위 예제를 통해 알수있듯이, 조회한 엔티티만 영속성 컨텍스트에 관리가 됨. </p><h3 id="1-2-JPQL로-조회한-엔티티와-영속성-컨텍스트"><a href="#1-2-JPQL로-조회한-엔티티와-영속성-컨텍스트" class="headerlink" title="1-2. JPQL로 조회한 엔티티와 영속성 컨텍스트"></a>1-2. JPQL로 조회한 엔티티와 영속성 컨텍스트</h3><figure class="highlight java"><figcaption><span>영속상태구분</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">em.find(Member.class,<span class="string">&quot;m1&quot;</span>); <span class="comment">//회원1 조회 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//엔티티 쿼리 조회 결과가 회원1, 회원2</span></span><br><span class="line">List&lt;Member&gt; resultList = em.createQuery(<span class="string">&quot;select m from Member m&quot;</span>, Member.class).getResultList(); </span><br></pre></td></tr></table></figure><p>em.find로 회원1을 조회했는데, JPQL로 전체를 가져오는 List를 호출하였다. 그럼 위 조회 과정은 어떻게 될까?</p><blockquote><p>em.find 호출뒤, List 조회 했을경우 </p><ol><li>JPQL을 사용해서 조회 요청</li><li>JPQL은 SQL로 변환되어 DB에 조회 </li><li>조회한 결과와 영속성 컨텍스트를 비교 (em.find로 조회된값 : m1 ,조회한값 :m1,m2)</li><li>식별자 기준으로 m1은 이미 영속성관리에 있으므로 버리고, 기존에 영속성관리에 있던 m1이 반환대상이됨.</li><li>식별자 기준으로 m2는 영속성 컨텍스트에 없으므로, 영속성컨텍스트에 추가 </li><li>쿼리 결과인 m1,m2를 반환한다. 여기서 m1은 쿼리결과가 아니라 영속성 컨텍스트에 있던 엔티티임을 잊지말자! </li></ol></blockquote><p>여기서 알수있는 2가지 사실이있다.</p><ol><li>JPQL로 조회한 엔티티는 영속상태다. </li><li>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다. </li></ol><p>영속성 컨텍스트는 영속상태인 엔티티의 동일성을 보장한다. em.find이든 JPQL로 조회하든 영속성 컨텍스트가 같으면 동일한 엔티티를 반환함. </p><h3 id="1-3-find-VS-JPQL"><a href="#1-3-find-VS-JPQL" class="headerlink" title="1-3. find() VS JPQL"></a>1-3. find() VS JPQL</h3><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><ul><li>find 메서드는 엔티티를 영속성 컨텍스트에 먼저 찾고 없으면 DB에서 찾는다. 따라서 해당 엔티티가 영속성 컨텍스트에 존재하면 메모리에서 바로 찾으므로 성능상 이점이 있다. (그래서 1차캐시라 부름)</li></ul><h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4><ul><li>JPQL은 항상 디비를 조회한다.</li><li>JPQL로 조회한 엔티티는 영속상태다. (왜냐 DB 조회후,영속성컨텍스트에 집어넣기때문 )</li><li>영속성 컨텍스트에 이미 존재하는 엔티티가있으면 기존 엔티티를 반환함. </li></ul><h2 id="2-JPQL과-flush모드"><a href="#2-JPQL과-flush모드" class="headerlink" title="2. JPQL과 flush모드"></a>2. JPQL과 flush모드</h2><h3 id="2-1-쿼리와-플러시-모드"><a href="#2-1-쿼리와-플러시-모드" class="headerlink" title="2-1. 쿼리와 플러시 모드"></a>2-1. 쿼리와 플러시 모드</h3><ul><li>JPQL은 영속성 컨텍스트 고려하지 않고, DB를 먼저 조회함. 따라서 JPQL을 실행하기전에 영속성 컨텍스트의 내용을 DB에 반영해야함. 그렇지 않으면 상이한결과가 발생할수있음. </li><li>FlushMode는 두가지있음. AUTO,COMMIT 이다.<ul><li>AUTO : FlushMode를 따로 지정하지 않으면 기본값임. AUTO는 JPQL가 수행되면 자동 FLUSH시켜버림. </li><li>COMMIT : COMMIT모드면 말그대로 커밋시점에 FLUSH가 됨. 따라서 JPQL쿼리가 수행되도, FLUSH되지않음. </li></ul></li><li>FlushMode.COMMIT은 왜 씀? <ul><li>flush가 너무 빈번하게 일어나는 상황에서 이모드를 사용하면 쿼리시 발생하는 플러시 횟수를 줄여서 성능 최적화 가능함. </li></ul></li><li>JPA를 사용하지않고, JDBC를 직접 사용해서 SQL을 실행할때도 플러시모드는 고민해야함. JPA를 통하지않고 JDBC로 직접 실행하면 JPA는 JDBC가 실행한 쿼리를 인식할 방법이 없음. 따라서 별도 JDBC호출은 플러시 모드를 AUTO로설정해도 무의미함. 이때는 JDBC로 쿼리를 실행하기전에 em.flush를 호출해서 영속성 컨텍스트의 내용을 디비에 동기화 하는게 안점함. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;객체지향-쿼리-언어3&quot;&gt;&lt;a href=&quot;#객체지향-쿼리-언어3&quot; class=&quot;headerlink&quot; title=&quot;객체지향 쿼리 언어3&quot;&gt;&lt;/a&gt;객체지향 쿼리 언어3&lt;/h1&gt;&lt;h2 id=&quot;1-Persistance-Context와-JPQL&quot;&gt;</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="자바ORM표준JPA프로그래밍" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    <category term="객체지향쿼리언어" scheme="https://codexdawn.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4/"/>
    
    
    <category term="Java,JPA" scheme="https://codexdawn.github.io/tags/Java-JPA/"/>
    
    <category term="QueryDSL" scheme="https://codexdawn.github.io/tags/QueryDSL/"/>
    
    <category term="객체지향쿼리언어3" scheme="https://codexdawn.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B43/"/>
    
  </entry>
  
  <entry>
    <title>coding-test-study-2</title>
    <link href="https://codexdawn.github.io/2021/05/15/coding-test-study-2/"/>
    <id>https://codexdawn.github.io/2021/05/15/coding-test-study-2/</id>
    <published>2021-05-15T09:15:44.000Z</published>
    <updated>2021-05-15T09:37:07.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linkedlist-링크드리스트"><a href="#linkedlist-링크드리스트" class="headerlink" title="linkedlist (링크드리스트)"></a>linkedlist (링크드리스트)</h1><h2 id="1-linkedlist-구조"><a href="#1-linkedlist-구조" class="headerlink" title="1. linkedlist 구조"></a>1. linkedlist 구조</h2><ul><li><p>연결 리스트라고도 함</p></li><li><p>배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조</p></li><li><p>링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조</p></li><li><p>링크드 리스트 기본 구조와 용어</p><ul><li>노드(Node): 데이터 저장 단위 (데이터값, 포인터) 로 구성</li><li>포인터(pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간</li></ul></li><li><p>일반적인 링크드 리스트 형태<br><img src="https://www.fun-coding.org/00_Images/linkedlist.png" alt="출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list"></p></li></ul><h2 id="2-SingleLinkedList-구현"><a href="#2-SingleLinkedList-구현" class="headerlink" title="2. SingleLinkedList 구현"></a>2. SingleLinkedList 구현</h2><figure class="highlight java"><figcaption><span>linkedlist구현1-Node클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>SingleLinkedList</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//노트 추가</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//head가 아무것도 없을경우</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node&lt;&gt;(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;T&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//노드 탐색 (null이 아닐때까지 탐색)</span></span><br><span class="line">            <span class="keyword">while</span>(node.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 맨 마자막 노드의 next에 새로운 노드 추가 및 생성</span></span><br><span class="line">            node.setNext(<span class="keyword">new</span> Node&lt;&gt;(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;head.getData() = &quot;</span> + head.getData());</span><br><span class="line">            Node&lt;T&gt; node = head;</span><br><span class="line">            <span class="keyword">while</span>(node.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.getNext();</span><br><span class="line">                System.out.println(<span class="string">&quot;node.getData() = &quot;</span> + node.getData());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeInside</span><span class="params">(T data, T target)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; targetNode = <span class="keyword">this</span>.search(target);</span><br><span class="line">        Node&lt;T&gt; addNode = <span class="keyword">new</span> Node&lt;&gt;(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// head노드가 targetNode와 같을때 head바로 뒷노드에 생성(next되는 노드들 변경)</span></span><br><span class="line">        <span class="keyword">if</span>(head == targetNode) &#123;</span><br><span class="line">            addNode.setNext(head.getNext());</span><br><span class="line">            head.setNext(addNode);</span><br><span class="line">            <span class="comment">//this.addNode(data);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 정말 바보같이 한번 더 탐색을 했다. (이미 탐색해서 그정보가지고 하면 된다는걸 알았는데.. targetNode의 next노드를 미리 assignment를 해놓고 해야한다는 생각을 못했음.) </span></span><br><span class="line"><span class="comment">// 정말 바보같은 짓을 했다. 한번 더 생각하라고 주석처리했음.  </span></span><br><span class="line"><span class="comment">/*Node&lt;T&gt; node = head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //노드 탐색</span></span><br><span class="line"><span class="comment">            while(node.getNext() != null) &#123;</span></span><br><span class="line"><span class="comment">                node = node.getNext();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                //targetNode와 같은 노드일경우 그 다음 노드에 생성 역시 next로 참조되는 부분 변경</span></span><br><span class="line"><span class="comment">                if(node == targetNode) &#123;</span></span><br><span class="line"><span class="comment">                    addNode.setNext(node.getNext());</span></span><br><span class="line"><span class="comment">                    node.setNext(addNode);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            Node&lt;T&gt; nextNode = targetNode.getNext();</span><br><span class="line">            targetNode.setNext(addNode);</span><br><span class="line">            addNode.setNext(nextNode);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//head의 데이터가 target과 같을 경우</span></span><br><span class="line">        <span class="keyword">if</span>(head.getData() == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;T&gt; node = head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//노드 탐색</span></span><br><span class="line">            <span class="keyword">while</span>(node.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//탐색된 노드의 데이터와 target이 같을경우 해당 노드반환</span></span><br><span class="line">                <span class="keyword">if</span>(node.getData() == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node = node.getNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//아무것도 탐색되지 않았을때는 그냥 마지막 노드 반환 (맨마지막에 넣어주기위해서)</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteNode</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//head가 제거 대상일경우는 다음 노드가 head가됨</span></span><br><span class="line">        <span class="keyword">if</span>(head.getData() == target) &#123;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;T&gt; node = head;</span><br><span class="line">            <span class="comment">//노드 탐색</span></span><br><span class="line">            <span class="keyword">while</span>(node.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//처음에는 여기에 놨었다. 그래서 node.getNext의 또 다음 getNext를 가져오는 격이 되어버렸음. </span></span><br><span class="line"><span class="comment">//그래서 잠재적인 버그를 유발 시켰었다. 이러면 낙제점이다. 디버깅을 했는데.. 왜 감지를 못했던가... </span></span><br><span class="line"><span class="comment">//node = node.getNext();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//탐색된 노드의 다음 노드의 데이터가 일치할경우</span></span><br><span class="line">                <span class="keyword">if</span>(node.getNext().getData() == target) &#123;</span><br><span class="line">                    node.setNext(node.getNext().getNext());</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node = node.getNext();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>SingleLinkedList 수행</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> single = <span class="keyword">new</span> SingleLinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        single.addNode(<span class="string">&quot;sim&quot;</span>);</span><br><span class="line">        single.addNode(<span class="string">&quot;ji&quot;</span>);</span><br><span class="line">        single.addNode(<span class="string">&quot;sung&quot;</span>);</span><br><span class="line"></span><br><span class="line">        single.addNodeInside(<span class="string">&quot;a.k.a&quot;</span>, <span class="string">&quot;sim&quot;</span>);</span><br><span class="line">        single.addNodeInside(<span class="string">&quot;dawn&quot;</span>,<span class="string">&quot;a.k.a&quot;</span>);</span><br><span class="line">        single.addNodeInside(<span class="string">&quot;s&quot;</span>,<span class="string">&quot;sss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(single.deleteNode(<span class="string">&quot;ji&quot;</span>));</span><br><span class="line">        System.out.println(single.deleteNode(<span class="string">&quot;s&quot;</span>));</span><br><span class="line">        System.out.println(single.deleteNode(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        single.printNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linkedlist-링크드리스트&quot;&gt;&lt;a href=&quot;#linkedlist-링크드리스트&quot; class=&quot;headerlink&quot; title=&quot;linkedlist (링크드리스트)&quot;&gt;&lt;/a&gt;linkedlist (링크드리스트)&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="코딩테스트369" scheme="https://codexdawn.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8369/"/>
    
    <category term="datasturct" scheme="https://codexdawn.github.io/categories/datasturct/"/>
    
    <category term="자료구조" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
    <category term="Java" scheme="https://codexdawn.github.io/tags/Java/"/>
    
    <category term="datasturct" scheme="https://codexdawn.github.io/tags/datasturct/"/>
    
    <category term="코딩테스트369" scheme="https://codexdawn.github.io/tags/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8369/"/>
    
    <category term="linkedlist" scheme="https://codexdawn.github.io/tags/linkedlist/"/>
    
  </entry>
  
  <entry>
    <title>coding-test-study-1</title>
    <link href="https://codexdawn.github.io/2021/05/13/coding-test-study-1/"/>
    <id>https://codexdawn.github.io/2021/05/13/coding-test-study-1/</id>
    <published>2021-05-13T14:05:38.000Z</published>
    <updated>2021-05-15T09:27:24.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Queue-큐-Stack-스택"><a href="#Queue-큐-Stack-스택" class="headerlink" title="Queue (큐) / Stack (스택)"></a>Queue (큐) / Stack (스택)</h1><h2 id="1-Queue-구조"><a href="#1-Queue-구조" class="headerlink" title="1. Queue 구조"></a>1. Queue 구조</h2><ul><li>FIFO (First-In First-Out) 처음들어간 element가 처음으로 빠져나감. </li><li>소위, 줄서는 행위와 유사함. </li></ul><h3 id="자바에서-Queue-객체-사용하기"><a href="#자바에서-Queue-객체-사용하기" class="headerlink" title="자바에서 Queue 객체 사용하기"></a>자바에서 Queue 객체 사용하기</h3><ul><li>JAVA 에서는 기본적으로 java.util 패키지에 Queue 클래스를 제공하고 있음<ul><li>Enqueue 에 해당하는 기능으로 Queue 클래스에서는 add(value) 또는 offer(value) 메서드를 제공함</li><li>Dequeue 에 해당하는 기능으로 Queue 클래스에서는 poll() 또는 remove() 메서드를 제공함<ul><li>아쉽게도, Queue 클래스에 데이터 생성을 위해서는 java.util 패키지에 있는 LinkedList 클래스를 사용해야 함</li><li>LinkedList 클래스는 자료구조의 링크드리스트 와 연관이 있으며, 관련 내용은 큐보다 복잡하므로 이후 챕터에서 상세히 익히도록 함</li></ul></li></ul></li></ul><figure class="highlight java"><figcaption><span>java.util.Queue 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue 사용을 위해, LinkedList 클래스를 사용하므로, 두 클래스 모두 import 해야 함</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"><span class="keyword">import</span> java.util.Queue; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 자료형 매개변수를 넣어서, 큐에 들어갈 데이터의 타입을 지정해야 함</span></span><br><span class="line">Queue&lt;Integer&gt; queue_int = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); <span class="comment">// Integer 형 queue 선언</span></span><br><span class="line">Queue&lt;String&gt; queue_str = <span class="keyword">new</span> LinkedList&lt;String&gt;(); <span class="comment">// String 형 queue 선언</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 추가는 add(value) 또는 offer(value) 를 사용함</span></span><br><span class="line">queue_int.add(<span class="number">1</span>);</span><br><span class="line">queue_int.offer(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 은 큐의 첫 번째 값 반환, 해당 값은 큐에서 삭제</span></span><br><span class="line">queue_int.poll();</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 과 마찬가지로, 첫 번째 값 반환하고, 해당 값은 큐에서 삭제</span></span><br><span class="line">queue_int.remove();</span><br></pre></td></tr></table></figure><h3 id="참고-어디에-큐가-많이-쓰일까"><a href="#참고-어디에-큐가-많이-쓰일까" class="headerlink" title="참고: 어디에 큐가 많이 쓰일까?"></a>참고: 어디에 큐가 많이 쓰일까?</h3><ul><li>멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨 (운영체제 참조)</li></ul><blockquote><p>큐의 경우에는 장단점 보다는 (특별히 언급되는 장단점이 없음), 큐의 활용 예로 프로세스 스케쥴링 방식을 함께 이해해두는 것이 좋음</p></blockquote><h3 id="1-2-Queue구현-ArrayList-활용"><a href="#1-2-Queue구현-ArrayList-활용" class="headerlink" title="1-2. Queue구현 (ArrayList 활용)"></a>1-2. Queue구현 (ArrayList 활용)</h3><figure class="highlight java"><figcaption><span>queue구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//enqueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">enqueue</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        queue.add(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dequeue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T data = queue.get(<span class="number">0</span>);</span><br><span class="line">        queue.remove(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCurrentQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">        queue.stream().forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Queue수행</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q1 = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q1.enqueue(<span class="string">&quot;sim&quot;</span>);</span><br><span class="line">        q1.enqueue(<span class="string">&quot;ji&quot;</span>);</span><br><span class="line">        q1.enqueue(<span class="string">&quot;sung&quot;</span>);</span><br><span class="line"></span><br><span class="line">        q1.printCurrentQueue();</span><br><span class="line"></span><br><span class="line">        q1.dequeue();</span><br><span class="line"></span><br><span class="line">        q1.printCurrentQueue();</span><br><span class="line"></span><br><span class="line">        q1.dequeue();</span><br><span class="line"></span><br><span class="line">        q1.printCurrentQueue();</span><br><span class="line"></span><br><span class="line">        q1.dequeue();</span><br><span class="line"></span><br><span class="line">        q1.printCurrentQueue();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;q1.dequeue() = &quot;</span> + q1.dequeue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Stack-구조"><a href="#2-Stack-구조" class="headerlink" title="2. Stack 구조"></a>2. Stack 구조</h2><ul><li>Stack은 LIFO(Last In First Out) 나중에 입력된 element가 가장 먼저 빠지는 구조 </li><li>컴퓨터 내부의 프로세스 구조의 함수 동작 방식(OS의 프로세스 동작 방식)</li></ul><h3 id="2-1-자료-구조-스택의-장단점"><a href="#2-1-자료-구조-스택의-장단점" class="headerlink" title="2-1. 자료 구조 스택의 장단점"></a>2-1. 자료 구조 스택의 장단점</h3><ul><li>장점<ul><li>구조가 단순해서, 구현이 쉽다.</li><li>데이터 저장/읽기 속도가 빠르다.</li></ul></li><li>단점 (일반적인 스택 구현시) <ul><li>데이터 최대 갯수를 미리 정해야 한다. </li><li>저장 공간의 낭비가 발생할 수 있음<ul><li>미리 최대 갯수만큼 저장 공간을 확보해야 함</li></ul></li></ul></li></ul><blockquote><p>스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적임.<br>이 경우, 위에서 열거한 단점이 있을 수 있음</p></blockquote><h3 id="2-2-Stack-구현-ArrayList-사용"><a href="#2-2-Stack-구현-ArrayList-사용" class="headerlink" title="2-2. Stack 구현 (ArrayList 사용)"></a>2-2. Stack 구현 (ArrayList 사용)</h3><figure class="highlight java"><figcaption><span>Stack클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">push</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        stack.add(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = stack.get(stack.size() - <span class="number">1</span>);</span><br><span class="line">        stack.remove(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        stack.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Stack수행</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1L</span>);</span><br><span class="line">        stack.push(<span class="number">2L</span>);</span><br><span class="line">        stack.push(<span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line">        stack.print();</span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line"></span><br><span class="line">        stack.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;\</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Queue-큐-Stack-스택&quot;&gt;&lt;a href=&quot;#Queue-큐-Stack-스택&quot; class=&quot;headerlink&quot; title=&quot;Queue (큐) / Stack (스택)&quot;&gt;&lt;/a&gt;Queue (큐) / Stack (스택)&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="코딩테스트369" scheme="https://codexdawn.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8369/"/>
    
    <category term="datasturct" scheme="https://codexdawn.github.io/categories/datasturct/"/>
    
    <category term="자료구조" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
    <category term="Java" scheme="https://codexdawn.github.io/tags/Java/"/>
    
    <category term="datasturct" scheme="https://codexdawn.github.io/tags/datasturct/"/>
    
    <category term="코딩테스트369" scheme="https://codexdawn.github.io/tags/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8369/"/>
    
    <category term="Queue" scheme="https://codexdawn.github.io/tags/Queue/"/>
    
    <category term="Stack" scheme="https://codexdawn.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>coding-test-study-0</title>
    <link href="https://codexdawn.github.io/2021/05/13/coding-test-study-0/"/>
    <id>https://codexdawn.github.io/2021/05/13/coding-test-study-0/</id>
    <published>2021-05-13T13:45:02.000Z</published>
    <updated>2021-05-13T14:04:48.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="코딩테스트-369-사전-세팅"><a href="#코딩테스트-369-사전-세팅" class="headerlink" title="코딩테스트 369 : 사전 세팅"></a>코딩테스트 369 : 사전 세팅</h1><h2 id="1-주피터-노트북-설치-및-수행방법-로컬설치"><a href="#1-주피터-노트북-설치-및-수행방법-로컬설치" class="headerlink" title="1. 주피터 노트북 설치 및 수행방법 (로컬설치)"></a>1. 주피터 노트북 설치 및 수행방법 (로컬설치)</h2><p><img src="/images/coding369/0513-1.png" alt="아나콘다 사이트 설치 화면"></p><p><a href="https://www.anaconda.com/products/individual">아나콘다 개인판 설치 URL</a></p><p>해당 부분 설치하고 나서 아나콘다 수행후 주피터 노트북 실행하면 끝! </p><h2 id="2-JAVA-호환-적용-방법"><a href="#2-JAVA-호환-적용-방법" class="headerlink" title="2. JAVA 호환 적용 방법"></a>2. JAVA 호환 적용 방법</h2><p>IJava 모듈을 다운받은뒤, 해당 폴더에 들어있는, java폴더와 install.py를 해당 강의자료에 복사 혹은 이동 시키기! </p><p><a href="https://github.com/SpencerPark/IJava/releases">IJava설치모듈다운로드</a></p><p><img src="/images/coding369/0513-1.png" alt="설치후 IJava 모듈 복사후 화면"></p><p>IJava모듈을 복사 이동 시킨뒤, </p><p>!python install.py –sys-prefix</p><p>위 명령어 수행시킨다. (주피터 노트북에서 수행해도 됨!)</p><p>수행시키고난뒤, 주피터노트북 및 아나콘다 재시작하면 JAVA호환 부분 완료! </p><h2 id="3-사용방법"><a href="#3-사용방법" class="headerlink" title="3. 사용방법"></a>3. 사용방법</h2><ul><li>기본적으로 MarkDown 사용가능 </li><li>신기한건 코드를 넣으면 실행결과를 실시간으로 확인 가능함. </li></ul><p><img src="/images/coding369/0513-1.png" alt="코드 적용 화면"></p><ul><li>위 화면에서 해당 코드블록 선택한뒤 Shift + Enter 하면 수행됨. 단, 순차적으로 관련코드들을 수행해줘야 결과값을 출력할수있음. </li><li>화면에서 왼쪽에 파란색 상태에서 A/B 키보드 클릭시 추가적인 코드블록이나 MD 를 타이핑할수있다. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;코딩테스트-369-사전-세팅&quot;&gt;&lt;a href=&quot;#코딩테스트-369-사전-세팅&quot; class=&quot;headerlink&quot; title=&quot;코딩테스트 369 : 사전 세팅&quot;&gt;&lt;/a&gt;코딩테스트 369 : 사전 세팅&lt;/h1&gt;&lt;h2 id=&quot;1-주피터-노트북</summary>
      
    
    
    
    <category term="코딩테스트369" scheme="https://codexdawn.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8369/"/>
    
    <category term="datasturct" scheme="https://codexdawn.github.io/categories/datasturct/"/>
    
    <category term="자료구조" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
    <category term="Java" scheme="https://codexdawn.github.io/tags/Java/"/>
    
    <category term="datasturct" scheme="https://codexdawn.github.io/tags/datasturct/"/>
    
    <category term="코딩테스트369사전작업" scheme="https://codexdawn.github.io/tags/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8369%EC%82%AC%EC%A0%84%EC%9E%91%EC%97%85/"/>
    
  </entry>
  
  <entry>
    <title>mapstruct-2</title>
    <link href="https://codexdawn.github.io/2021/05/12/mapstruct-2/"/>
    <id>https://codexdawn.github.io/2021/05/12/mapstruct-2/</id>
    <published>2021-05-12T01:27:36.000Z</published>
    <updated>2021-05-12T01:55:38.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mapstruct-삽질기2-활용편-custom-mapping-사용방법"><a href="#Mapstruct-삽질기2-활용편-custom-mapping-사용방법" class="headerlink" title="Mapstruct 삽질기2 : 활용편 (custom mapping 사용방법)"></a>Mapstruct 삽질기2 : 활용편 (custom mapping 사용방법)</h1><h2 id="1-적용했는데-문제-발생-문제가-뭐야"><a href="#1-적용했는데-문제-발생-문제가-뭐야" class="headerlink" title="1. 적용했는데 문제 발생! 문제가 뭐야?"></a>1. 적용했는데 문제 발생! 문제가 뭐야?</h2><p>사건의 발단은 이렇다. 직장동료가 내가 전파한 MapStruct를 가지고 적용을 했는데, lombok을 같이 사용하다보니, isUse라는 Entity에서 useYn으로 변환을 시켜줘야하는 이슈가 있었다. 결국 boolean -&gt; String 으로 변환을 시켜줘야 하는데, 잘 안되었던것이다. 그리고 lombok에서 접두어에 is- 를 붙이면 네이밍이슈가 발생하여서, 이부분도 골칫거리였다. lombok에서 boolean타입일땐.. 가급적 is-접두어 붙이지말자..-_-; 여러가지로 상당히 피곤해짐….</p><h2 id="2-해결방법"><a href="#2-해결방법" class="headerlink" title="2. 해결방법"></a>2. 해결방법</h2><p>해결방법은 직장동료분께서 적용한 방식과 내가 적용한 방식 두가지 방식으로 해결할수있었다. </p><h3 id="2-1-해결방법1-Named로-정의하기해서-사용하기"><a href="#2-1-해결방법1-Named로-정의하기해서-사용하기" class="headerlink" title="2-1. 해결방법1 : @Named로 정의하기해서 사용하기!"></a>2-1. 해결방법1 : @Named로 정의하기해서 사용하기!</h3><figure class="highlight java"><figcaption><span>named사용방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.cms.api.utils.mapstruct.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.cms.api.dto.app.AppExaminationDto;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.cms.domain.repository.jpa.vcontent.app.entity.AppExaminationEntity;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.cms.domain.utils.mapstruct.GenericMapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper(componentModel=&quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppExaminationMapper</span> <span class="keyword">extends</span> <span class="title">GenericMapper</span>&lt;<span class="title">AppExaminationDto</span>, <span class="title">AppExaminationEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;use&quot;, target = &quot;useYn&quot;, qualifiedByName = &quot;booleanToYN&quot;)</span></span><br><span class="line">    <span class="function">AppExaminationDto <span class="title">toDto</span><span class="params">(AppExaminationEntity appExaminationEntity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Named(&quot;booleanToYN&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">booleanToYN</span><span class="params">(<span class="keyword">boolean</span> bool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bool ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@Named로 일종의 custom mapper를 만들어서 사용 (qualifiedByName 으로 해당 메서드 주입? 연결 시킴)</li><li>interface의 default메서드를 활용해서 구현체에 영향주지 않도록 걸어둠 </li><li>isUse로 사용했던 부분은 mapping시 use로 변경해서 매핑 (lombok이슈인듯)</li><li>단일 매퍼 적용시 기대효과 괜춘할듯. </li></ol><h3 id="2-2-해결방법2-uses로-매핑하여-사용하기"><a href="#2-2-해결방법2-uses로-매핑하여-사용하기" class="headerlink" title="2-2. 해결방법2 : uses로 매핑하여 사용하기!"></a>2-2. 해결방법2 : uses로 매핑하여 사용하기!</h3><figure class="highlight java"><figcaption><span>booleanMapper생성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.cms.api.utils.mapstruct.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.cms.api.dto.app.AppExaminationDto;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.cms.domain.repository.jpa.vcontent.app.entity.AppExaminationEntity;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.cms.domain.utils.mapstruct.GenericMapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper(uses = BooleanYNMapper.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppExaminationMapper</span> <span class="keyword">extends</span> <span class="title">GenericMapper</span>&lt;<span class="title">AppExaminationDto</span>, <span class="title">AppExaminationEntity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Mapping(source = &quot;use&quot;, target = &quot;useYn&quot;)</span></span><br><span class="line">    <span class="function">AppExaminationDto <span class="title">toDto</span><span class="params">(AppExaminationEntity appExaminationEntity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wemakeprice.v.cms.api.utils.mapstruct.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanYNMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">asString</span><span class="params">(Boolean use)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == use ?</span><br><span class="line">            <span class="keyword">null</span> : (use ?</span><br><span class="line">            <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>componentModel=”spring” 제거 (이렇게 걸고 BooleanYNMapper생성하니 nullpointer발생)</li><li>uses는 여러개 mapper를 적용할수있다. 따라서 생성된 custom mapper들은 공통 로직으로 활용가능함. (해결방법1은 그 mapper만 적용할때 사용 하면 될듯)</li><li>isUse로 사용했던 부분은 mapping시 use로 변경해서 매핑 (lombok이슈인듯)</li></ol><p><a href="https://stackoverflow.com/questions/54610680/mapstruct-mapping-boolean-to-string">참고1. 스택오버플로우 질문</a><br><a href="https://mapstruct.org/documentation/stable/reference/html/#invoking-other-mappers">참고2. 공식사이트 내용</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mapstruct-삽질기2-활용편-custom-mapping-사용방법&quot;&gt;&lt;a href=&quot;#Mapstruct-삽질기2-활용편-custom-mapping-사용방법&quot; class=&quot;headerlink&quot; title=&quot;Mapstruct 삽질기2 :</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="Mapstruct" scheme="https://codexdawn.github.io/categories/Mapstruct/"/>
    
    
    <category term="Java,JPA,Spring" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring/"/>
    
    <category term="Mapstruct" scheme="https://codexdawn.github.io/tags/Mapstruct/"/>
    
  </entry>
  
  <entry>
    <title>mapstruct-1</title>
    <link href="https://codexdawn.github.io/2021/05/10/mapstruct-1/"/>
    <id>https://codexdawn.github.io/2021/05/10/mapstruct-1/</id>
    <published>2021-05-10T03:18:01.000Z</published>
    <updated>2021-05-12T01:50:52.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mapstruct-삽질기-기본편"><a href="#Mapstruct-삽질기-기본편" class="headerlink" title="Mapstruct 삽질기 : 기본편"></a>Mapstruct 삽질기 : 기본편</h1><h2 id="1-Mapstruct란"><a href="#1-Mapstruct란" class="headerlink" title="1. Mapstruct란?"></a>1. Mapstruct란?</h2><p><a href="https://mapstruct.org/">Mapstruct 공식사이트</a></p><p>MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.<br>자바빈즈기반의 객체를 간단한 컨벤션 설정을 통해 매핑시켜주는 역할을 담당한다고 생각하면 됨. 그냥 ModelMapper와 유사한 기능을 한다고 생각하면 됨. (그렇다고 둘이 매커니즘이 같은건 아님. )</p><hr><h2 id="2-왜-사용함"><a href="#2-왜-사용함" class="headerlink" title="2. 왜 사용함?"></a>2. 왜 사용함?</h2><p>Multi-layered applications often require to map between different object models (e.g. entities and DTOs). Writing such mapping code is a tedious and error-prone task. MapStruct aims at simplifying this work by automating it as much as possible.<br>In contrast to other mapping frameworks MapStruct generates bean mappings at compile-time which ensures a high performance, allows for fast developer feedback and thorough error checking.</p><p>Multi-layered (멀티모듈 프로젝트 같은것?)은 다른 객체 모델에 대해서 매핑시켜줘야하는 일들이 많다. 예를들어서 Entity를 DTO로. 기존 노가다성 메핑할떄는 세레머니 코드들이 많이 들어가있고(map,mapToList..) 에러를 유발시킬수있는 코드로 실수할수있는데, MapStruct는 이런 부분을 자동으로 간단스하게 처리 해줌.<br>다른 매핑프레임워크에 비해서 MapStruct는 컴파일 시점에 mapping 코드를 생성하기때문에 성능적으로 안정적인 부분과 컴파일시점에 에러를 잡아낼수있어서, 개발자의 실수를 줄일수있음. (modelmapper는 runtime시점에 mapping하기때문에 생성비용이 꽤나큼 뭐 Bean Scope가 singleton이라 한번 컨테이너 올리면.. 그닥 큰 이슈가 아닐란가싶긴하지만..runtime과 compile시점은 엄청난 차이가 있음. compile시점이 사실 안정적으로 실수나 에러검증을 해주기가 아주 유리함!)</p><hr><h2 id="3-설정"><a href="#3-설정" class="headerlink" title="3. 설정"></a>3. 설정</h2><h3 id="3-1-build-gradle"><a href="#3-1-build-gradle" class="headerlink" title="3-1. build.gradle"></a>3-1. build.gradle</h3><p>설정위해서는 lombok 의존성을 추가한 root 프로젝트쪽 build.gradle쪽에 추가해줘야함. 중요한 부분은 lombok을 사용하면 의존성 추가할때 위치나 버전에 따라 설정이 달라질수있음. </p><figure class="highlight plain"><figcaption><span>root-build.gradle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">        implementation &#39;org.mapstruct:mapstruct:1.4.1.Final&#39;</span><br><span class="line">        compileOnly &#39;org.projectlombok:lombok&#39;</span><br><span class="line">        compile group: &#39;org.projectlombok&#39;, name: &#39;lombok-mapstruct-binding&#39;, version: &#39;0.2.0&#39;</span><br><span class="line">        annotationProcessor &#39;org.springframework.boot:spring-boot-configuration-processor&#39;</span><br><span class="line">        annotationProcessor &#39;org.projectlombok:lombok&#39;</span><br><span class="line">        annotationProcessor &#39;org.mapstruct:mapstruct-processor:1.4.1.Final&#39;</span><br><span class="line"></span><br><span class="line">        testImplementation(&#39;org.springframework.boot:spring-boot-starter-test&#39;) &#123;</span><br><span class="line">            exclude group: &#39;org.junit.vintage&#39;, module: &#39;junit-vintage-engine&#39;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; jackson</span><br><span class="line">        implementation(&#39;com.fasterxml.jackson.core:jackson-databind&#39;)</span><br><span class="line">        implementation(&#39;com.google.code.gson:gson:2.8.0&#39;)</span><br><span class="line">        implementation(&#39;com.google.guava:guava:28.0-jre&#39;)</span><br><span class="line">        implementation(&#39;commons-codec:commons-codec&#39;)</span><br><span class="line">        implementation(&#39;org.apache.commons:commons-lang3:3.9&#39;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; jsr validation</span><br><span class="line">        implementation(&#39;javax.validation:validation-api:2.0.1.Final&#39;)</span><br><span class="line"></span><br><span class="line">        testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;</span><br><span class="line">        testImplementation(&#39;org.easytesting:fest-assert:1.4&#39;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-GenericMapper"><a href="#3-2-GenericMapper" class="headerlink" title="3-2. GenericMapper"></a>3-2. GenericMapper</h3><p>사실 굳이 안만들어도 되긴하는데, 한벌 만들어놓으면 공통로직으로 사용하기 용이함 </p><figure class="highlight java"><figcaption><span>api-GenericMapper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wemakeprice.v.ocs.api.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mapstruct.NullValuePropertyMappingStrategy.IGNORE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mapstruct.BeanMapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.MappingTarget;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericMapper</span>&lt;<span class="title">D</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">toDto</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">toEntity</span><span class="params">(D d)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeanMapping(nullValuePropertyMappingStrategy = IGNORE)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFromDto</span><span class="params">(D dto, <span class="meta">@MappingTarget</span> E entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="4-사용방법"><a href="#4-사용방법" class="headerlink" title="4. 사용방법"></a>4. 사용방법</h2><p>사용 예시는 mapToList 의 예시이다. 하지만 기존 modelMapper에서 처리하는 부분도 @Mapper내에서 가능한것으로 파악되어짐. </p><figure class="highlight java"><figcaption><span>entity to dto 사용방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wemakeprice.v.ocs.api.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.api.dto.order.PurchaseInfo;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.domain.repository.escrow.order.Purchase;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PurchaseMapper</span> <span class="keyword">extends</span> <span class="title">GenericMapper</span>&lt;<span class="title">PurchaseInfo</span>, <span class="title">Purchase</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;PurchaseInfo&gt; <span class="title">getPurchaseInfo</span><span class="params">(List&lt;Purchase&gt; purchaseEntity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>실사용소스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.ocs.api.service.purchase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.api.dto.order.PurchaseInfo;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.api.dto.order.PurchaseRequestParam;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.api.mapper.PurchaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.domain.provider.order.PurchaseProvider;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.domain.utils.ModelMapperUtils;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.meta.order.OrderType;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.factory.Mappers;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PurchaseProvider purchaseProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PurchaseMapper purchaseMapper = Mappers.getMapper(PurchaseMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PurchaseInfo&gt; <span class="title">getPurchaseInfo</span><span class="params">(PurchaseRequestParam param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return ModelMapperUtils.mapToList(purchaseProvider.findByOrderTypeAndMid(param.getOrderType(),param.getMid()),PurchaseInfo.class);</span></span><br><span class="line">        <span class="keyword">return</span> purchaseMapper.getPurchaseInfo(purchaseProvider.findByOrderTypeAndMid(param.getOrderType(),param.getMid()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PurchaseInfo&gt; <span class="title">getPurchaseInfoByOrderType</span><span class="params">(OrderType orderType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return ModelMapperUtils.mapToList(purchaseProvider.findByOrderTypeEquals(orderType),PurchaseInfo.class);</span></span><br><span class="line">        <span class="keyword">return</span> purchaseMapper.getPurchaseInfo(purchaseProvider.findByOrderTypeEquals(orderType));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>purchaseInfoImpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wemakeprice.v.ocs.api.mapper;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.api.dto.order.PurchaseInfo;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.domain.repository.escrow.order.Purchase;</span><br><span class="line"><span class="keyword">import</span> com.wemakeprice.v.ocs.meta.order.OrderType;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Generated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Generated(</span></span><br><span class="line"><span class="meta">    value = &quot;org.mapstruct.ap.MappingProcessor&quot;,</span></span><br><span class="line"><span class="meta">    date = &quot;2021-05-10T12:03:46+0900&quot;,</span></span><br><span class="line"><span class="meta">    comments = &quot;version: 1.4.1.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-6.8.3.jar, environment: Java 1.8.0_181 (Oracle Corporation)&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseMapperImpl</span> <span class="keyword">implements</span> <span class="title">PurchaseMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PurchaseInfo <span class="title">toDto</span><span class="params">(Purchase e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( e == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        PurchaseInfo purchaseInfo = <span class="keyword">new</span> PurchaseInfo();</span><br><span class="line"> </span><br><span class="line">        purchaseInfo.setPurchaseNo( e.getPurchaseNo() );</span><br><span class="line">        <span class="keyword">if</span> ( e.getOrderType() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            purchaseInfo.setOrderType( e.getOrderType().name() );</span><br><span class="line">        &#125;</span><br><span class="line">        purchaseInfo.setTotProdPrice( e.getTotProdPrice() );</span><br><span class="line">        purchaseInfo.setTotShipPrice( e.getTotShipPrice() );</span><br><span class="line">        purchaseInfo.setBuyerNm( e.getBuyerNm() );</span><br><span class="line">        purchaseInfo.setBuyerPhone( e.getBuyerPhone() );</span><br><span class="line">        purchaseInfo.setMid( e.getMid() );</span><br><span class="line">        purchaseInfo.setRegDt( e.getRegDt() );</span><br><span class="line">        purchaseInfo.setChgDt( e.getChgDt() );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> purchaseInfo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Purchase <span class="title">toEntity</span><span class="params">(PurchaseInfo d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( d == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Purchase purchase = <span class="keyword">new</span> Purchase();</span><br><span class="line"> </span><br><span class="line">        purchase.setPurchaseNo( d.getPurchaseNo() );</span><br><span class="line">        <span class="keyword">if</span> ( d.getOrderType() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            purchase.setOrderType( Enum.valueOf( OrderType.class, d.getOrderType() ) );</span><br><span class="line">        &#125;</span><br><span class="line">        purchase.setTotProdPrice( d.getTotProdPrice() );</span><br><span class="line">        purchase.setTotShipPrice( d.getTotShipPrice() );</span><br><span class="line">        purchase.setBuyerNm( d.getBuyerNm() );</span><br><span class="line">        purchase.setBuyerPhone( d.getBuyerPhone() );</span><br><span class="line">        purchase.setMid( d.getMid() );</span><br><span class="line">        purchase.setRegDt( d.getRegDt() );</span><br><span class="line">        purchase.setChgDt( d.getChgDt() );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> purchase;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFromDto</span><span class="params">(PurchaseInfo dto, Purchase entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dto == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( dto.getPurchaseNo() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setPurchaseNo( dto.getPurchaseNo() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( dto.getOrderType() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setOrderType( Enum.valueOf( OrderType.class, dto.getOrderType() ) );</span><br><span class="line">        &#125;</span><br><span class="line">        entity.setTotProdPrice( dto.getTotProdPrice() );</span><br><span class="line">        entity.setTotShipPrice( dto.getTotShipPrice() );</span><br><span class="line">        <span class="keyword">if</span> ( dto.getBuyerNm() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setBuyerNm( dto.getBuyerNm() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( dto.getBuyerPhone() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setBuyerPhone( dto.getBuyerPhone() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( dto.getMid() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setMid( dto.getMid() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( dto.getRegDt() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setRegDt( dto.getRegDt() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( dto.getChgDt() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            entity.setChgDt( dto.getChgDt() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PurchaseInfo&gt; <span class="title">getPurchaseInfo</span><span class="params">(List&lt;Purchase&gt; purchaseEntity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( purchaseEntity == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        List&lt;PurchaseInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;PurchaseInfo&gt;( purchaseEntity.size() );</span><br><span class="line">        <span class="keyword">for</span> ( Purchase purchase : purchaseEntity ) &#123;</span><br><span class="line">            list.add( toDto( purchase ) );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-참고"><a href="#5-참고" class="headerlink" title="5. 참고"></a>5. 참고</h2><ul><li>modelMapper는 runtime시점에 reflection 하기때문에 runtime시에만 발생할수 있는 문제를 야기 시킬수 있음. <ul><li>리플렉션으로 메서드 혹은 클래스에 접근할때 찾지 못하는 이슈가 runtime시에만 발생할수 있기때문에 그것에 대한 예외처리가 반드시 필요하다. </li><li>getMethod나 getClass 사용시 superclass,superinterface의 메서드를 호출하려 하기때문에 컴파일시에 감지하지 못하는 에러가 발생할수도 있음. (SecurityException발생 -&gt; checkPackageAccess() 전처리 필요)</li><li>runtime시점에 변환작업을 수행하기때문에 성능이슈가 발생할수있음. 기존 setter로 하는것이 한번에 세팅된다면, 리플렉션으로 두단계 더 거친뒤에야 세팅하기때문에 대량 처리할때는 비용이 클수가 있음.</li><li>이에반헤 mapStruct는 컴파일시점에 코드를 generate 시켜서 해당 부분의 코드 및 파일이 증가하는 이슈가 있지만 runtime시에 발생할수있는 리플렉션 에러는 방지할수있음. </li><li>결론은 runtime 시점에 리플렉션으로 처리되는 부분들은 가급적 사용하지 말자. 컴파일 시점에서 체크하는것이 가장 안전함.  </li></ul></li></ul><p><a href="https://www.skyer9.pe.kr/wordpress/?p=1596">상구리의 기술 블로그 참고</a><br><a href="https://www.baeldung.com/mapstruct">baeldung-mapstruct 가이드</a><br><a href="https://mapstruct.org/documentation/stable/reference/html/">mapstruct공식사이트</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mapstruct-삽질기-기본편&quot;&gt;&lt;a href=&quot;#Mapstruct-삽질기-기본편&quot; class=&quot;headerlink&quot; title=&quot;Mapstruct 삽질기 : 기본편&quot;&gt;&lt;/a&gt;Mapstruct 삽질기 : 기본편&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="Mapstruct" scheme="https://codexdawn.github.io/categories/Mapstruct/"/>
    
    
    <category term="Java,JPA,Spring" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring/"/>
    
    <category term="Mapstruct" scheme="https://codexdawn.github.io/tags/Mapstruct/"/>
    
  </entry>
  
  <entry>
    <title>java8-chaptor2</title>
    <link href="https://codexdawn.github.io/2021/05/08/java8-chaptor2/"/>
    <id>https://codexdawn.github.io/2021/05/08/java8-chaptor2/</id>
    <published>2021-05-08T08:18:24.000Z</published>
    <updated>2021-05-10T05:04:02.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2-동작파라미터화-코드-전달하기"><a href="#Chapter-2-동작파라미터화-코드-전달하기" class="headerlink" title="Chapter 2. 동작파라미터화 코드 전달하기"></a>Chapter 2. 동작파라미터화 코드 전달하기</h1><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p><a href="#1.%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EC%97%90-%EB%8C%80%EC%9D%91">1.변화하는 요구사항에 대응</a><br><a href="#2.%EB%8F%99%EC%9E%91%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%ED%99%94">2.동작파라미터화</a><br><a href="#3.%EC%9D%B5%EB%AA%85%ED%81%B4%EB%9E%98%EC%8A%A4">3.익명클래스</a><br><a href="#4.%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0">4.람다 표현식 미리보기</a><br><a href="#5.%EC%8B%A4%EC%A0%84%EC%98%88%EC%A0%9C:-Comparator,Runnable,GUI">5.실전예제: Comparator,Runnable,GUI</a></p><hr><h2 id="1-변화하는-요구사항에-대응"><a href="#1-변화하는-요구사항에-대응" class="headerlink" title="1.변화하는 요구사항에 대응"></a>1.변화하는 요구사항에 대응</h2><ul><li>우리가 어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀐다. 변화하는 요구사항은 소프트웨어 엔지니어링에서 피할수 없는 문제다. </li><li>동작 파라미터화(behavior parameterization) 을 활용하면 자주 바뀌는 요구사항에 효과적으로 대응 할수 있다. </li><li>동작 파라미터란? 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미함. 이 코드 블록은 나중에 프로그램에서 호출한다. 즉, 코드블록의 실행은 나중으로 미뤄진다. </li></ul><h3 id="1-1-첫번째시도-녹색사과-필터링"><a href="#1-1-첫번째시도-녹색사과-필터링" class="headerlink" title="1-1. 첫번째시도:녹색사과 필터링"></a>1-1. 첫번째시도:녹색사과 필터링</h3><figure class="highlight java"><figcaption><span>filterGreenApples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">(List&lt;Apple&gt; inventory)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();                          <span class="number">1.</span>사과 누적리스트</span><br><span class="line">    <span class="keyword">for</span>(Apple apple: inventory)&#123;</span><br><span class="line">        <span class="keyword">if</span>( GREEN.equals(apple.getColor() ) &#123;                        <span class="number">2.</span>녹색사과 필터 </span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-두번째시도-색을-파라미터화"><a href="#1-2-두번째시도-색을-파라미터화" class="headerlink" title="1-2. 두번째시도:색을 파라미터화"></a>1-2. 두번째시도:색을 파라미터화</h4><figure class="highlight java"><figcaption><span>filterGreenApples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApplesByColor</span><span class="params">(List&lt;Apple&gt; inventory,</span></span></span><br><span class="line"><span class="function"><span class="params">Color color)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple: inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( apple.getColor().equals(color) ) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; greenApples = filterApplesByColor(inventory, GREEN);</span><br><span class="line">List&lt;Apple&gt; redApples = filterApplesByColor(inventory, RED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 농부의 다양한 요구사항을 들어보니 색과 마찬가지로 앞으로 무게의 기준도 얼마든지 바뀔수있다는걸 알게됫음.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApplesByWeight</span><span class="params">(List&lt;Apple&gt; inventory,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    For (Apple apple: inventory)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( apple.getWeight() &gt; weight ) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주로 내가 현업에서 개발하던 스타일이며 자주 보던 스타일이다. 코드 자체가 저렇게 필터링 되는 조건만 달라지고 나머지는 거의 동일한 로직으로 처리되는 로직들을 종종 볼수있었다. 그렇다보니 최악의 코드이며 가장 더러운 방식까지 내려가던일도 진짜 가끔있었다. 세번째 시도를 한번 보자.</p><h4 id="1-3-세번째-시도-가능한-모든-속성으로-필터링"><a href="#1-3-세번째-시도-가능한-모든-속성으로-필터링" class="headerlink" title="1-3. 세번째 시도: 가능한 모든 속성으로 필터링"></a>1-3. 세번째 시도: 가능한 모든 속성으로 필터링</h4><figure class="highlight java"><figcaption><span>filterApples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory, Color color,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> weight, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple: inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (flag &amp;&amp; apple.getColor().equals(color)) ||</span><br><span class="line">             (!flag &amp;&amp; apple.getWeight() &gt; weight) )&#123;          <span class="number">1.</span> 정말 더럽다. 코드가..-_-; flag의 용도는 대체 뭐임? </span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 보자하니, 정말 답이없다. 우선 flag의 용도는 뭘까? 하나의 공통 코드로 만들어보려다가 오히려 똥 만들어놨다. 부끄럽지만 나도 저렇게 짜려고 했던적이 있던것 같다. 이제부터 동작 파라미터화를 하는 방법에 대해서 확인해보자! </p><hr><h2 id="2-동작파라미터화"><a href="#2-동작파라미터화" class="headerlink" title="2.동작파라미터화"></a>2.동작파라미터화</h2><h3 id="2-1-네번째시도-추상적조건으로-필터링"><a href="#2-1-네번째시도-추상적조건으로-필터링" class="headerlink" title="2-1. 네번째시도: 추상적조건으로 필터링"></a>2-1. 네번째시도: 추상적조건으로 필터링</h3><figure class="highlight java"><figcaption><span>predicate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span> <span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;   <span class="number">1.</span> 무게 <span class="number">150</span>이상</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;    <span class="number">2.</span> 녹색사과만 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GREEN.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleRedAndHeavyPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RED.equals(apple.getColor())</span><br><span class="line">                       &amp;&amp; apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ApplePredicate p)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Apple apple: inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple)) &#123;                       <span class="number">1.</span> predicate객체로 사과 검사 조건 캡슐화</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; redAndHeavyApples =</span><br><span class="line">    filterApples(inventory, <span class="keyword">new</span> AppleRedAndHeavyPredicate());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/java8/java-1.png" alt="사과를 선택하는 다양한 전략"></p><p>위 그림처럼 전략패턴을 활용해서 사과의 필터조건을 결정하도록 개발하게되었다. 이렇게되면 각 구체 클래스에서 정의한 조건을 ApplePredicate 에 파라미터화 시키면 된다. 확실히 더러웠던 3번째시도 보다는 아주 스마트하고 깔끔해졌다. 역시 이래서 디자인패턴을 활용해야하나 보다. </p><hr><h2 id="3-익명클래스"><a href="#3-익명클래스" class="headerlink" title="3.익명클래스"></a>3.익명클래스</h2><ul><li>익명 클래스는 자바의 지역클래스(블록 내부에 설정된 클래스)와 비슷한개념이다.</li><li>익명 클래스를 이용하면 클래스 선언과 인스턴스화를 동시에 할 수 있다.</li></ul><h3 id="3-1-다섯번째-시도-익명클래스-사용"><a href="#3-1-다섯번째-시도-익명클래스-사용" class="headerlink" title="3-1. 다섯번째 시도: 익명클래스 사용"></a>3-1. 다섯번째 시도: 익명클래스 사용</h3><figure class="highlight java"><figcaption><span>filterApples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, <span class="keyword">new</span> ApplePredicate() &#123;     <span class="number">1.</span>메서드를 파라미터화 시켰음. </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RED.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 처럼 메서드를 파라미터화 시켜서 익명클래스를 적용은 시켰지만 여전히 빨간사과를 필터링하는 조건이 이외에 코드들이 너무 장황하다. 이런 익명클래스는 람다식을 통해 코드량을 단축시킬수있다. </p><hr><h2 id="4-람다-표현식-미리보기"><a href="#4-람다-표현식-미리보기" class="headerlink" title="4.람다 표현식 미리보기"></a>4.람다 표현식 미리보기</h2><h3 id="4-1-여섯번째-시도-람다-표현식-사용"><a href="#4-1-여섯번째-시도-람다-표현식-사용" class="headerlink" title="4-1. 여섯번째 시도: 람다 표현식 사용"></a>4-1. 여섯번째 시도: 람다 표현식 사용</h3><figure class="highlight java"><figcaption><span>filterApples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">List&lt;Apple&gt; result =</span><br><span class="line">  filterApples(inventory, (Apple apple) -&gt; RED.equals(apple.getColor()));</span><br></pre></td></tr></table></figure><p>이렇게 람다 표현식을 사용하면 코드를 더 심플하게 작성이 가능하다. </p><h3 id="4-2-일곱번째-시도-리스트형식-추상화"><a href="#4-2-일곱번째-시도-리스트형식-추상화" class="headerlink" title="4-2. 일곱번째 시도: 리스트형식 추상화"></a>4-2. 일곱번째 시도: 리스트형식 추상화</h3><figure class="highlight java"><figcaption><span>filterApples:generic</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;     <span class="number">1</span></span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T e: list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(e)) &#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앞으로 이렇게 추상화 시켜서, 공통 모듈로 만드는 습관이 필요하다. 모든 개발할때 저런 추상화를 늘 고려해서 개발하는 경지에 이르렀으면 좋겠다. </p><hr><h2 id="5-실전예제-Comparator-Runnable-GUI"><a href="#5-실전예제-Comparator-Runnable-GUI" class="headerlink" title="5.실전예제: Comparator,Runnable,GUI"></a>5.실전예제: Comparator,Runnable,GUI</h2><h3 id="5-1-Comparator로-정렬하기"><a href="#5-1-Comparator로-정렬하기" class="headerlink" title="5-1. Comparator로 정렬하기"></a>5-1. Comparator로 정렬하기</h3><figure class="highlight java"><figcaption><span>Comparator정렬</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">inventory.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inventory.sort(</span><br><span class="line">  (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="5-2-Runnable"><a href="#5-2-Runnable" class="headerlink" title="5-2. Runnable"></a>5-2. Runnable</h3><figure class="highlight java"><figcaption><span>Runnable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// java.lang.Runnable 인터페이스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//익명클래스 표현</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//람다식표현</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Hello world&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;String&gt; threadName = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; threadName = executorService.submit(</span><br><span class="line">                     () -&gt; Thread.currentThread().getName());</span><br></pre></td></tr></table></figure><h3 id="5-3-GUI-이벤트-처리하기"><a href="#5-3-GUI-이벤트-처리하기" class="headerlink" title="5-3. GUI 이벤트 처리하기"></a>5-3. GUI 이벤트 처리하기</h3><figure class="highlight java"><figcaption><span>GUI</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">Button button = <span class="keyword">new</span> Button(<span class="string">&quot;Send&quot;</span>);</span><br><span class="line">button.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        label.setText(<span class="string">&quot;Sent!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button.setOnAction((ActionEvent event) -&gt; label.setText(<span class="string">&quot;Sent!!&quot;</span>));</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-2-동작파라미터화-코드-전달하기&quot;&gt;&lt;a href=&quot;#Chapter-2-동작파라미터화-코드-전달하기&quot; class=&quot;headerlink&quot; title=&quot;Chapter 2. 동작파라미터화 코드 전달하기&quot;&gt;&lt;/a&gt;Chapter 2.</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Java8InAction" scheme="https://codexdawn.github.io/categories/Java8InAction/"/>
    
    
    <category term="Java8" scheme="https://codexdawn.github.io/tags/Java8/"/>
    
    <category term="behavior parameterization" scheme="https://codexdawn.github.io/tags/behavior-parameterization/"/>
    
    <category term="동작파라미터" scheme="https://codexdawn.github.io/tags/%EB%8F%99%EC%9E%91%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0/"/>
    
  </entry>
  
  <entry>
    <title>jpa-obj-query-2</title>
    <link href="https://codexdawn.github.io/2021/05/08/jpa-obj-query-2/"/>
    <id>https://codexdawn.github.io/2021/05/08/jpa-obj-query-2/</id>
    <published>2021-05-08T02:54:28.000Z</published>
    <updated>2021-05-08T07:20:25.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체지향-쿼리-언어2"><a href="#객체지향-쿼리-언어2" class="headerlink" title="객체지향 쿼리 언어2"></a>객체지향 쿼리 언어2</h1><h2 id="1-경로표현식"><a href="#1-경로표현식" class="headerlink" title="1. 경로표현식"></a>1. 경로표현식</h2><h3 id="1-1-경로표현식이란"><a href="#1-1-경로표현식이란" class="headerlink" title="1-1. 경로표현식이란?"></a>1-1. 경로표현식이란?</h3><ul><li>. 찍어서 객체그래프를 탐색하는 것 </li></ul><h3 id="1-2-경로표현식-특징"><a href="#1-2-경로표현식-특징" class="headerlink" title="1-2. 경로표현식 특징"></a>1-2. 경로표현식 특징</h3><ul><li>상태 필드(state field): 경로 탐색의 끝, 탐색X</li><li>단일 값 연관 경로: 묵시적 내부 조인(inner join) 발생, 탐색O<ul><li>@ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team)</li></ul></li><li>컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색X<ul><li>FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통 해 탐색 가능</li><li>@OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.orders)</li></ul></li></ul><h3 id="1-3-경로탐색을-사용한-묵시적-조인-시-주의사항"><a href="#1-3-경로탐색을-사용한-묵시적-조인-시-주의사항" class="headerlink" title="1-3. 경로탐색을 사용한 묵시적 조인 시 주의사항"></a>1-3. 경로탐색을 사용한 묵시적 조인 시 주의사항</h3><ul><li>항상 내부조인 걸림 </li><li>걸렉션은 경로 탐색이 안된다. (사이즈만 받을수있음) 따라서 컬렉션은 반드시 명시적 조인으로 별칭을 얻어서 경로탐색하도록 해야함<ul><li>select m.username from Team t join t.members m</li></ul></li><li>경로탐색은 주로 SELECT/WHERE 절에서만 하는데, 묵시적조인을 사용하면 SQL에서 FROM(JOIN) 절에 영향을 줌 </li></ul><h3 id="1-4-실무자의-조언"><a href="#1-4-실무자의-조언" class="headerlink" title="1-4. 실무자의 조언"></a>1-4. 실무자의 조언</h3><ul><li>가급적 묵시적 조인 하지말고 명시적 조인만 사용하도록 하자 (쿼리 튜닝 및 알아보기 힘듦)</li><li>조인은 sql튜닝에 가장 중요한 포인트(기승전 SQL)</li><li>묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움 </li></ul><h2 id="2-페치-조인-fetch-join"><a href="#2-페치-조인-fetch-join" class="headerlink" title="2. 페치 조인 (fetch join)"></a>2. 페치 조인 (fetch join)</h2><h3 id="2-1-페치-조인의-특징"><a href="#2-1-페치-조인의-특징" class="headerlink" title="2-1. 페치 조인의 특징"></a>2-1. 페치 조인의 특징</h3><ul><li>SQL join종류 아님 (sql 명령어 아님)</li><li>JPQL 성능 최적화를 위해 제공하는 기능 </li><li>연관된 엔티티나 컬렉션을 SQL 한번에 함께 조회 가능 (한방쿼리)</li><li>join fetch 명령어 사용 </li><li>페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로</li></ul><h3 id="2-2-엔티티-페치-조인"><a href="#2-2-엔티티-페치-조인" class="headerlink" title="2-2. 엔티티 페치 조인"></a>2-2. 엔티티 페치 조인</h3><ul><li>ManyToOne, OneToOne 관계에서 조회할때 이슈라고 생각해도됨. </li><li>회원-팀 예시 기준으로 회원을 조회하면서 연관된 팀도 함께 조회 (SQL 한방 쿼리)</li><li>SQL을 보면 회원 뿐만 아니라 팀(T.*)도 함께 SELECT</li><li>[JPQL]<ul><li>select m from Member m join fetch m.team</li></ul></li><li>[SQL]<ul><li>SELECT M.<em>, T.</em> FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID</li></ul></li></ul><p><img src="/images/jpa/jpql-11.png" alt="엔티티페치조인 예시"><br><img src="/images/jpa/jpql-12.png" alt="엔티티페치코드 예시"></p><p>[Q1] 그냥 Member 엔티티를 쿼리를 날리고, 비즈니스코드에서 Team정보를 조회하면?</p><figure class="highlight java"><figcaption><span>엔티티조회</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members =entityManager.createQuery(<span class="string">&quot;select m from Member m&quot;</span>, Member.class).getResultList();</span><br><span class="line"><span class="keyword">for</span> (Member member1 : members2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;member1.getUserName() = &quot;</span> + member1.getUserName() </span><br><span class="line">+ <span class="string">&quot;/ teamName : &quot;</span> + member1.getTeam().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–&gt; 위 처럼 비즈니스로직에서 Team정보를 호출하면 proxy상태이기때문에, 초기화처리로 각 멤버당 팀 정보를 디비를 통해 조회 해오게된다. 하지만 1차캐시에 등록된 그니까 영속성 관리가 되면 1차캐시 정보로 가져오게됨. </p><figure class="highlight plain"><figcaption><span>엔티티조회결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m *&#x2F; select</span><br><span class="line">            member0_.member_id as member_i1_0_,</span><br><span class="line">            member0_.age as age2_0_,</span><br><span class="line">            member0_.team_id as team_id4_0_,</span><br><span class="line">            member0_.userName as userName3_0_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m1&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m2&#x2F; teamName : Team1 &#x2F;&#x2F;여기서는 1차캐시로 조회된 정보 가져옴 </span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m3&#x2F; teamName : Team2</span><br></pre></td></tr></table></figure><p>[Q2] 위 쿼리에서 Team엔티티를 조인해서 조회하면 어떻게 될까? </p><figure class="highlight java"><figcaption><span>단순 조인시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members =entityManager.createQuery(<span class="string">&quot;select m from Member m join m.team&quot;</span>, Member.class).getResultList();</span><br><span class="line"><span class="keyword">for</span> (Member member1 : members2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;member1.getUserName() = &quot;</span> + member1.getUserName() </span><br><span class="line">+ <span class="string">&quot;/ teamName : &quot;</span> + member1.getTeam().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–&gt; 단순 조인만 했지만 프로젝션 상에서 팀정보가 없다.<br>어쨋든 위 상황에서는 프로젝션상에서 Team엔티티 정보가 없기때문에 Q1 상황과 동일한 결과로 나오게됨.<br>(참고) 글로벌 페치 전략을 아무리 EAGER로 강제해도 동일한 결과 나올수밖에 없음. 프록시 이슈는 동일하게 나올수밖에없더라.<br>(추론) 만약에 저기서 조회를 가능하게 하려면 프로젝션상에서 t를 받고, 프로젝션에 맞는 신규DTO를 만들어서 객체로 반환하면 해결되지않을까 싶음. </p><figure class="highlight plain"><figcaption><span>단순 조인시 결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m </span><br><span class="line">    join</span><br><span class="line">        m.team *&#x2F; select</span><br><span class="line">            member0_.member_id as member_i1_0_,</span><br><span class="line">            member0_.age as age2_0_,</span><br><span class="line">            member0_.team_id as team_id4_0_,</span><br><span class="line">            member0_.userName as userName3_0_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_ </span><br><span class="line">        inner join &#x2F;&#x2F;조인만 됫지 프로젝션상에서는 Team정보가 없다..-_-; </span><br><span class="line">            Team team1_ </span><br><span class="line">                on member0_.team_id&#x3D;team1_.team_id</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m1&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m2&#x2F; teamName : Team1</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        team0_.team_id as team_id1_3_0_,</span><br><span class="line">        team0_.name as name2_3_0_ </span><br><span class="line">    from</span><br><span class="line">        Team team0_ </span><br><span class="line">    where</span><br><span class="line">        team0_.team_id&#x3D;?</span><br><span class="line">member1.getUserName() &#x3D; m3&#x2F; teamName : Team2</span><br></pre></td></tr></table></figure><p>[Q3] 그럼 저렇게 N+1이 나면 어떻게 해결해야함?<br>–&gt; fetch join 하면 됨. </p><figure class="highlight java"><figcaption><span>조인페치시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Member&gt; members =entityManager.createQuery(<span class="string">&quot;select m from Member m join fetch m.team&quot;</span>, Member.class).getResultList();</span><br><span class="line"><span class="keyword">for</span> (Member member1 : members2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;member1.getUserName() = &quot;</span> + member1.getUserName() </span><br><span class="line">+ <span class="string">&quot;/ teamName : &quot;</span> + member1.getTeam().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>단순 조인시 결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        m </span><br><span class="line">    from</span><br><span class="line">        Member m </span><br><span class="line">    join</span><br><span class="line">        fetch m.team *&#x2F; select</span><br><span class="line">            member0_.member_id as member_i1_0_0_,</span><br><span class="line">            team1_.team_id as team_id1_3_1_,</span><br><span class="line">            member0_.age as age2_0_0_,</span><br><span class="line">            member0_.team_id as team_id4_0_0_,</span><br><span class="line">            member0_.userName as userName3_0_0_,</span><br><span class="line">            team1_.name as name2_3_1_ </span><br><span class="line">        from</span><br><span class="line">            Member member0_ </span><br><span class="line">        inner join</span><br><span class="line">            Team team1_ </span><br><span class="line">                on member0_.team_id&#x3D;team1_.team_id</span><br><span class="line">member1.getUserName() &#x3D; m1&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m2&#x2F; teamName : Team1</span><br><span class="line">member1.getUserName() &#x3D; m3&#x2F; teamName : Team2</span><br></pre></td></tr></table></figure><h3 id="2-3-컬렉션-페치-조인"><a href="#2-3-컬렉션-페치-조인" class="headerlink" title="2-3. 컬렉션 페치 조인"></a>2-3. 컬렉션 페치 조인</h3><ul><li>일대다,다대다 관계, 컬렉션 페치 조인 </li><li>[JPQL]<ul><li>select t from Team t join fetch t.members where t.name = ‘팀A’</li></ul></li><li>[SQL]<ul><li>SELECT T.<em>, M.</em> FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID WHERE T.NAME = ‘팀A’</li></ul></li></ul><p><img src="/images/jpa/jpql-13.png" alt="컬렉션페치조인 예시"><br><img src="/images/jpa/jpql-14.png" alt="컬렉션페치코드 예시"></p><h3 id="컬렉션-페치-조인-혹은-그냥-조인을-걸었는데-중복-발생"><a href="#컬렉션-페치-조인-혹은-그냥-조인을-걸었는데-중복-발생" class="headerlink" title="컬렉션 페치 조인 혹은 그냥 조인을 걸었는데 중복 발생?"></a>컬렉션 페치 조인 혹은 그냥 조인을 걸었는데 중복 발생?</h3><p>OneToMany특성상 쿼리 뻥튀기가 되었기때문에 중복 row발생된것임. 이걸 해결할라면 jpql의 distinct를 걸어주면 해결됨. </p><h4 id="JPQL에서의-distinct"><a href="#JPQL에서의-distinct" class="headerlink" title="JPQL에서의 distinct"></a>JPQL에서의 distinct</h4><ul><li>SQL의 distinct 처리를 명령함  </li><li>JPQL에서는 distinct 2가지 기능 제공 <ol><li>SQL distinct 를 추가시킴. </li><li>애플리케이션에서 엔티티 중복을 제거시킴. </li></ol></li></ul><p>[Q1] Member 컬렉션을 조인하면 어떻게 될까?</p><figure class="highlight java"><figcaption><span>컬렉션조인시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select t from Team t join t.members&quot;</span>, Team.class)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>컬렉션조인결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        t.members *&#x2F; select</span><br><span class="line">            team0_.team_id as team_id1_3_,</span><br><span class="line">            team0_.name as name2_3_ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        members0_.team_id as team_id4_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_1_,</span><br><span class="line">        members0_.age as age2_0_1_,</span><br><span class="line">        members0_.team_id as team_id4_0_1_,</span><br><span class="line">        members0_.userName as userName3_0_1_ </span><br><span class="line">    from</span><br><span class="line">        Member members0_ </span><br><span class="line">    where</span><br><span class="line">        members0_.team_id&#x3D;?</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2 &#x2F;&#x2F;컬렉션 조인시 요렇게 중복된 결과가 나오는걸 확인할수있음. 이럴때는 distinct를 걸어서 중복제거해야함. </span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        members0_.team_id as team_id4_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_0_,</span><br><span class="line">        members0_.member_id as member_i1_0_1_,</span><br><span class="line">        members0_.age as age2_0_1_,</span><br><span class="line">        members0_.team_id as team_id4_0_1_,</span><br><span class="line">        members0_.userName as userName3_0_1_ </span><br><span class="line">    from</span><br><span class="line">        Member members0_ </span><br><span class="line">    where</span><br><span class="line">        members0_.team_id&#x3D;?</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure><p>[Q2] 컬렉션 조인을 페치하면 어떻게 될까?<br>–&gt; 쿼리는 fetch가 되서 한방쿼리가 되었지만, distinct처리 안해서 중복 엔티티 row발생함. </p><figure class="highlight java"><figcaption><span>컬렉션조인시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select t from Team t join fetch t.members&quot;</span>, Team.class)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>컬렉션조인결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        fetch t.members *&#x2F; select</span><br><span class="line">            team0_.team_id as team_id1_3_0_,</span><br><span class="line">            members1_.member_id as member_i1_0_1_,</span><br><span class="line">            team0_.name as name2_3_0_,</span><br><span class="line">            members1_.age as age2_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_1_,</span><br><span class="line">            members1_.userName as userName3_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_0__,</span><br><span class="line">            members1_.member_id as member_i1_0_0__ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2 &#x2F;&#x2F;fetch를하면 쿼리는 줄지만 distinct를 처리하지 않았기때문에 여전히 중복 발생 </span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure><p>[Q3] 위 쿼리에서 distinct를 걸면 해결되나?<br>–&gt; 해결됨</p><figure class="highlight java"><figcaption><span>컬렉션페치조인 distinct처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select distinct t from Team t join fetch t.members&quot;</span>, Team.class)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>컬렉션페치조인 distinct처리결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        distinct t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        fetch t.members *&#x2F; select</span><br><span class="line">            distinct team0_.team_id as team_id1_3_0_,</span><br><span class="line">            members1_.member_id as member_i1_0_1_,</span><br><span class="line">            team0_.name as name2_3_0_,</span><br><span class="line">            members1_.age as age2_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_1_,</span><br><span class="line">            members1_.userName as userName3_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_0__,</span><br><span class="line">            members1_.member_id as member_i1_0_0__ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure><p>[Q4] 컬렉션 페치 조인해서 페이징 적용하면 어떻게되나?<br>–&gt; 페이징 로직이 미적용되고, 메모리에 해당 엔티티들의 모든 row가 다 적재됨. (메모리 부하 발생 성능 다운됨.)</p><figure class="highlight java"><figcaption><span>컬렉션페치조인 페이징처리시도</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select distinct t from Team t join fetch t.members&quot;</span>, Team.class)</span><br><span class="line">                .setFirstResult(<span class="number">0</span>)</span><br><span class="line">                .setMaxResults(<span class="number">2</span>)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>컬렉션페치조인 페이징적용결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        distinct t </span><br><span class="line">    from</span><br><span class="line">        Team t </span><br><span class="line">    join</span><br><span class="line">        fetch t.members *&#x2F; select</span><br><span class="line">            distinct team0_.team_id as team_id1_3_0_,</span><br><span class="line">            members1_.member_id as member_i1_0_1_,</span><br><span class="line">            team0_.name as name2_3_0_,</span><br><span class="line">            members1_.age as age2_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_1_,</span><br><span class="line">            members1_.userName as userName3_0_1_,</span><br><span class="line">            members1_.team_id as team_id4_0_0__,</span><br><span class="line">            members1_.member_id as member_i1_0_0__ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ </span><br><span class="line">        inner join</span><br><span class="line">            Member members1_ </span><br><span class="line">                on team0_.team_id&#x3D;members1_.team_id &#x2F;&#x2F;페이징 처리 로직 미적용됨. </span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;메모리 다 적재됫다고 경고떳음</span><br><span class="line">5월 08, 2021 3:11:40 오후 org.hibernate.hql.internal.ast.QueryTranslatorImpl list</span><br><span class="line">WARN: HHH000104: firstResult&#x2F;maxResults specified with collection fetch; applying in memory!</span><br><span class="line">5월 08, 2021 3:11:40 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PoolState stop</span><br><span class="line">INFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;~&#x2F;jpqlshop]</span><br></pre></td></tr></table></figure><p>–&gt; 페이징을 강제로 해결하려면 페치조인 걸었던것 제거하고 Team.members에 @BatchSize를 걸던지, 혹은 글로벌 설정에서 persistence.xml혹은 application.yml등에서 batchsize를 설정해야함. 보통 글로벌 설정으로 설정하고 시작한다고함. </p><figure class="highlight java"><figcaption><span>컬렉션페치조인 페이징처리 batchsize적용상태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////// Team.java /////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@BatchSize(size = 100)</span></span><br><span class="line"><span class="meta">@OneToMany(mappedBy = &quot;team&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">///////// 구분 /////////////</span></span><br><span class="line"></span><br><span class="line">List&lt;Team&gt; teams2 = entityManager.createQuery(<span class="string">&quot;select distinct t from Team t&quot;</span>, Team.class)</span><br><span class="line">                .setFirstResult(<span class="number">0</span>)</span><br><span class="line">                .setMaxResults(<span class="number">2</span>)</span><br><span class="line">                .getResultList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Team team1 : teams2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;team1.getName() = &quot;</span> + team1.getName() + <span class="string">&quot;/ members : &quot;</span>+ team1.getMembers().size());</span><br><span class="line">    <span class="keyword">for</span> (Member member1 : team1.getMembers()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; member1.getUserName()  = &quot;</span> + member1.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>컬렉션페치조인 페이징적용결과-batchsize적용했을때</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* select</span><br><span class="line">        distinct t </span><br><span class="line">    from</span><br><span class="line">        Team t *&#x2F; select</span><br><span class="line">            distinct team0_.team_id as team_id1_3_,</span><br><span class="line">            team0_.name as name2_3_ </span><br><span class="line">        from</span><br><span class="line">            Team team0_ limit ?</span><br><span class="line">Hibernate: </span><br><span class="line">    &#x2F;* load one-to-many entity.Team.members *&#x2F; select</span><br><span class="line">        members0_.team_id as team_id4_0_1_,</span><br><span class="line">        members0_.member_id as member_i1_0_1_,</span><br><span class="line">        members0_.member_id as member_i1_0_0_,</span><br><span class="line">        members0_.age as age2_0_0_,</span><br><span class="line">        members0_.team_id as team_id4_0_0_,</span><br><span class="line">        members0_.userName as userName3_0_0_ </span><br><span class="line">    from</span><br><span class="line">        Member members0_ </span><br><span class="line">    where</span><br><span class="line">        members0_.team_id in (</span><br><span class="line">            ?, ?</span><br><span class="line">        )</span><br><span class="line">team1.getName() &#x3D; Team1&#x2F; members : 2</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m2</span><br><span class="line">team1.getName() &#x3D; Team2&#x2F; members : 1</span><br><span class="line">--&gt; member1.getUserName()  &#x3D; m3</span><br></pre></td></tr></table></figure><h3 id="2-4-페치조인과-일반조인의-차이"><a href="#2-4-페치조인과-일반조인의-차이" class="headerlink" title="2-4. 페치조인과 일반조인의 차이"></a>2-4. 페치조인과 일반조인의 차이</h3><h4 id="일반-조인"><a href="#일반-조인" class="headerlink" title="일반 조인"></a>일반 조인</h4><ul><li>일반조인 실행시 연관된 엔티티를 함께 조회 안함 </li><li>[JPQL]<ul><li>select t from Team t join t.members m where t.name = ‘팀A’</li></ul></li><li>[SQL]<ul><li>SELECT T.* FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID  WHERE T.NAME = ‘팀A’</li></ul></li><li>JPQL은 결과를 반환할때 연관관계 고려안함</li><li>단지 select절에 지정한 엔티티만 조회한다.</li><li>따라서 Team엔티티만 조회할뿐, Member정보는 조회 안함</li></ul><h4 id="페치-조인"><a href="#페치-조인" class="headerlink" title="페치 조인"></a>페치 조인</h4><ul><li>페치 조인을 사용할때만 연관된 엔티티도 함께 조회 (즉시로딩됨)</li><li>페치 조인은 객체 그래프를 SQL한번에 조회하는 개념 </li><li>페치 조인은 연관된 엔티티를 함께 조회함</li><li>[JPQL]<ul><li>select t from Team t join fetch t.members where t.name = ‘팀A’</li></ul></li><li>[SQL]<ul><li>SELECT T.<em>, M.</em> FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID WHERE T.NAME = ‘팀A’</li></ul></li></ul><h3 id="2-5-페치-조인의-특징-과-한계"><a href="#2-5-페치-조인의-특징-과-한계" class="headerlink" title="2-5. 페치 조인의 특징 과 한계"></a>2-5. 페치 조인의 특징 과 한계</h3><ul><li>페치 조인 대상에서는 별칭을 줄수없다. (하이버네이트는 가능하지만 가급적 사용하지 말자)</li><li>둘 이상의 컬렉션은 페치 조인 할수 없다. (1:N:M의 관계로 가져오기때문에 관련된 모든 정보를 끌고오기때문에)</li><li>컬렉션을 페치조인하면 페이징 API를 사용할수 없다. <ul><li>1:1, N:1 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능 </li><li>1:N, N:M 같은 컬렉션은 강제로 페이징처리를 하면 페이징로직이 무시되고 해당 엔티티에 있는 모든 정보를 다 끌고옴. (하이버네이트에서 경고 로그 남기고 모든 row를 메모리에 올리는 불상사가 벌어짐.)</li><li>컬렉션은 그럼 페이징을 못하는가? 컬렉션 상태에서는 아니고 fetch join한 부분을 지우고 @BatchSize혹은 글로벌설정에서 batchsize를 설정하고 조회하면 페이징 처리는 가능 하지만 N+1을 완벽하게 해소되지 않은 상태지만 성능에는 큰 도움이됨. </li></ul></li><li>연관된 엔티티들을 SQL한번으로 조회 -&gt; 성능 최적화 </li><li>엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함 </li><li>실무에서는 글로벌 로딩전략은 모두 지연로딩으로 걸어두자</li><li>최적화 필요한곳만 페치 조인 적용 </li><li>페치조인을 사용해서 연관된 엔티티를 쿼리시점에 조회해서 지연로딩이 발생하지 않는데, 이때 준영속상태에서도 객체그래프를 탐색할수있다. 왜냐 1차캐시에 올라갔기때문에 </li></ul><h3 id="2-6-페치조인-정리"><a href="#2-6-페치조인-정리" class="headerlink" title="2-6. 페치조인 정리"></a>2-6. 페치조인 정리</h3><ul><li>모든것을 페치 조인으로 해결이 안될때가 있음. </li><li>페치 조인은 객체 그래프를 유지할때 사용하면 효과적 </li><li>여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치조인보다 일반 조인을 사용하고 필요한 데이터들만 프로젝션해서 DTO로 반환하는 것이 효과적</li></ul><h2 id="3-다형성-쿼리"><a href="#3-다형성-쿼리" class="headerlink" title="3. 다형성 쿼리"></a>3. 다형성 쿼리</h2><h3 id="3-1-TYPE"><a href="#3-1-TYPE" class="headerlink" title="3-1. TYPE"></a>3-1. TYPE</h3><ul><li>조회 대상을 특정 자식으로 한정 </li><li>예) 위 예제중 Item중에 Book, Movie를 조회해라</li><li>[JPQL]<ul><li>select i from Item i where type(i) IN (Book, Movie)</li></ul></li><li>[SQL]<ul><li>select i from i where i.DTYPE in (‘B’, ‘M’)</li></ul></li></ul><h3 id="3-2-TREAT-JPA-2-1"><a href="#3-2-TREAT-JPA-2-1" class="headerlink" title="3-2. TREAT (JPA 2.1)"></a>3-2. TREAT (JPA 2.1)</h3><ul><li>자바의 타입 캐스팅과 유사</li><li>상속 구조에서 부모타입을 특정 자식 타입으로 다룰때 사용 </li><li>FROM, WHERE, SELECT(하이버네이트 지원) 사용</li><li>예) 부모인 Item과 자식 Book이 있다.</li><li>[JPQL]<ul><li>select i from Item i where treat(i as Book).auther = ‘kim’</li></ul></li><li>[SQL]<ul><li>select i.* from Item i where i.DTYPE = ‘B’ and i.auther = ‘kim’</li></ul></li></ul><h2 id="4-엔티티-직접-사용"><a href="#4-엔티티-직접-사용" class="headerlink" title="4. 엔티티 직접 사용"></a>4. 엔티티 직접 사용</h2><p><img src="/images/jpa/jpql-15.png" alt="엔티티직접사용 예시"></p><ul><li>JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기 본 키 값을 사용</li><li>[JPQL]<ul><li>select count(m.id) from Member m //엔티티의 아이디를 사용</li><li>select count(m) from Member m //엔티티를 직접 사용</li></ul></li><li>[SQL] (JPQL 둘다 같은 다음 SQL 실행)<ul><li>select count(m.id) as cnt from Member m</li></ul></li></ul><p><img src="/images/jpa/jpql-16.png" alt="엔티티직접사용 기본키예시"><br><img src="/images/jpa/jpql-17.png" alt="엔티티직접사용 외래키예시"></p><h2 id="5-Named-쿼리"><a href="#5-Named-쿼리" class="headerlink" title="5. Named 쿼리"></a>5. Named 쿼리</h2><h3 id="5-1-Named쿼리-정적-쿼리"><a href="#5-1-Named쿼리-정적-쿼리" class="headerlink" title="5-1. Named쿼리 - 정적 쿼리"></a>5-1. Named쿼리 - 정적 쿼리</h3><ul><li>미리 정의해서 이름을 부여해두고 사용하는 JPQL</li><li>정적 쿼리</li><li>어노테이션, XML지원</li><li>애플리케이션 로딩 시점에 초기화 후 재사용 </li><li>애플리케이션 로딩 시점에 쿼리를 검증해줌 </li></ul><h3 id="5-2-Named쿼리-어노테이션-사용-방법"><a href="#5-2-Named쿼리-어노테이션-사용-방법" class="headerlink" title="5-2. Named쿼리 - 어노테이션 사용 방법"></a>5-2. Named쿼리 - 어노테이션 사용 방법</h3><p><img src="/images/jpa/jpql-18.png" alt="Named쿼리 어노테이션예시"></p><h3 id="5-3-Named쿼리-XML-사용방법"><a href="#5-3-Named쿼리-XML-사용방법" class="headerlink" title="5-3. Named쿼리 - XML 사용방법"></a>5-3. Named쿼리 - XML 사용방법</h3><p><img src="/images/jpa/jpql-19.png" alt="Named쿼리 XML예시"></p><h3 id="5-4-Named쿼리-환경에-따른-설정"><a href="#5-4-Named쿼리-환경에-따른-설정" class="headerlink" title="5-4. Named쿼리 환경에 따른 설정"></a>5-4. Named쿼리 환경에 따른 설정</h3><ul><li>XML이 항상 우선권을 가짐 </li><li>애플리케이션 운영 환경에 따라 다른 XML을 배포할수있다. </li></ul><h2 id="6-JPQL-벌크연산"><a href="#6-JPQL-벌크연산" class="headerlink" title="6. JPQL - 벌크연산"></a>6. JPQL - 벌크연산</h2><p><img src="/images/jpa/jpql-20.png" alt="벌크연산"><br><img src="/images/jpa/jpql-21.png" alt="벌크연산 예시"></p><h3 id="6-1-벌크연산시-주의"><a href="#6-1-벌크연산시-주의" class="headerlink" title="6-1. 벌크연산시 주의"></a>6-1. 벌크연산시 주의</h3><ul><li>벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리 (JPQL로 사용하니 당연한 부분)<ul><li>벌크 연산을 먼저 실행 </li><li>벌크 연산 수행 후 영속성 컨텍스트 초기화 </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;객체지향-쿼리-언어2&quot;&gt;&lt;a href=&quot;#객체지향-쿼리-언어2&quot; class=&quot;headerlink&quot; title=&quot;객체지향 쿼리 언어2&quot;&gt;&lt;/a&gt;객체지향 쿼리 언어2&lt;/h1&gt;&lt;h2 id=&quot;1-경로표현식&quot;&gt;&lt;a href=&quot;#1-경로표현식&quot; c</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="자바ORM표준JPA프로그래밍" scheme="https://codexdawn.github.io/categories/%EC%9E%90%EB%B0%94ORM%ED%91%9C%EC%A4%80JPA%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    <category term="객체지향쿼리언어" scheme="https://codexdawn.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4/"/>
    
    
    <category term="Java,JPA" scheme="https://codexdawn.github.io/tags/Java-JPA/"/>
    
    <category term="QueryDSL" scheme="https://codexdawn.github.io/tags/QueryDSL/"/>
    
    <category term="객체지향쿼리언어2" scheme="https://codexdawn.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B42/"/>
    
  </entry>
  
</feed>
