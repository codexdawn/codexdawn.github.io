<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>codexdawn</title>
  
  
  <link href="https://codexdawn.github.io/atom.xml" rel="self"/>
  
  <link href="https://codexdawn.github.io/"/>
  <updated>2021-01-18T03:11:36.317Z</updated>
  <id>https://codexdawn.github.io/</id>
  
  <author>
    <name>codexdawn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java-effective-3</title>
    <link href="https://codexdawn.github.io/2021/01/18/java-effective-3/"/>
    <id>https://codexdawn.github.io/2021/01/18/java-effective-3/</id>
    <published>2021-01-18T01:58:36.000Z</published>
    <updated>2021-01-18T03:11:36.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>싱글턴(singleton) 이란?<br>=&gt; 인스턴스를 오직 하나만 생성할 수 있는 클래스<br>=&gt; ex) 함수와 같은 무상태 객체 (stateless object) , 설계상 유일해야하는 시스템 컨포넌트 </p></blockquote><h2 id="아이템3-private생성자나-열거타입으로-싱글턴임을-보증하라"><a href="#아이템3-private생성자나-열거타입으로-싱글턴임을-보증하라" class="headerlink" title="아이템3. private생성자나 열거타입으로 싱글턴임을 보증하라."></a>아이템3. private생성자나 열거타입으로 싱글턴임을 보증하라.</h2><p><strong>클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.</strong> 그 이유는 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜 구현으로 대체 할 수 없기때문이다. 저자는 싱글턴 만드는 방식을 3가지로 소개한다. 아래 내용 참고 해보자. </p><h3 id="싱글턴1-public-static-멤버가-final-필드-방식"><a href="#싱글턴1-public-static-멤버가-final-필드-방식" class="headerlink" title="싱글턴1. public static 멤버가 final 필드 방식"></a>싱글턴1. public static 멤버가 final 필드 방식</h3><figure class="highlight java"><figcaption><span>public static final 필드 방식 싱긑턴</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis(); </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//내부 코드 중략 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//내부 코드 중략 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####싱글턴1의 장점 </p><ul><li>해당 클래스가 싱글턴임이 API에 명핵하게 드러남</li><li>간결함 </li></ul><h3 id="싱글턴2-정적팩터리-방식의-싱글턴"><a href="#싱글턴2-정적팩터리-방식의-싱글턴" class="headerlink" title="싱글턴2. 정적팩터리 방식의 싱글턴"></a>싱글턴2. 정적팩터리 방식의 싱글턴</h3><figure class="highlight java"><figcaption><span>정적팩터리 방식의 싱글턴</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis(); </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> INSTANCE;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="싱글턴2의-장점"><a href="#싱글턴2의-장점" class="headerlink" title="싱글턴2의 장점"></a>싱글턴2의 장점</h4><ul><li>마음만 먹으면 API를 바꾸지 않아도, 싱글턴이 아니게 변경 가능 </li><li>정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음 (아이템 30)</li><li>정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할수 있음 (Elvis::getInstance -&gt; Supplier<Elvis> (아이템 43, 44))</li></ul><p>싱글턴1,2 방식으로 싱글턴을 개발하면, 직렬화 할때 Serializable을 구현만 하면 안되고, 역직렬화 되었을때 인스턴스가 생성되는 부분을 초반에 조져야 한다. 역직렬화 공격을 방어하려면, 아래 코드를 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;싱글턴임을 보장해주는 readResolve 메서드 </span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">&#x2F;&#x2F;진짜 Elvis는 반환하고, 가짜는 GC에 버린다. </span><br><span class="line">return INSTANCE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="싱글턴3-원소가-하나인-열거타입-선언"><a href="#싱글턴3-원소가-하나인-열거타입-선언" class="headerlink" title="싱글턴3. 원소가 하나인 열거타입 선언"></a>싱글턴3. 원소가 하나인 열거타입 선언</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Elvis &#123;</span><br><span class="line">INSTANCE; </span><br><span class="line"></span><br><span class="line">public void leaveTheBuilding() &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="싱글턴3의-장점"><a href="#싱글턴3의-장점" class="headerlink" title="싱글턴3의 장점"></a>싱글턴3의 장점</h4><ul><li>싱글턴1 방식과 비슷하지만, 더 간결하고 추가적인 노력없이 직렬화 가능 하며 심지어 아주 복잡한 직렬화 상황이나 리플렉션 공격에도 제2의 인스턴스가 생성되는걸 방지 할 수 있다.</li></ul><p>조금 부자연스러워 보일수는 있는데, 저자는 대부분상황에서는 원소가 하나뿐인 열거타입이 싱글턴 만드는 가장 좋은 방법이라고 소개하고있다. 단, 만들려는 싱글턴이 Enum외의 클래스를 상속해야 한다면 이 방법은 사용할수 없다고 한다. (열거 타입이 다른 인터페이스를 구현하도록 선언 할 수는 있다.)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;싱글턴(singleton) 이란?&lt;br&gt;=&amp;gt; 인스턴스를 오직 하나만 생성할 수 있는 클래스&lt;br&gt;=&amp;gt; ex) 함수와 같은 무상태 객체 (stateless object) , 설계상 유일해야하는 시스템 컨포넌트 &lt;/p</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="객체 생성과 파괴" scheme="https://codexdawn.github.io/categories/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%8C%8C%EA%B4%B4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="singleton" scheme="https://codexdawn.github.io/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-2</title>
    <link href="https://codexdawn.github.io/2021/01/16/java-effective-2/"/>
    <id>https://codexdawn.github.io/2021/01/16/java-effective-2/</id>
    <published>2021-01-16T04:57:19.000Z</published>
    <updated>2021-01-16T08:33:01.920Z</updated>
    
    <content type="html"><![CDATA[<p>객체 생성함에 있어서, 아이템1 에서 학습한 정적팩터리 와 생성자에는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을때 적절히 대응하기 어렵다는 점이다. </p><h2 id="아이템2-생성자에-매개변수가-많다면-빌더를-고려하라"><a href="#아이템2-생성자에-매개변수가-많다면-빌더를-고려하라" class="headerlink" title="아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라."></a>아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라.</h2><blockquote><p>점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. </p></blockquote><h3 id="해결안1-생성자"><a href="#해결안1-생성자" class="headerlink" title="해결안1. 생성자"></a>해결안1. 생성자</h3><figure class="highlight java"><figcaption><span>점층적 생성자 패턴</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutiritionFacts coke = <span class="keyword">new</span> NutritionFacts(<span class="number">240</span>,<span class="number">8</span>,<span class="number">100</span>,<span class="number">35</span>,<span class="number">27</span>);</span><br></pre></td></tr></table></figure><p>위 코드를 보았을때 무엇이 느껴지는가? 정말 해당 클래스 스펙을 확인하지 않고서는 식별이 어렵고, 개인적으로 IDE의 버프를 받아 변수명 힌트를 받지 않으면, 엄하게 다른 값 넣고, 삽질하는 경우를 갠적으로 좀 겪어봤다. </p><h3 id="해결안2-자바빈즈-Java-Beans"><a href="#해결안2-자바빈즈-Java-Beans" class="headerlink" title="해결안2. 자바빈즈(Java Beans)"></a>해결안2. 자바빈즈(Java Beans)</h3><figure class="highlight java"><figcaption><span>자바빈즈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NutiritionFacts coke = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line">coke.setServingSize(<span class="number">240</span>);</span><br><span class="line">coke.setServings(<span class="number">8</span>);</span><br><span class="line">coke.setCalories(<span class="number">100</span>);</span><br><span class="line">coke.setSodium(<span class="number">35</span>);</span><br><span class="line">coke.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><p>위 코드는 현업에서 본인이 자주 사용했던 기법이다. 생성자 보다는 확실히 가독성 측면에서는 사용성이 편하지만, 이 부분도 사실 매개변수가 많아지면 불편함이 있고, 소스도 굉장히 길어져서 보기가 싫은 기억이 자주 있다. 그리고 객체 하나를 인스턴스 생성하려면, 위 코드처럼 여러개의 set메소드를 호출 해야한다. 그리고 생성자에서는 각 변수가 어떻게 나와야하는지 지정을 해주지만, 자바빈즈는 개발자가 set메서드를 입력해야하기 때문에 지정된 매개변수를 넣기가 힘들어서, 코드 일관성이 깨져서,버그를 유발시키기도하고, 또한 자바빈즈는 클래스를 불변클래스(아이템17)으로 만들수 없으며, 스레드 안정성을 얻으려면 추가적인 작업해줘야한다. (lock) 이런 단점을 보완 하기 위해 객체 Freezing을 수행한다고 한다.</p><p>그럼 Object Freezing이란? 멀티 스레드 환경에서 객체내에 각 변수을 get할때 freeze 를 synchronized 가 되었는지 확인하고 freeze를 수행 하는데 멀티 스레드 환경이다 보니, 그 변수를 사용중에 있는데 set하는 불상사가 발생하게 된다면, 해당 변수가 set되어지는것을 방지하기 위해서 freeze된부분이 true이면 예외를 던져서 set하지 못하도록 막는 부분이 Object Freezing이다. 쉽게 말하면 화장실 변기에 앉아서 볼일을 보고있는데, 갑자기 뒷사람이 문을 열더니, 너 놔와! 하면서 내동댕이 치고, 쫒겨나는 현상이라 생각하면 될것 같다. 이런 상황을 미연에 방지하기 위해 사용중이라고 문밖에 표시를 하고, 문 잠그고 안전하게 볼일볼수있도록 도와주는 부분을 Freezing 한다라고 개인적으로 이해했다. </p><h3 id="해결안3-빌더패턴"><a href="#해결안3-빌더패턴" class="headerlink" title="해결안3. 빌더패턴"></a>해결안3. 빌더패턴</h3><figure class="highlight java"><figcaption><span>빌더패턴 심플 버전</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"><span class="comment">//필수 매개변수 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//선택적 매개변수</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.servingSize = servingSize; </span><br><span class="line"><span class="keyword">this</span>.servings = servings; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">calories = val; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">fat = val; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">sodium = val; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">carbohydrate = val; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> NuritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NuritionFacts(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">NuritionFacts</span><span class="params">(Builder bulider)</span> </span>&#123;</span><br><span class="line">servingSize = builder.servingSize; </span><br><span class="line">servings = builder.servings; </span><br><span class="line">calories = builder.calories; </span><br><span class="line">fat = builder.fat; </span><br><span class="line">sodium = builder.sodium; </span><br><span class="line">carbohydrate = builder.carbohydrate; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>책에서는 핵심만 도드라져 보이도록 유효성 검사 코드는 생략했다고한다. 잘못된 매개변수임을 유효성 검토하려면, 빌더의 생성자와 메서드에서 입력매개변수를 검사하고, build 메서드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식 (invariant)을 검사하자. (invalid메서드 만들어서 객체가 정말 유효한지 검증하자는 말이다.) </p><blockquote><p>Class Invariant?<br><a href="https://en.wikipedia.org/wiki/Class_invariant">https://en.wikipedia.org/wiki/Class_invariant</a><br>위 위키 사이트에 잘 명시가 되어있는데, 말이 어려워서 그렇지 결국 유효성 검증을 하라는 말이다.<br>예를들어 1월은 1~31일까지 있는데 32일까지 나오는것로 표기되면 오류 이기 때문에, 객체 생성 시점 전에 assert를 하라는 소리이다. </p></blockquote><figure class="highlight java"><figcaption><span>빌더패턴 인스턴스 생성부</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutiritionFacts coke = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>,<span class="number">8</span>).calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><p>길고 긴 Builder를 작성하고 나면, 위와같이 간단하게(?) 객체를 생성할수 있다. 딱 봐도 가독성이 좋고, 필수 매개변수 와 옵션 매개변수를 나눌수가 있어서, 필수 매개변수 이외에 옵션으로 불필요 매개변수는 빼고 객체를 넣어도 상관이 없다.<br>그리고 <strong>빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.</strong> 주저리 주저리 하는것 보다 아래 코드를 보자. </p><figure class="highlight java"><figcaption><span>Pizza Abstract Builder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Topping</span> </span>&#123;HAM, MUSHROOM, ONION, PEPPER, SAUAGE&#125;</span><br><span class="line"><span class="keyword">final</span> Set&lt;Topping&gt; toppings; </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">addTopping</span><span class="params">(Topping topping)</span> </span>&#123;</span><br><span class="line">toppings.add(Objects.requireNonNull(topping)); </span><br><span class="line"><span class="keyword">return</span> self(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Pizza <span class="title">build</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 하위 클래스는 이 메서드를 재정의 하여 this를 반환하도록 해야한다. </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">toppings = builder.toppings.clone(); <span class="comment">//아이템 50 참고 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>NyPizza Builder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;SMALL, MEDIUM, LARGE&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Size size; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Size size; </span><br><span class="line"></span><br><span class="line"><span class="function">pubilc <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.size = Objects.requireNonNull(size); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(builder); </span><br><span class="line">size = builder.size; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Calzone Builder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calzone</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sauceInside; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line"><span class="function">pubilc Builder <span class="title">sauceInside</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sauceInside = <span class="keyword">true</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Calzone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Calzone(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Calzone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(builder); </span><br><span class="line">sauceInside = builder.sauceInside; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Calzone Builder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NyPizza pizza = <span class="keyword">new</span> NyPizza.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line">CalZone calzone = <span class="keyword">new</span> Calzone.Builder().addTopping(HAM).sauceInside().build(); </span><br></pre></td></tr></table></figure><p>위 코드 처럼 Pizza 추상 클래스를 확장받아서 NyPizza 와 Calzone를 구현하였다. 그래서 기본적으로 addTopping은 하위 클래스에서 사용하고,<br>각각 하위 클래스에서 필수 파라미터로 지정한 부분만 추가적으로 세팅을 한 부분을 확인 할 수 있다.(size, sauceInside)  </p><p>이처럼 빌더패턴은 상당히 유연한 객체로 가변인수를 사용할수있고, 각각 적절한 메서드로 나눠서 선언할수도있고, 메서드를 여러번 호출하도록 하고 각 호출때 넘겨진 매개변수들을 하나의 필드로 모을수도 있다. 그리고 빌더에 넘기는 매개변수에 따라 다른 객체를 만들수도 있다.<br>(앞의 예제 처럼 가능하다는 것이다.)</p><blockquote><p><strong>생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.</strong><br>=&gt; 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고,<br>자바빈즈보다 훨씬 안전하다. </p></blockquote><p>내가 겪은 현업에서는 요즘들어서 빌더가 자주 보이는 편이고, 아직까지는 많이 사용되고 있지는 않는듯하다. 앞으로 복잡하고 큰 도메인 일수록 빌더를 구현해보는것도 나쁘지는 않을듯하다.<br>단, 매개변수가 최소 4개이상은 받을거라는 전제하에.. 직접 짜는것보다 롬복 @Builder를 통해서 사용할 경우가 많을수도 있지만, 너무 롬복에 의존하지말고, 상황에 따라서 직접 짜는 부분도 고려하도록 하자. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;객체 생성함에 있어서, 아이템1 에서 학습한 정적팩터리 와 생성자에는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을때 적절히 대응하기 어렵다는 점이다. &lt;/p&gt;
&lt;h2 id=&quot;아이템2-생성자에-매개변수가-많다면-빌더를-고려하라&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="객체 생성과 파괴" scheme="https://codexdawn.github.io/categories/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%8C%8C%EA%B4%B4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-1</title>
    <link href="https://codexdawn.github.io/2021/01/15/java-effective-1/"/>
    <id>https://codexdawn.github.io/2021/01/15/java-effective-1/</id>
    <published>2021-01-15T15:17:09.987Z</published>
    <updated>2021-01-15T15:17:09.987Z</updated>
    
    <content type="html"><![CDATA[<p>기본적으로 자바에서는 인스턴스를 얻는 수단은 public 생성자이지만,<br>클래스는 생성자와 별도로 정적 팩터리 메서드를 제공 할수 있다. </p><h2 id="아이템1-생성자-대신-정적-팩터리-메서드를-고려하라"><a href="#아이템1-생성자-대신-정적-팩터리-메서드를-고려하라" class="headerlink" title="아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라."></a>아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라.</h2><figure class="highlight java"><figcaption><span>Boolean.valueOf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 메서드는 기본적으로 기본 타입인 boolean을 받아 Boolean 객체 참조로 변환해 준다. </p><h3 id="장점1-이름을-가질수-있다-메서드의-목적을-분명하게-알수있다"><a href="#장점1-이름을-가질수-있다-메서드의-목적을-분명하게-알수있다" class="headerlink" title="장점1. 이름을 가질수 있다. (메서드의 목적을 분명하게 알수있다.)"></a>장점1. 이름을 가질수 있다. (메서드의 목적을 분명하게 알수있다.)</h3><p>자바에서 기본으로 제공하는 public생성자는 이름을 가질수없으며, 매개변수들이 포함되어 있는 생성자 역시 이름이 없다.<br>그래서 개발자들은 여러 생성자가 존재 할 경우, 어떤 역할을 하는지 한눈에 알아보기가 쉽지않을것이다.<br>이런 public생성자의 단점을 이름을 가질수있는 정적 팩터리 메서드가 해결 할 수있다. </p><h3 id="장점2-호출될-때마다-인스턴스를-새로-생성하지-않아도-된다"><a href="#장점2-호출될-때마다-인스턴스를-새로-생성하지-않아도-된다" class="headerlink" title="장점2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다."></a>장점2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.</h3><p>자바에서 public생성자를 호출 하려면 new 키워드로 인스턴스를 생성하게 되어있다.<br>하지만 정적 팩터리 메서드를 사용하면, 매번 인스턴스를 생성하지 않아도 된다.<br>특히 불변 클래스(immutable class; 아이템17)는 인스턴스를 미리 만들어놓거나 새로 생성한 인스턴스를 캐싱하여, 재활용하는 식으로 불필요한 객체 생성을 피할수 있다. (EX&gt; Boolean.valueOf) 따라서 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어올려 준다.</p><blockquote><p>인스턴스 통제(instance-controlled) 클래스란? (ex&gt; 싱글턴)<br>=&gt; 반복된 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할수있다. </p><p>인스턴스를 통제하는 이유는?<br>=&gt; 싱글턴, 인스턴스화 불가(Util성 클래스에서 생성자 막을때), 불변 값 클래스에서 동치인 인스턴스가 단 하나임을 보장 (a == b 일때, a.equals(b) 성립) </p></blockquote><h3 id="장점3-반환-타입의-하위-타입-객체를-반환할-수-있는-능력이-있다"><a href="#장점3-반환-타입의-하위-타입-객체를-반환할-수-있는-능력이-있다" class="headerlink" title="장점3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다."></a>장점3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.</h3><p>제목이 거창해서 그렇지, 간단하게 생각하면 인터페이스를 반환 타입을 갖게하고, 실제로는 인터페이스를 구현하는 구현체를 리턴하는 방식 가장 대표적인 예는 <code>java.util.Collections</code> 이다. 이 컬렉션 프레임워크는 45개의 구현체 클래스를 사용하고 있지만, 실제로 사용하는 개발자는 45개나 되는 구현체를 굳이 알필요가 없도록, 정적 팩터리 메서드를 사용하였다.<br>자바8부터는 인터페이스가 정적 메서드(public static) 를 가질 수 없는 제한이 풀렸다. 자바9에서는 private 정적메서드까지 허락하지만,정적 필드와 정적 멤버 클래스는 여전히 public이어야함. </p><h3 id="장점4-입력-매개변수에-따라-매번-다른-클래스의-객체를-반환할-수-있다"><a href="#장점4-입력-매개변수에-따라-매번-다른-클래스의-객체를-반환할-수-있다" class="headerlink" title="장점4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다."></a>장점4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.</h3><p>장점3과 비슷한 맥락이지만, 차이점은 매개변수의 갯수의 차이다. EnumSet은 public생성자가 없이 오직 정적 팩터리만 제공하는데, 원소가 64개 이하면 RegularEnumSet을 65개이상이면 JumboEnumSet의 인스턴스를 반환하게 구현되어있다.<br>하지만 굳이 개발자가 하위타입의 리턴타입을 알 필요가 있을까? 당연 없다. </p><h3 id="장점5-정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다"><a href="#장점5-정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다" class="headerlink" title="장점5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다."></a>장점5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</h3><p>이 책에서는 위 장점의 예를 둔 부분이, JDBC이다. JDBC로 개발할때를 생각하면 어느정도 이해를 할 수 있다.</p><figure class="highlight java"><figcaption><span>jdbc example</span><a href="https://www.tutorialspoint.com/jdbc-class-forname-vs-drivermanager-registerdriver">tutorialspoint.com</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Registering the Driver</span></span><br><span class="line">   DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());       <span class="comment">//Class.forName으로 자주 씀. </span></span><br><span class="line">   <span class="comment">//Getting the connection</span></span><br><span class="line">   String mysqlUrl = <span class="string">&quot;jdbc:mysql://localhost/mydatabase&quot;</span>;</span><br><span class="line">   Connection con = DriverManager.getConnection(mysqlUrl, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;Connection established: &quot;</span>+con);</span><br></pre></td></tr></table></figure><p>위 코드에서 확인 할 수 있듯이, Connection을 사용하기 위해서 <code>DriverManager.registerDriver</code> 통해서 어떤 DB의 방언을 사용할것 인지 결정하고 (제공자등록API),<br>Connection인터페이스는 어떤 DB방언에도 연결할수있도록 서비스 인터페이스 역할을 담당하고, 결국 <code>DriverManager.getConnection</code>을 통해서 서비스에 접근하여 인스턴스를 얻을수있도록 한다. 여기서 DriverManager.getConnection 이 장점5의 의도이다.<br>그래서 우리가 서로 다른 DB의 방언을 제공자 등록 API를 통해 세팅하고, DB접근정보가 담겨있는 서비스접근 API를 통해서 Connection 인터페이스로 반환하게 할때, 마치 DB를 연결하기 위해 중간다리 역할 (브리지 패턴) 처럼 혹은 레고 처럼 조립되는 과정이 있다는걸 알수가 있다. 우리가 흔히 알고있는 DI(의존객체주입) 와 유사하다고 생각하면 된다. </p><h3 id="단점1-상속을-하려면-public이나-protected-생성자가-필요하니-정적-팩터리-메서드만-제공하면-하위-클래스를-만들수-없다"><a href="#단점1-상속을-하려면-public이나-protected-생성자가-필요하니-정적-팩터리-메서드만-제공하면-하위-클래스를-만들수-없다" class="headerlink" title="단점1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들수 없다."></a>단점1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들수 없다.</h3><p>java.util.Collections 컬렉션 프레임워크 처럼 유틸리티 구현 클래스들은 상속할 수 없다는 이야기다. 글쓴이는 이 제약은 상속 보다는 컴포지션을 사용(아이템 18) 하도록 유도하고, 불변 타입(아이템 17)으로 만들려면 이 제약을 지켜야하기에 오히려 장점이 아닌가라고 생각했다.</p><h3 id="단점2-정적-펙터리-메서드는-프로그래머가-찾기-힘들다"><a href="#단점2-정적-펙터리-메서드는-프로그래머가-찾기-힘들다" class="headerlink" title="단점2. 정적 펙터리 메서드는 프로그래머가 찾기 힘들다."></a>단점2. 정적 펙터리 메서드는 프로그래머가 찾기 힘들다.</h3><p>개발자들이 각자의 네이밍룰로 정적 펙터리 메서드를 구현하면, 그 메서드를 찾기위해서 클래스를 찾아서 분석 해야하는 비용이 생겨서, 찾기 어렵다고 표현한것이 아닐까? 추측해본다.<br>그래서 글쓴이는 from, of, valueOf. getInstance 등과 같은 범용적으로 사용되는 정적 팩터리 메서드를 예시로 들면서, 네이밍으로도 그 기능을 알 수 있도록 구현하는걸 추천하고 있다. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;기본적으로 자바에서는 인스턴스를 얻는 수단은 public 생성자이지만,&lt;br&gt;클래스는 생성자와 별도로 정적 팩터리 메서드를 제공 할수 있다. &lt;/p&gt;
&lt;h2 id=&quot;아이템1-생성자-대신-정적-팩터리-메서드를-고려하라&quot;&gt;&lt;a href=&quot;#아이템1-</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="객체 생성과 파괴" scheme="https://codexdawn.github.io/categories/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%8C%8C%EA%B4%B4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
  </entry>
  
</feed>
