<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>codexdawn</title>
  
  
  <link href="https://codexdawn.github.io/atom.xml" rel="self"/>
  
  <link href="https://codexdawn.github.io/"/>
  <updated>2022-06-08T01:47:23.918Z</updated>
  <id>https://codexdawn.github.io/</id>
  
  <author>
    <name>codexdawn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>holder-pattern</title>
    <link href="https://codexdawn.github.io/2022/05/09/holder-pattern/"/>
    <id>https://codexdawn.github.io/2022/05/09/holder-pattern/</id>
    <published>2022-05-09T07:51:40.000Z</published>
    <updated>2022-06-08T01:47:23.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Holder-패턴-사용하기"><a href="#Holder-패턴-사용하기" class="headerlink" title="Holder 패턴 사용하기!"></a>Holder 패턴 사용하기!</h1><h2 id="Holder-패턴이란"><a href="#Holder-패턴이란" class="headerlink" title="Holder 패턴이란?"></a>Holder 패턴이란?</h2><p>문맥 자체만 봐도 어느정도 느낌이 오겠지만, Holder는 소유자라는 뜻으로 어떠한 정보를 소유하고 있는 객체를 의미한다.<br>어떠한 정보를 component로 bean등록하여 호출해서 사용하면 끝이다. 여기서 포인트는 세팅하는 데이터가 영구적으로 오래사용되는 케이스가 많다는부분이다.<br>주로 사용할수있는 부분이 header정보를 갖고있는 RequestHolder, 세션으로 부터 넘겨받은 사용자 정보를 갖고있는 userHolder, 스프링 서버 환경별 정보를 갖고있는 profileHolder등<br>정보를 묶어놓고 필요할때 가져다 쓰는 형태를 의미한다. </p><h2 id="적용방법"><a href="#적용방법" class="headerlink" title="적용방법"></a>적용방법</h2><figure class="highlight java"><figcaption><span>RequestHolder 사용사례</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VRequestInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; IGNORE_URLS = Lists.newArrayList(<span class="string">&quot;/hello&quot;</span>,<span class="string">&quot;/lbStatusCheck&quot;</span>,<span class="string">&quot;/servicemanager/prometheus&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VRequestHolder vRequestHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IGNORE_URLS.contains(request.getRequestURI())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vRequestHolder.build(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;request&quot;, proxyMode= ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VRequestHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProfileHolder profileHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserAgentType userAgentType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLogin;</span><br><span class="line">    <span class="keyword">private</span> AppName appName;</span><br><span class="line">    <span class="keyword">private</span> String appVersion;</span><br><span class="line">    <span class="keyword">private</span> String loginUserInfo;</span><br><span class="line">    <span class="keyword">private</span> String cartInfo;</span><br><span class="line">    <span class="keyword">private</span> String clientIp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaderInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headerInfo = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headerInfo.set(USER_AGENT_TYPE, userAgentType.name());</span><br><span class="line">        headerInfo.set(LOGIN_USER_INFO, loginUserInfo);</span><br><span class="line">        headerInfo.set(NON_USER_INFO, nonUserInfo);</span><br><span class="line">        headerInfo.set(WMP_APP_NAME,appName.getHeadValue());</span><br><span class="line">        headerInfo.set(MOBILE_APP_VERSION, appVersion);</span><br><span class="line">        headerInfo.set(CART_INFO, cartInfo);</span><br><span class="line">        headerInfo.set(CLIENT_IP, clientIp);</span><br><span class="line">        <span class="keyword">return</span> headerInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String mid = request.getHeader(MID);</span><br><span class="line">        <span class="keyword">if</span> (isNotEmpty(mid)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mid = Long.valueOf(mid);</span><br><span class="line">            <span class="keyword">this</span>.isLogin = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setLoginUserInfo(request);</span><br><span class="line">        setNonUserInfo(request);</span><br><span class="line">        setAppName(request);</span><br><span class="line">        setUserAgentType(request);</span><br><span class="line">        setAppVersion(request);</span><br><span class="line">        setCartInfo(request);</span><br><span class="line">        setClientIp(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLoginUserInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String loginUserInfo = request.getHeader(WmpHeaderKey.LOGIN_USER_INFO);</span><br><span class="line">        <span class="keyword">if</span> (isNotBlank(loginUserInfo)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loginUserInfo = loginUserInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNonUserInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String nonUserInfo = request.getHeader(WmpHeaderKey.NON_USER_INFO);</span><br><span class="line">        <span class="keyword">if</span> (isNotBlank(nonUserInfo)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonUserInfo = nonUserInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppVersion</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String appVersion = request.getHeader(WmpHeaderKey.MOBILE_APP_VERSION);</span><br><span class="line">        <span class="keyword">if</span> (isNotBlank(appVersion)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.appVersion = appVersion;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;VRequestHolder.setAppVersion - &#123;&#125;&quot;</span>, request.getHeader(WmpHeaderKey.MOBILE_APP_VERSION));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAppName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String displayServiceTypeAsString = request.getParameter(DISPLAY_SERVICE_TYPE_PARAMETER);</span><br><span class="line">        <span class="keyword">if</span> (isNotEmpty(displayServiceTypeAsString)) &#123;</span><br><span class="line">            DisplayServiceType displayServiceType = DisplayServiceType.findDefaultVertical(displayServiceTypeAsString);</span><br><span class="line">            <span class="keyword">this</span>.appName = (DisplayServiceType.VERTICAL == displayServiceType) ? AppName.WStyle : AppName.WMP;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;VRequestHolder.setAppName - &#123;&#125;&quot;</span>, request.getHeader(WmpHeaderKey.WMP_APP_NAME));</span><br><span class="line">        <span class="keyword">this</span>.appName = AppName.find(request.getHeader(WmpHeaderKey.WMP_APP_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUserAgentType</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;VRequestHolder.setUserAgentType - &#123;&#125;&quot;</span>, request.getHeader(USER_AGENT_TYPE));</span><br><span class="line">        String userAgentType = request.getHeader(USER_AGENT_TYPE);</span><br><span class="line">        <span class="keyword">this</span>.userAgentType = isEmpty(userAgentType) ? APP : UserAgentType.findByName(userAgentType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCartInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String cartInfo = request.getHeader(CART_INFO);</span><br><span class="line">        <span class="keyword">if</span> (isNotBlank(cartInfo)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cartInfo = cartInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setClientIp</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String clientIp = request.getHeader(CLIENT_IP);</span><br><span class="line">        <span class="keyword">if</span> (isNotBlank(clientIp)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clientIp = clientIp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>위 예시의 RequestHolder는 http 요청할때마다 새로운정보가 holder에 담겨야한다. 따라서 @Scope(value = “request”, proxyMode= ScopedProxyMode.TARGET_CLASS) 빈 스콥을 request로 요청해야한다. 보통 holder에 담기는 정보는 singleton 성격의 데이터들이 저장되는 경우가 많이 있다.</li><li>헤더정보는 인터셉터 설정내에 HttpServletRequest 정보를 파라미터로 넘겨서 헤더값 정보를 추출하는 방식으로 사용한다. </li><li>위와 같이 외부에서 해당 정보를 갖길 원할때 holder에 저장된 정보를 꺼내서 사용할때 가장 적합한 패턴으로 체감된다. </li><li>Holder패턴은 FacotryMethod패턴과 아주 유사하다. 단 한가지 다른점은 팩토리메서드패턴은 외부의 요청에 매번생성해서 주지만, Holder패턴은 딱 한번만 생성한다.  </li></ul><p><a href="https://effectiveprogramming.tistory.com/entry/Holder-%ED%8C%A8%ED%84%B4">참고</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Holder-패턴-사용하기&quot;&gt;&lt;a href=&quot;#Holder-패턴-사용하기&quot; class=&quot;headerlink&quot; title=&quot;Holder 패턴 사용하기!&quot;&gt;&lt;/a&gt;Holder 패턴 사용하기!&lt;/h1&gt;&lt;h2 id=&quot;Holder-패턴이란&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    
    <category term="Java,JPA,Spring" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring-batch-2</title>
    <link href="https://codexdawn.github.io/2022/05/09/spring-batch-2/"/>
    <id>https://codexdawn.github.io/2022/05/09/spring-batch-2/</id>
    <published>2022-05-09T02:44:51.000Z</published>
    <updated>2022-06-08T02:11:33.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="스프링-배치-삽질기-2탄-배치-분기-및-상태관리-해버리기"><a href="#스프링-배치-삽질기-2탄-배치-분기-및-상태관리-해버리기" class="headerlink" title="스프링 배치 삽질기 2탄 (배치 분기 및 상태관리 해버리기!)"></a>스프링 배치 삽질기 2탄 (배치 분기 및 상태관리 해버리기!)</h1><h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><p>브랜드 랭킹를 기존에는 한세트만 세팅해서 랭킹을 보여줬지만, 외부의 요청에따라 다양한 가중치를 주고싶다고 요청을 받아서 배치판 AB테스트를 적용해야했다.<br>예를들어 A-D타입까지 각기다른 가중치가 설정되어있다면 (가중치 설정 어드민에서 설정했다고 가정) 배치에서는 4번의 각기 다른 가중치로 계산된 데이터가 적재되어야할것이다.<br>따라서 A-D까지 분기및반복 처리가 요구되어 적용하려고 하였으나, tasklet 방식으로 적용하면 간단하게 로직을 집어넣어주면 되지만, chunk단위 방식으로는 if-else 로직을 직접 넣을수없고,<br>chunk단위 배치만의 분기 처리 방식이 따로 존재하는걸 알게되었고, 거기서부터 내 삽질이 시작되었다. 젠장<br>적는 시점은 개발한지 한참뒤라서 기억이 많이 안난다… 그냥 정리해둬보는걸로… </p><h2 id="적용방법"><a href="#적용방법" class="headerlink" title="적용방법"></a>적용방법</h2><figure class="highlight java"><figcaption><span>batch내 분기 처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JobExecutionDecider brandDecider;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutionContextPromotionListener promotionListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(BRAND_RANK_JOB_NAME)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Job <span class="title">brandRankJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jobBuilderFactory.get(BRAND_RANK_JOB_NAME)</span><br><span class="line">           .incrementer(<span class="keyword">new</span> UniqueRunIdIncrementer())</span><br><span class="line">           .start(saveStep())</span><br><span class="line">           .next(brandDecider)</span><br><span class="line">               .on(<span class="string">&quot;COMPLETE&quot;</span>).to(removeStep())</span><br><span class="line">               .from(brandDecider)</span><br><span class="line">               .on(<span class="string">&quot;CONTINUE&quot;</span>).to(saveStep()).end()</span><br><span class="line">           .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(SAVE_STEP_NAME)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Step <span class="title">saveStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stepBuilderFactory.get(SAVE_STEP_NAME)</span><br><span class="line">           .&lt;VBrandWSinEntity, BrandRankEntity&gt;chunk(CHUNK_SIZE)</span><br><span class="line">           .reader(saveReader())</span><br><span class="line">           .processor(brandRankSaveProcessor)</span><br><span class="line">           .writer(brandRankSaveWriter)</span><br><span class="line">           .listener(promotionListener)</span><br><span class="line">           .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>분기처리를 하려면 상태를 결정하는 상태설정 클래스를 만들어야한다. 해당 부분은 바로 아래 코드에 명시되어있다. </li><li>기본적인 구조는 on (상태명) /to (해당 상태를 결정하는 action) /from (else if 조건) /end (분기 flow 종료)  </li></ul><figure class="highlight java"><figcaption><span>step간 데이터 공유를 위한 설정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionListenerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutionContextPromotionListener <span class="title">promotionListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutionContextPromotionListener executionContextPromotionListener = <span class="keyword">new</span> ExecutionContextPromotionListener();</span><br><span class="line">        executionContextPromotionListener.setKeys(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;status&quot;</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> executionContextPromotionListener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>step간에 상태를 공유하려면 ExecutionContextPromotionListener 를 설정 해줘야 한다.</li></ul><figure class="highlight java"><figcaption><span>상태를결정하도록 설정하기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeciderConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeightProvider weightProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> test = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobExecutionDecider <span class="title">brandDecider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDecider(BRAND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JobExecutionDecider <span class="title">getDecider</span><span class="params">(WeightServiceType serviceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (jobExecution, stepExecution) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            jobExecution = stepExecution.getJobExecution();</span><br><span class="line">            ExecutionContext jobContext = jobExecution.getExecutionContext();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = weightProvider.countByServiceEquals(serviceType);</span><br><span class="line"></span><br><span class="line">            stepExecution.setExitStatus(EXECUTING);</span><br><span class="line">            <span class="keyword">if</span> (EXECUTING.equals(stepExecution.getExitStatus())) &#123;</span><br><span class="line">                ++status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( status &gt;= <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = status;</span><br><span class="line">                log.info(<span class="string">&quot;getDecider =&gt; status - &#123;&#125; || exit  - &#123;&#125;&quot;</span>,String.valueOf((<span class="keyword">char</span>)(test+(temp))), stepExecution.getExitStatus());</span><br><span class="line">                jobContext.put(<span class="string">&quot;status&quot;</span>,String.valueOf((<span class="keyword">char</span>)(test+(temp))));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status &gt; (count-<span class="number">1</span>) || count == <span class="number">0</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;getDecider - COMPLETE - status: &#123;&#125;&quot;</span>, status);</span><br><span class="line">                status = <span class="number">0</span>;</span><br><span class="line">                test = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                stepExecution.setExitStatus(COMPLETED);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FlowExecutionStatus(<span class="string">&quot;COMPLETE&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;getDecider - CONTINUE - status: &#123;&#125;&quot;</span>, status);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FlowExecutionStatus(<span class="string">&quot;CONTINUE&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>위 코드는 A-D의 상태를 관리 한다고 했을때  4번의 상태가 존재하기때문에 4번 배치가 수행되어야한다. stepExecution내에서 Step내 상태를 확인할수있다. (exitStatus)</li><li>최종 리턴결과는 상태를 job에서 처리결과를 FlowExecutionStatus에 담아서 리턴하면, job에서 on절로 체크가 가능하다. </li></ul><h3 id="현재-적용된-상태를-step간-공유변수-가져오는-방법"><a href="#현재-적용된-상태를-step간-공유변수-가져오는-방법" class="headerlink" title="현재 적용된 상태를(step간 공유변수) 가져오는 방법"></a>현재 적용된 상태를(step간 공유변수) 가져오는 방법</h3><p><a href="https://wckhg89.github.io/archivers/springbatch1">참고</a></p><figure class="highlight java"><figcaption><span>상태를 관리하는 클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperStepExecution</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StepExecution stepExecution;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putData</span><span class="params">(String key, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stepExecution == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;StepExecution is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExecutionContext stepContext = <span class="keyword">this</span>.stepExecution.getExecutionContext();</span><br><span class="line">        stepContext.put(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stepExecution == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;StepExecution is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JobExecution jobExecution = stepExecution.getJobExecution();</span><br><span class="line">        ExecutionContext jobContext = jobExecution.getExecutionContext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jobContext.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setStepExecution</span><span class="params">(StepExecution stepExecution)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stepExecution = stepExecution;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> StepExecution <span class="title">getStepExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stepExecution;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>상태를 꺼내오는 부분</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@StepScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandRankSaveProcessor</span> <span class="keyword">extends</span> <span class="title">SuperStepExecution</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">ItemProcessor</span> &lt;<span class="title">VBrandEntity</span>,<span class="title">BrandRankEntity</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//코드중략 </span></span><br><span class="line"><span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeStep</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveStepExecution</span><span class="params">(StepExecution stepExecution)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.setStepExecution(stepExecution);</span><br><span class="line"><span class="keyword">this</span>.status = (String) <span class="keyword">super</span>.getData(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//코드중략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>위와 같이 stepExecution 사용하여 공유 데이터를 저장하고 가져오는것이 가능하다. </li></ul><h2 id="기타-적용하면서-알게된-TMI"><a href="#기타-적용하면서-알게된-TMI" class="headerlink" title="기타 적용하면서 알게된 TMI"></a>기타 적용하면서 알게된 TMI</h2><ul><li>브랜드랭킹 적용하면서 외부 API를 통해 데이터를 가져오는 부분이 많았는데, 이부분이 배치처리의 소요시간의 큰 타격을 줫었음. 처리가 다안되고 1번만 수행하고 배치가 뻗었었음. 그래서 기존 1000개씩 가져와서 했던 부분을 100개로 줄이니까 정상적으로 배치가 수행되었었음. </li><li>가급적이면 api call로 데이터를 가져오는것보다 db로 데이터를 가져와서 처리하는 방식을 고려하도록 하자. 그도 그럴것이 한번 처리할때마다 api콜을 계속하기때문에 지연처리가 발생할수밖에 없었을것이다. </li><li>브랜드배치 말고 베스트랭킹 부분을 step간 데이터공유부분의 소스를 공통으로 가져가려고 공통로직화 시켰는데, status가 static 변수라 좋은 엔지니어링방식을 하지못했었음. static으로 상태를 공유하는일은 극도로 조심해야할것이다.<br>static처리했다가 베스트랭킹에서 상태 C까지 처리했더니 브랜드랭킹에서 A부터 시작해야하는데, D부터 시작하는 불상사가 발생함. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;스프링-배치-삽질기-2탄-배치-분기-및-상태관리-해버리기&quot;&gt;&lt;a href=&quot;#스프링-배치-삽질기-2탄-배치-분기-및-상태관리-해버리기&quot; class=&quot;headerlink&quot; title=&quot;스프링 배치 삽질기 2탄 (배치 분기 및 상태관리 해버</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="Batch" scheme="https://codexdawn.github.io/categories/Batch/"/>
    
    
    <category term="Java,JPA,Spring,Batch" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring-Batch/"/>
    
    <category term="Batch" scheme="https://codexdawn.github.io/tags/Batch/"/>
    
    <category term="querydsl" scheme="https://codexdawn.github.io/tags/querydsl/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-25</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-25/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-25/</id>
    <published>2022-02-05T10:45:46.000Z</published>
    <updated>2022-02-05T10:56:14.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="톱레벨-클래스는-한파일에-하나만-담아라"><a href="#톱레벨-클래스는-한파일에-하나만-담아라" class="headerlink" title="톱레벨 클래스는 한파일에 하나만 담아라"></a>톱레벨 클래스는 한파일에 하나만 담아라</h1><ul><li>소스파일 하나에 톱레벨 클래스를 여러개를 담는데는 컴파일러 오류가 나는 부분은 없지만 득은 없으며, 심각한 위험이 있을수있음 </li><li>한파일에 여러 톱레벨 클래스를 두면 한 클래스를 여러가지로 정의할수 있으며 그중 어느것을 사용할지는 어느 소스파일을 먼저 컴파일하냐에따라 달라짐 (런타임 시점에서 결정되는 치명적인 부분이 결함으로 작용된다는 의미)</li><li>위 이슈를 해결하는 방법은 간단하다. 그냥 톱클래스는 한파일에만 담는것! </li><li>굳이 한파일에 여러 톱레벨 클래스를 담으려면 정적 멤버 클래스로 (private static class) 구현하면 가능함. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;톱레벨-클래스는-한파일에-하나만-담아라&quot;&gt;&lt;a href=&quot;#톱레벨-클래스는-한파일에-하나만-담아라&quot; class=&quot;headerlink&quot; title=&quot;톱레벨 클래스는 한파일에 하나만 담아라&quot;&gt;&lt;/a&gt;톱레벨 클래스는 한파일에 하나만 담아라&lt;/</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-24</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-24/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-24/</id>
    <published>2022-02-05T10:02:54.000Z</published>
    <updated>2022-02-05T10:45:29.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="멤버-클래스는-되도록-static-으로-만들라"><a href="#멤버-클래스는-되도록-static-으로-만들라" class="headerlink" title="멤버 클래스는 되도록 static 으로 만들라"></a>멤버 클래스는 되도록 static 으로 만들라</h1><ul><li>중첩클래스 (nested class)란? 다른 클래스안에 정의된 클래스임 </li><li>중첩클래스 종류? 정적멤버클래스, 멤버클래스, 익명 클래스, 지역 클래스 (이중 첫번째 제외하고 내부 클래스에 해당 (inner class))</li><li>정적 멤버 클래스 vs 멤버 클래스 <ul><li>구문상 차이는 static이 있고 없고 차이</li><li>비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결됨. 그래서 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올수있음 </li><li>정규화된 this란? 클래스명.this 형태로 바깥 클래스의 이름을 명시하는 용법 </li><li>개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할수있다면 정적 멤버 클래스로 만들어야함. 비정적 멤버 클래스는 바깥 인스턴스없이는 생성할수 없기 때문</li></ul></li><li>멤버 클래스에서 바깥 인스턴스에 접근할일 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자! static을 생략하면 바깥 인스턴스로 숨은 외부 참조를 갖게된다. 또한 이런 부분으로 메모리 누수 현상을 겪을수있음. </li><li>익명클래스는 바깥 클래스의 멤버 아님. 익명 클래스는 멤버와 달리 쓰이는 시점에 선언과 동시에 인스턴스가 생성됨. 정적 문맥에서라도 상수변수이외에 정적 멤버를 가질수 없음 </li><li>익명 클래스는 응용하는데 제약이 많다. 선언한 지점에서만 인스턴스를 만들수있고, instanceof 검사나 클래스의 이름이 필요한 작업은 수행못함 </li><li>익명 클래스는 여러 인터페이스를 구현할수없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할수도 없다. 추가적으로 가독성도 안좋음 </li><li>자바8이상부터는 익명클래스보다는 람다로 사용함 </li><li>지역 클래스는 가장 드물게 사용됨. 지역클래스는 지역변수를 사용하는 곳이라면 실질적으로 어디서든 사용가능함. 익명 클래스처럼 비정적 문맥에서 사용될때만 바깥 인스턴스를 참조할수 있으며 정적 멤버는 가질수 없음. 가독성을 위해서 가급적 짧게 작성하길 권장함. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;멤버-클래스는-되도록-static-으로-만들라&quot;&gt;&lt;a href=&quot;#멤버-클래스는-되도록-static-으로-만들라&quot; class=&quot;headerlink&quot; title=&quot;멤버 클래스는 되도록 static 으로 만들라&quot;&gt;&lt;/a&gt;멤버 클래스는 되도록</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-23</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-23/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-23/</id>
    <published>2022-02-05T09:36:56.000Z</published>
    <updated>2022-02-05T10:02:09.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="태그-달린-클래스보다는-클래스-계층구조를-활용하라"><a href="#태그-달린-클래스보다는-클래스-계층구조를-활용하라" class="headerlink" title="태그 달린 클래스보다는 클래스 계층구조를 활용하라"></a>태그 달린 클래스보다는 클래스 계층구조를 활용하라</h1><ul><li>태그달린 클래스? 두가지 이상의 의미를 표현할수있고, 그중 현재 표현하는 의미를 태그값으로 알려주는 클래스 </li><li>태그달린 클래스는 그냥 문제 그자체다. 안티패턴임! 태그달린 클래스는 장황하고, 오류내기도 쉽고, 비효율적임. </li><li>태그달린 클래스를 사용하지 말고 계층구조로 변환하는것이 맞다!</li></ul><figure class="highlight java"><figcaption><span>태그달린클래스-안티패턴</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;RECTANGLE, CIRCLE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Shape shape; </span><br><span class="line"></span><br><span class="line"><span class="comment">//사각형</span></span><br><span class="line"><span class="keyword">double</span> length; </span><br><span class="line"><span class="keyword">double</span> width; </span><br><span class="line"></span><br><span class="line"><span class="comment">//원 </span></span><br><span class="line"><span class="keyword">double</span> radius; </span><br><span class="line"></span><br><span class="line"><span class="comment">//원 전용 생성자 </span></span><br><span class="line">Figure(<span class="keyword">double</span> radius) &#123;</span><br><span class="line">shape = Shape.CIRCLE;</span><br><span class="line"><span class="keyword">this</span>.radius = radius; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//사각형 전용 생성자 </span></span><br><span class="line">Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">shape = Shape.RECTANGLE; </span><br><span class="line"><span class="keyword">this</span>.length = length; </span><br><span class="line"><span class="keyword">this</span>.width = width; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(shape) &#123;</span><br><span class="line"><span class="keyword">case</span> RECTANGLE:</span><br><span class="line"><span class="keyword">return</span> length * width; </span><br><span class="line"><span class="keyword">case</span> CIRCLE:</span><br><span class="line"><span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(shape);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>태그달린크래스에서 계층구조로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//추상클래스 </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//원</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> radius; </span><br><span class="line"></span><br><span class="line">Circle(<span class="keyword">double</span> radius) &#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.PI * (radius * radius); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//사각형</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> length; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> width; </span><br><span class="line"></span><br><span class="line">Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line"><span class="keyword">this</span>.length = length; </span><br><span class="line"><span class="keyword">this</span>.width = width; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> length * width; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//정사각형</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">Squre(<span class="keyword">double</span> side) &#123;</span><br><span class="line"><span class="keyword">super</span>(side,side);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;태그-달린-클래스보다는-클래스-계층구조를-활용하라&quot;&gt;&lt;a href=&quot;#태그-달린-클래스보다는-클래스-계층구조를-활용하라&quot; class=&quot;headerlink&quot; title=&quot;태그 달린 클래스보다는 클래스 계층구조를 활용하라&quot;&gt;&lt;/a&gt;태그 달린</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-22</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-22/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-22/</id>
    <published>2022-02-05T09:27:14.000Z</published>
    <updated>2022-02-05T09:36:33.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="인터페이스는-타입을-정의하는-용도로만-사용하라"><a href="#인터페이스는-타입을-정의하는-용도로만-사용하라" class="headerlink" title="인터페이스는 타입을 정의하는 용도로만 사용하라"></a>인터페이스는 타입을 정의하는 용도로만 사용하라</h1><ul><li>인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할수 있는 타입 역할을 한다. 달리말해, 클래스가 어떤 인터페이스를 구현한다는것은 자신의 인스턴스로 무엇을 할수 있는지를 클라이언트에 얘기해주는것. 인터페이스는 오로지 이용도로만 사용해야함!!! </li><li>상수값을 모아놓는 상수 인터페이스는 안티 패턴이다! 상수 인터페이스를 구현하는건 클래스의 API로 노출하는 행위다. </li><li>상수 인터페이스 대신 상수 유틸클래스를 작성하자! (private 생성자는 필수 구현!)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;인터페이스는-타입을-정의하는-용도로만-사용하라&quot;&gt;&lt;a href=&quot;#인터페이스는-타입을-정의하는-용도로만-사용하라&quot; class=&quot;headerlink&quot; title=&quot;인터페이스는 타입을 정의하는 용도로만 사용하라&quot;&gt;&lt;/a&gt;인터페이스는 타입을 </summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-21</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-21/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-21/</id>
    <published>2022-02-05T09:05:24.000Z</published>
    <updated>2022-02-05T09:26:25.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="인터페이스는-구현하는-쪽을-생각해-설계하라"><a href="#인터페이스는-구현하는-쪽을-생각해-설계하라" class="headerlink" title="인터페이스는 구현하는 쪽을 생각해 설계하라"></a>인터페이스는 구현하는 쪽을 생각해 설계하라</h1><ul><li>인터페이스의 디폴트메서드를 선언하면 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. </li><li>디톨트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬수 있다. (잘못 구현하면 굉장히 위험한 존재!)</li><li>기존 인터페이스에 디폴트 메서드를 추가하는 행위는 굉장히 심사숙고해야함.</li><li>새로운 인터페이스의 경우는 표준적인 메서드 구현을 제공하는데 아주 유용한 수단이며 그 인터페이스를 더 쉽게 구현해 활용할수 있게끔 한다. </li><li>결론은 인터페이스를 설계할때는 늘 세심한 주의를 기울여야하며 테스트를 반드시 권장한다. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;인터페이스는-구현하는-쪽을-생각해-설계하라&quot;&gt;&lt;a href=&quot;#인터페이스는-구현하는-쪽을-생각해-설계하라&quot; class=&quot;headerlink&quot; title=&quot;인터페이스는 구현하는 쪽을 생각해 설계하라&quot;&gt;&lt;/a&gt;인터페이스는 구현하는 쪽을 생각</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-20</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-20/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-20/</id>
    <published>2022-02-05T07:09:26.000Z</published>
    <updated>2022-02-05T09:02:20.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="추상-클래스-보다는-인터페이스를-우선하라"><a href="#추상-클래스-보다는-인터페이스를-우선하라" class="headerlink" title="추상 클래스 보다는 인터페이스를 우선하라"></a>추상 클래스 보다는 인터페이스를 우선하라</h1><ul><li>자바가 제공하는 다중 구현 메커니즘은 추상 클래스와 인터페이스가 존재함 </li><li>자바8부터는 default method 를 제공하여 추상클래스와 인스턴스 메서드를 구현 형태로 제공함 </li><li>추상 클래스와 인터페이스의 큰차이점은 추상클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위클래스가 되어야한다는점, 자바는 단일상속만 지원되니 새로운 타입을 정의하는데 큰 제약이 있음 </li><li>인터페이스는 믹스인 정의에 안성맞춤이다. 믹스인이란? 클래스가 구현할수있는 타입으로 믹스인을 구현한 클래스에 원래의 ‘주된타입’ 외에도 특정 선택적 행위를 제공한다고 선언 하는 효과를 준다. (ex&gt; Comparable) </li><li>인터페이스와 추상골격구현 클래스를 함께 제공하면 인터페이스의 공통메서드를 제공하면서, 추상골격구현 클래스로 중복제거 효과를 볼수있음 (템플릿 메서드 패턴)  </li><li>추상골격구현클래스는 관례상 접두어로 Abtract~ 형태로 사용함 (AbtractList)</li><li>일반적으로 다중 구현용 타입으로는 인터페이스가 적합하다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현 클래스를 함께 제공하는 방법을 꼭 고려하자! </li><li>골격구현은 가능한! 인터페이스의 디폴트메서드로 제공하여 그 인터페이스를 구현한 모든곳에서 활용하도록 하는것이 좋지만, 가능한 이라고 한이유는 인터페이스에 걸려있는 구현상의 제약때문에 골격구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문 </li></ul><p><a href="https://javabom.tistory.com/22">추상골격구현 좋은예시</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;추상-클래스-보다는-인터페이스를-우선하라&quot;&gt;&lt;a href=&quot;#추상-클래스-보다는-인터페이스를-우선하라&quot; class=&quot;headerlink&quot; title=&quot;추상 클래스 보다는 인터페이스를 우선하라&quot;&gt;&lt;/a&gt;추상 클래스 보다는 인터페이스를 우선</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-19</title>
    <link href="https://codexdawn.github.io/2022/02/05/java-effective-19/"/>
    <id>https://codexdawn.github.io/2022/02/05/java-effective-19/</id>
    <published>2022-02-05T06:08:05.000Z</published>
    <updated>2022-02-05T07:04:46.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="상속을-고려해-설계하고-문서화하라-그러지않았다면-상속을-금지하라"><a href="#상속을-고려해-설계하고-문서화하라-그러지않았다면-상속을-금지하라" class="headerlink" title="상속을 고려해 설계하고 문서화하라. 그러지않았다면 상속을 금지하라"></a>상속을 고려해 설계하고 문서화하라. 그러지않았다면 상속을 금지하라</h1><ul><li>상속용 클래스는 재정의 할수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야함 </li><li>상속 클래스를 작성시 내부동작에 영향을 줄수 있는 메서드들은 protected로 선언해야함 </li><li>protected메서드는 하나하나가 내부구현에 해당되므로 그수는 가능한 적어야하지만, 너무 적어도 안된다. </li><li>상속용 클래스를 시험할 방법은 직접 만들어서 확인하는것이 유일함! 상속용 클래스는 반드시 배포전 하위클래스를 만들어서 테스트해봐야함! </li><li>상속용 클래스의 생성자는 직접적으로든 간적접으로든 재정의 가능 메서드를 호출해서는 절대! 안됨! 이유는 상위클래스 생성자가 하위 클래스 생성자 보다 먼저 수행되기때문에 프로그램 오작동이 일어날수있음 </li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;상속을-고려해-설계하고-문서화하라-그러지않았다면-상속을-금지하라&quot;&gt;&lt;a href=&quot;#상속을-고려해-설계하고-문서화하라-그러지않았다면-상속을-금지하라&quot; class=&quot;headerlink&quot; title=&quot;상속을 고려해 설계하고 문서화하라. 그러</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-18</title>
    <link href="https://codexdawn.github.io/2021/12/31/java-effective-18/"/>
    <id>https://codexdawn.github.io/2021/12/31/java-effective-18/</id>
    <published>2021-12-31T04:23:48.000Z</published>
    <updated>2021-12-31T06:17:24.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="상속보다는-컴포지션을-사용하라"><a href="#상속보다는-컴포지션을-사용하라" class="headerlink" title="상속보다는 컴포지션을 사용하라"></a>상속보다는 컴포지션을 사용하라</h1><h2 id="상속의-문제점은"><a href="#상속의-문제점은" class="headerlink" title="상속의 문제점은?"></a>상속의 문제점은?</h2><ul><li>상속은 캡슐화를 깨뜨린다. (상위클래스가 어떻게 구현되었냐에따라서 하위클래스의 동작이 상이할수있음)</li><li>상위 클래스의 로직을 완벽하게 이해하지 못하고, 확장해서 사용하면 논리오류가 발생할 확률이 크다</li><li>상속은 is-a관계가 성립될때만 사용해야한다. A is B = B is a 인지를 늘 생각하고 저 식이 성립안되면 컴포지션을 고려해야한다. </li></ul><h2 id="상속을-대체할-방법은-컴포지션-composition"><a href="#상속을-대체할-방법은-컴포지션-composition" class="headerlink" title="상속을 대체할 방법은? 컴포지션 (composition)"></a>상속을 대체할 방법은? 컴포지션 (composition)</h2><ul><li>컴포지션은 기존 클래스가 새로운 클래스의 구성요소로 쓰다는 뜻이며, 새로운 클래스를 만들고 private필드로 기존클래스의 인스턴스를 참조하게 하는 방식이며, 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드들을 호출해 반환한다. 이방식을 전달(forwarding) 이라하며 새클래스의 메서드를 전달 메서드라 부름. </li><li>컴포지션 + 전달 = 위임(delegate) 이다. </li><li>구아바 프레임워크는 모든 컬렉션 인터페이스용 전달 메서드를 전부 구현해놨음. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;상속보다는-컴포지션을-사용하라&quot;&gt;&lt;a href=&quot;#상속보다는-컴포지션을-사용하라&quot; class=&quot;headerlink&quot; title=&quot;상속보다는 컴포지션을 사용하라&quot;&gt;&lt;/a&gt;상속보다는 컴포지션을 사용하라&lt;/h1&gt;&lt;h2 id=&quot;상속의-문제점은&quot;</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-17</title>
    <link href="https://codexdawn.github.io/2021/12/31/java-effective-17/"/>
    <id>https://codexdawn.github.io/2021/12/31/java-effective-17/</id>
    <published>2021-12-31T02:29:18.000Z</published>
    <updated>2021-12-31T04:23:03.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="변경-가능성을-최소화하라"><a href="#변경-가능성을-최소화하라" class="headerlink" title="변경 가능성을 최소화하라"></a>변경 가능성을 최소화하라</h1><h2 id="클래스를-불변으로-만드려면"><a href="#클래스를-불변으로-만드려면" class="headerlink" title="클래스를 불변으로 만드려면?"></a>클래스를 불변으로 만드려면?</h2><ol><li>객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</li><li>클래스를 확장할수 없도록 한다. <ul><li>하위 클래스에서 부주의하게 혹은 나쁜의도로 객체의 상태를 변하게 만드는 사례를 막아줌 </li></ul></li><li>모든 필드를 final로 선언한다.<ul><li>설계자의 의도를 명확하게 하기 위한 수단 </li><li>스레드 세이프 하기 위한 수단 </li></ul></li><li>모든 필드를 private으로 선언한다.<ul><li>필드가 참조하는 가변객체를 클라이언트에서 직접 접근해 수정하는 일을 막는다.</li><li>불변객체를 참조하는 필드를 public final 로 만 선언해도 불변 객체가 되지만, 다음 릴리스에서 내부 표현을 바꾸지 못하므로 비권장</li></ul></li><li>자신외에 내부의 가변 컴포넌트에 접근할수 없도록 한다. <ul><li>클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을수 없도록 해야함. </li><li>생성자, 접근자, readObject메서드 모두에서 방어적 복사를 수행해야함.  </li></ul></li></ol><h2 id="불변-객체의-장점"><a href="#불변-객체의-장점" class="headerlink" title="불변 객체의 장점?"></a>불변 객체의 장점?</h2><ol><li><p>불변객체는 단순하다 </p><ul><li>생성된 시점부터 파괴될때까지 그대로 간직함.</li><li>가변객체는 상태전이가 발생하여 문서로 남겨놓지않으면 믿고 사용하기 어려움. (신뢰성 제로)</li></ul></li><li><p>불변객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요 없다. </p><ul><li>여러 스레드가 동시에 사용해도 절대 훼손없음. </li><li>다른스레드의 영향이 없어서 불변객체는 안심하고 공유 가능 </li></ul></li><li><p>불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성되지 않게 해주는 정적 팩터리를 제공할수있다. </p><ul><li>정적 팩터리를 사용하면 여러 클라이언트가 한 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용을 줄일수있음. </li><li>public생성자 대신 정적 팩터리를 만들어두면 클라이언트를 수정하지 않고도 필요에 따라 캐시기능을 나중에 덧붙일수있음. </li></ul></li><li><p>불변 객체는 자유롭게 공유할수있음은 물론 불변 객체끼리는 내부 데이터를 공유할수있다. </p></li><li><p>객체를 만들때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. </p><ul><li>값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문</li></ul></li><li><p>불변객체는 그 자체로 실패 원자성을 제공한다. </p><ul><li>상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.</li></ul></li></ol><h2 id="불변-클래스-단점"><a href="#불변-클래스-단점" class="headerlink" title="불변 클래스 단점?"></a>불변 클래스 단점?</h2><ol><li>값이 다르면 반드시 독립된 객체로 만들어야한다. (1개라도 다르면 100개를 만들어도 다 버려짐.)<ul><li>위 부분을 대처하는 방법은 2가지로 소개됨<ul><li>다단계연산 : 미리쓰일 부분을 예측하여 기본기능으로 제공하는 방법  </li><li>가변동반클래스 : 대표적인 예가 String -&gt; StringBuilder (구닥다리 StringBuffer)</li></ul></li></ul></li></ol><h2 id="스마트한-불변클래스-작성-방법"><a href="#스마트한-불변클래스-작성-방법" class="headerlink" title="스마트한 불변클래스 작성 방법?"></a>스마트한 불변클래스 작성 방법?</h2><figure class="highlight java"><figcaption><span>생성자 대신 정적 팩터리를 사용한 불변클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> re; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> im; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Complex</span><span class="params">(<span class="keyword">double</span> re, <span class="keyword">double</span> im)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.re = re;</span><br><span class="line"><span class="keyword">this</span>.im = im; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 불변이기에 캐시도 가능 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> re, <span class="keyword">double</span> im)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Complex(re,im);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>클래스에 final을 걸어서 상속을 못하게하는방법도 있지만 위 코드처럼 생성자를 비공개처리하고 정적팩터리로 제공하는 방법도 있음. </li></ul><h2 id="객체-생성하면서-명심할것"><a href="#객체-생성하면서-명심할것" class="headerlink" title="객체 생성하면서 명심할것!"></a>객체 생성하면서 명심할것!</h2><ul><li>클래스에 getter가 있다고 무조건 setter를 생성하지말고 필요할때 setter를 열어주자 (필요한 필드만!)</li><li>클래스는 꼭 필요한 경우가 아니면 무조건 불변이어야 한다! </li><li>모든 클래스를 불변으로 만들순없다 그럼 변경할수있는 부분을 최소한으로 줄이도록하자 (변경해야할 필드 제외하곤 private final 붙이는 습관화)</li><li>생성자는 불변식이 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야함. <ul><li>확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공하면 안됨 </li><li>객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안됨. </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;변경-가능성을-최소화하라&quot;&gt;&lt;a href=&quot;#변경-가능성을-최소화하라&quot; class=&quot;headerlink&quot; title=&quot;변경 가능성을 최소화하라&quot;&gt;&lt;/a&gt;변경 가능성을 최소화하라&lt;/h1&gt;&lt;h2 id=&quot;클래스를-불변으로-만드려면&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-16</title>
    <link href="https://codexdawn.github.io/2021/12/31/java-effective-16/"/>
    <id>https://codexdawn.github.io/2021/12/31/java-effective-16/</id>
    <published>2021-12-31T01:50:34.000Z</published>
    <updated>2021-12-31T02:28:50.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="public클래스에서는-public필드가-안닌-접근자-메서드를-사용하라"><a href="#public클래스에서는-public필드가-안닌-접근자-메서드를-사용하라" class="headerlink" title="public클래스에서는 public필드가 안닌 접근자 메서드를 사용하라"></a>public클래스에서는 public필드가 안닌 접근자 메서드를 사용하라</h1><ul><li>public 클래스는 멤버변수를 public으로 하면 안된다. (데이터 필드에 직접 접근할수있어서 캡슐화 이점을 제공하지 못함.)</li><li>멤버변수를 public으로 하지말고 private으로 하고 getter/setter로 접근자 메서드로 처리할수있도록 해야함.</li><li>패키지 바깥에서 접근할수있는 클래스라면 접근자메서드를 사용하고, package-private 클래스 혹은 private 중첩 클래스라면 데이터필드를 노출한다해도 큰이슈는 없음. </li><li>public클래스의 필드가 불변이라면 직접 노출할때의 단점이 조금 줄어들지만 좋은 방식은 아님. API를 변경하지 않고는 표현방식을 바꿀수없고, 필드를 읽을때 부수작업을 수행할수 없다는 단점은 여전함. 단, 불변식은 보장할수있게된다. (setter가 없기때문에..)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;public클래스에서는-public필드가-안닌-접근자-메서드를-사용하라&quot;&gt;&lt;a href=&quot;#public클래스에서는-public필드가-안닌-접근자-메서드를-사용하라&quot; class=&quot;headerlink&quot; title=&quot;public클래스에서는 p</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-15</title>
    <link href="https://codexdawn.github.io/2021/12/30/java-effective-15/"/>
    <id>https://codexdawn.github.io/2021/12/30/java-effective-15/</id>
    <published>2021-12-30T08:00:46.000Z</published>
    <updated>2021-12-30T10:20:49.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="클래스와-멤버의-접근권한을-최소화하라"><a href="#클래스와-멤버의-접근권한을-최소화하라" class="headerlink" title="클래스와 멤버의 접근권한을 최소화하라"></a>클래스와 멤버의 접근권한을 최소화하라</h1><blockquote><p>정보은닉의 장점 ? </p><ul><li>시스템 개발 속도를 높임. 여러 컴포넌트를 병렬로 개발할수 있기때문 </li><li>시스템 관리 비용 낮춤. 각 컴포넌트를 더 빨리 파악하여 디버깅 가능/다른 컴포넌트로 교체 부담 적음 </li><li>정보은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 줌. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지않고 해당 컴포넌트만 최적화 할수있기때문</li><li>소프트웨어 재사용성 증가. 외부에 의존하지않고 독자적으로 동작할수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.</li><li>큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할수있기떄문 </li></ul><p>자바에서는 정보은닉 어떻게 함?</p><ul><li>클래스,인터페이스,멤버의 접근성을 명시. 각요소에 접근성은 그 요소가 선언된 위치와 접근제한자로 정해짐. 이 접근 제한자를 잘 활용하는것이 정보은닉의 핵심이다. </li></ul></blockquote><h2 id="정보은닉-잘하는법"><a href="#정보은닉-잘하는법" class="headerlink" title="정보은닉 잘하는법?"></a>정보은닉 잘하는법?</h2><ul><li>기본원칙은 <strong>모든클래스와 멤버의 접근성을 가능한 좁혀야한다</strong> 한마디로 private 위주로 접근을 두자는 의미이며, 공개여부에 따라 차츰차츰 공개하는 방식을 하자는 의미다. </li><li>톱레벨 클래스 | 인터페이스 =&gt; package-private,public (package-private : 패키지내에서만 접근가능)  </li><li>패키지외부에 공개할일 없으면 package-private을 쓰자 </li><li>바깥 클래스에서 클래스 하나에서만 접근하게 하려면 private static 으로 중첩시키면(nested class) 가능하다. </li></ul><blockquote><p>접근제한자 </p><ul><li>private : 멤버를 선언한 톱레벨 클래스에서만 접근 가능  </li><li>package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할수있음. (접근제한자를 명시하지 않을때, 인터페이스는 기본이 public)</li><li>protected : package-private 포함하고, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근가능 </li><li>public : 모든곳에서 접근가능 </li></ul></blockquote><ul><li>public클래스에서는 멤버의 접근수준을 package-private 에서 protected 바꾸는순간, 그 멤버에 접근할수있는 대상범위가 엄청나게 넓어진다. public클래스의 protected멤버는 공개 API이기때문에 영원히 지원해줘야함. 또한 내부 동작방식을 API문서에 적어 사용자에게 공개해야할수도있음. 따라서 protected 멤버는 적을수록 좋다! </li><li>멤버 접근성을 좁히지 못하게 하는 제약하나가 있는데, 상위 클래스의 메서드를 재정의할때 그 접근수준을 상위 클래스보다 좁게 설정할수없음. 왜냐면 리스코프 치환 원칙에 의해서 상위 클래스는 하위 클래스를 대체 할수 있는 원칙으로 이 규칙을 어기면 컴파일 에러남. </li><li>public클래스의 인스턴스 필드는 되도록 public이 아니어야함. public 가변필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다. final로 불변객체로 참조해도 문제는 발생한다.</li><li>클래스에서 public static final 배열필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안됨. </li></ul><figure class="highlight java"><figcaption><span>상수배열사용시 주의사항</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//보안허점이 있다. </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//개선1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line"></span><br><span class="line"><span class="comment">//개선2 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line"><span class="keyword">return</span> PRIVATE_VALUES.clone(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java9 에 이르면 모듈시스템이라는 개념이 있는데 간략하게 모듈은 패키지가 클래스의 모음이라면 모듈은 패키지들의 모음이다. </li><li>모듈은 자신에 속하는 패키지중에 export(공개) 할것들을 선언함. protected 혹은 public이라할지라도, 해당 패키지를 export하지 않으면 모듈 외부에서는 접근 불가능한 구조다. 물론 모듈내에서는 export로 선언여부에 영향범위없음 </li><li>모듈은 접근제한자와 달리 상당히 주의해서 사용해야함. 만약 모듈의 JAR파일을 자신의 모듈경로가 아닌 애플리케이션 클래스패스에 두면 그 모듈안에 모든 패키지는 모듈이 없는것처럼, 모듈 공개여부와 관계없이 public/protected 멤버를 모듈밖에서 접근할수있게됨. </li><li>모듈의 장점을 누비려면, 애초부터 패키지를 모듈단위로 묶고, 모듈 선언에 패키지들의 모든 의존성을 명시하고, 소스트리를 재배치하고 모듈 안으로부터 일반 패키지로의 모든접근에 특별한 조치를 해야함. (내부적인 export 설정을 말하는듯)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;클래스와-멤버의-접근권한을-최소화하라&quot;&gt;&lt;a href=&quot;#클래스와-멤버의-접근권한을-최소화하라&quot; class=&quot;headerlink&quot; title=&quot;클래스와 멤버의 접근권한을 최소화하라&quot;&gt;&lt;/a&gt;클래스와 멤버의 접근권한을 최소화하라&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="클래스와 인터페이스" scheme="https://codexdawn.github.io/categories/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="class" scheme="https://codexdawn.github.io/tags/class/"/>
    
    <category term="interface" scheme="https://codexdawn.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-14</title>
    <link href="https://codexdawn.github.io/2021/12/30/java-effective-14/"/>
    <id>https://codexdawn.github.io/2021/12/30/java-effective-14/</id>
    <published>2021-12-30T06:17:35.000Z</published>
    <updated>2021-12-30T07:30:41.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Comparable을-구현할지-고려하라"><a href="#Comparable을-구현할지-고려하라" class="headerlink" title="Comparable을 구현할지 고려하라"></a>Comparable을 구현할지 고려하라</h1><h2 id="Comparable-뭐임"><a href="#Comparable-뭐임" class="headerlink" title="Comparable 뭐임?"></a>Comparable 뭐임?</h2><ul><li>Comparable은 유일한 메서드인 compareTo만 존재함</li><li>기본적으로 equals와 동일하지만 여기에 더해 순서까지 비교가능하다는 특징이있음. 따라서 정렬이 가능함. </li></ul><h2 id="언제-사용해야할까-사용법은"><a href="#언제-사용해야할까-사용법은" class="headerlink" title="언제 사용해야할까? 사용법은 ?"></a>언제 사용해야할까? 사용법은 ?</h2><ul><li>알파벳, 숫자, 연대와 같이 순서가 명확한 값 클래스를 작성할때 반드시 Comparable 인터페이스를 구현!!</li></ul><figure class="highlight java"><figcaption><span>기본타입필드가 여럿일때 비교</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = Short.compare(areaCode, pn.areaCode);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">result = Short.compare(prefix, pn.prefix);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">result = Short.compare(lineNum, pn.lineNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 와 같은 방식으로 Comparable를 정의할수있겠지만, JAVA8 이상을 활용한다면 위 방법은 구식이다. 코드도 복잡하고</li></ul><figure class="highlight java"><figcaption><span>비교자 생성 메서드를 활용한 비교자</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">.thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">.thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> COMPARATOR.compare(<span class="keyword">this</span>, pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>위와같이 java8의 Comparator를 활용하여 코드를 깔끔하고 성능향상에도 도움을 줄수있음. </p></li><li><p>값의차를 기준으로 compareTo를 사용하는건 절대로 해서는 안됨 </p><figure class="highlight java"><figcaption><span>해시코드 값의 차를 기준으로 하는 비교자</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.hashCode() - o2.hashCode(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>위 방식은 정수 오버플로우를 일으키거나 IEEE 754 부동소수점 계산방식에 따른 오류 발생한다. 그리고 성능도 별로다</p></li></ul><figure class="highlight java"><figcaption><span>해시코드 값의 차를 기준으로 하는 비교자 개선방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode()); </span><br></pre></td></tr></table></figure><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>순서를 고려한다면 Comparable을 구현하자 </li><li>compareTo 메서드에서 필드의 값을 비교할때 &lt; 와 &gt; 연산자는 쓰지말고 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Comparable을-구현할지-고려하라&quot;&gt;&lt;a href=&quot;#Comparable을-구현할지-고려하라&quot; class=&quot;headerlink&quot; title=&quot;Comparable을 구현할지 고려하라&quot;&gt;&lt;/a&gt;Comparable을 구현할지 고려하라&lt;/</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="모든 객체의 공통 메서드" scheme="https://codexdawn.github.io/categories/%EB%AA%A8%EB%93%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B3%B5%ED%86%B5-%EB%A9%94%EC%84%9C%EB%93%9C/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="comparable" scheme="https://codexdawn.github.io/tags/comparable/"/>
    
  </entry>
  
  <entry>
    <title>spring-batch-1</title>
    <link href="https://codexdawn.github.io/2021/12/29/spring-batch-1/"/>
    <id>https://codexdawn.github.io/2021/12/29/spring-batch-1/</id>
    <published>2021-12-29T05:43:43.000Z</published>
    <updated>2021-12-29T07:04:19.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Batch-도전기-간단스-정리"><a href="#Spring-Batch-도전기-간단스-정리" class="headerlink" title="Spring Batch 도전기 (간단스 정리)"></a>Spring Batch 도전기 (간단스 정리)</h1><p>[참고]<br><a href="https://jojoldu.tistory.com/324?category=902551">조졸도님블로그</a></p><h2 id="기본적인-용어"><a href="#기본적인-용어" class="headerlink" title="기본적인 용어"></a>기본적인 용어</h2><p>JOB : 배치를 수행할 일거리<br>STEP: JOB내에 배치를 단계적으로 수행하는 작업단위<br>Reader: STEP내에서 조회 역할을 담당 (대상을 쿼리로 조회)<br>Processor: Reader에서 가져온 데이터로 비즈니스로직을 처리 담당 (중간에서 계산 / 세팅 등)<br>Writer: Processor에서 처리된 데이터들을 최종 트랜젝션 처리 (Ready상태를 -&gt; Complete상태로 바꾼다든지.. 뭐그런 상태 최종 처리)<br>@JobScope: Job이 실행되는 시점에 Job Paramter가 생성 (Late binding 처리됨)<br>@StepScope: 스프링 컨테이너가 올라갈때 Job Parameter가 생성 (빌드시점 생성)<br>Chunk : 한번에 처리될 트랜잭션 단위 (PageSize는 조회될 대상의 사이즈이며 Chunk단위랑은 다름)</p><h2 id="기본-구조"><a href="#기본-구조" class="headerlink" title="기본 구조"></a>기본 구조</h2><h3 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h3><figure class="highlight java"><figcaption><span>batch-설정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// build.gradle에 아래 의존성 추가 </span></span><br><span class="line"><span class="comment">// implementation &#x27;org.springframework.boot:spring-boot-starter-batch&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// querydsl 사용하려면 추가</span></span><br><span class="line"><span class="comment">// implementation &#x27;com.querydsl:querydsl-jpa&#x27;</span></span><br><span class="line"><span class="comment">// implementation &#x27;com.querydsl:querydsl-apt&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBatchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">BatchConfigurer <span class="title">configurer</span><span class="params">(<span class="meta">@Qualifier(&quot;vbatchMasterDataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultBatchConfigurer(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="job-구조"><a href="#job-구조" class="headerlink" title="job 구조"></a>job 구조</h3><figure class="highlight java"><figcaption><span>batch-job</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = JOB_NAME)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Job <span class="title">job</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jobBuilderFactory.get(JOB_NAME)</span><br><span class="line">           .start(unusedStep())</span><br><span class="line">           .next(saveStep())</span><br><span class="line">           .next(removeStep())</span><br><span class="line">           .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="step-구조"><a href="#step-구조" class="headerlink" title="step 구조"></a>step 구조</h3><figure class="highlight java"><figcaption><span>batch-job</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = SAVE_STEP_NAME)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Step <span class="title">saveStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stepBuilderFactory.get(SAVE_STEP_NAME)</span><br><span class="line">           .&lt;BestRankQueryResult, BestRankSummaryEntity&gt;chunk(CHUNK_SIZE)</span><br><span class="line">           .reader(saveReader())</span><br><span class="line">           .processor(bestRankSummarySaveProcessor)</span><br><span class="line">           .writer(bestRankSummarySaveWriter)</span><br><span class="line">           .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="reader구조"><a href="#reader구조" class="headerlink" title="reader구조"></a>reader구조</h4><ul><li>spring batch에서는 본디 jpaPagingItemReader 처럼 jpa관련 리더를 제공하지만, querydsl사용이 어렵다. 조졸두님 블로그 확인하면 이부분을 해소하는 방법을 올려주셨음. 참고하자 </li><li>여기서 @StepScope는 job parameter가 없기때문에 제거해도 됨. (파라미터가 있는경우만 넣어주는것이 좋음)</li></ul><figure class="highlight java"><figcaption><span>batch-reader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = SAVE_READER_NAME)</span></span><br><span class="line">   <span class="meta">@StepScope</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> QuerydslPagingItemReader&lt;BestRankQueryResult&gt; <span class="title">saveReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> LocalDateTime startDate = parse(LocalDateTime.now().minusDays(<span class="number">2</span>).format(ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)).concat(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">           .concat(LocalDateTime.now().minusDays(<span class="number">2</span>).format(ofPattern(<span class="string">&quot;HH:00:00&quot;</span>))));</span><br><span class="line">       <span class="keyword">final</span> LocalDateTime endDate = parse(LocalDateTime.now().format(ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)).concat(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">           .concat(LocalDateTime.now().format(ofPattern(<span class="string">&quot;HH:59:59&quot;</span>))));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> QuerydslPagingItemReader&lt;&gt;(vorderEntityManagerFactory, CHUNK_SIZE, jpaQueryFactory -&gt;</span><br><span class="line">           jpaQueryFactory.select(getBestRankQueryProjection())</span><br><span class="line">               .from(bestRankEntity)</span><br><span class="line">               .where(betweenBasisDate(startDate, endDate))</span><br><span class="line">               .groupBy(bestRankEntity.productId), <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> QBestRankQueryResult <span class="title">getBestRankQueryProjection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String basisDate = LocalDateTime.now().format(ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)).concat(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">           .concat(LocalDateTime.now().minusHours(<span class="number">1</span>).format(ofPattern(<span class="string">&quot;HH:00:00&quot;</span>)));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> QBestRankQueryResult(bestRankEntity.productId.as(<span class="string">&quot;productId&quot;</span>)</span><br><span class="line">           , bestRankEntity.productPrice.as(<span class="string">&quot;productPrice&quot;</span>)</span><br><span class="line">           , bestRankEntity.wStyleOrderCount.sum().coalesce(<span class="number">0L</span>).as(<span class="string">&quot;wStyleOrderCount&quot;</span>)</span><br><span class="line">           , bestRankEntity.wStyleProductCount.sum().coalesce(<span class="number">0</span>).as(<span class="string">&quot;wStyleProductCount&quot;</span>)</span><br><span class="line">           , bestRankEntity.wmpOrderCount.sum().coalesce(<span class="number">0L</span>).as(<span class="string">&quot;wmpOrderCount&quot;</span>)</span><br><span class="line">           , bestRankEntity.wmpProductCount.sum().coalesce(<span class="number">0</span>).as(<span class="string">&quot;wmpProductCount&quot;</span>)</span><br><span class="line">           , constant(LocalDateTime.parse(basisDate)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> BooleanExpression <span class="title">betweenBasisDate</span><span class="params">(LocalDateTime startDate, LocalDateTime endDate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bestRankEntity.basisDate.between(startDate, endDate);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="processor-구조"><a href="#processor-구조" class="headerlink" title="processor 구조"></a>processor 구조</h4><figure class="highlight java"><figcaption><span>batch-processor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestRankSummarySaveProcessor</span> <span class="keyword">implements</span> <span class="title">ItemProcessor</span>&lt;<span class="title">BestRankQueryResult</span>, <span class="title">BestRankSummaryEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> wStyleBoost = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> wmpBoost = <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProductDetailViewCountProvider productDetailViewCountProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BestRankSummaryEntity <span class="title">process</span><span class="params">(BestRankQueryResult item)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BestRankSummaryEntity saveTarget = <span class="keyword">new</span> BestRankSummaryEntity();</span><br><span class="line"></span><br><span class="line">        saveTarget.setBasisDate(parse(now().minusHours(<span class="number">48</span>).format(ofPattern(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:00:00&quot;</span>))));</span><br><span class="line">        saveTarget.setProductId(item.getProductId());</span><br><span class="line">        saveTarget.setUsable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Float boostScore = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item.getWStyleOrderCount() &gt; <span class="number">0L</span> || item.getWStyleProductCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            boostScore += (item.getWStyleOrderCount() * wStyleBoost) + (item.getWStyleProductCount() * wStyleBoost);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item.getWmpOrderCount() &gt; <span class="number">0L</span> || item.getWmpProductCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            boostScore += (item.getWmpOrderCount() * wmpBoost) + (item.getWmpProductCount() * wmpBoost);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Integer productDetailViewCount = getProductDetailViewCount(item.getProductId());</span><br><span class="line">        <span class="keyword">if</span> (isCalculateProductViewCount(productDetailViewCount)) &#123;</span><br><span class="line">            boostScore += (productDetailViewCount * <span class="number">0.005F</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        saveTarget.setBoostScore(boostScore);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> saveTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCalculateProductViewCount</span><span class="params">(<span class="keyword">final</span> Integer productViewCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productViewCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">getProductDetailViewCount</span><span class="params">(<span class="keyword">final</span> Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LocalDateTime startDate = parse(LocalDateTime.now().minusDays(<span class="number">1</span>).format(ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)).concat(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">            .concat(LocalDateTime.now().minusDays(<span class="number">1</span>).format(ofPattern(<span class="string">&quot;HH:00:00&quot;</span>))));</span><br><span class="line">        <span class="keyword">final</span> LocalDateTime endDate = parse(LocalDateTime.now().format(ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)).concat(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">            .concat(LocalDateTime.now().format(ofPattern(<span class="string">&quot;HH:59:59&quot;</span>))));</span><br><span class="line">        <span class="keyword">return</span> productDetailViewCountProvider.getProductDetailViewCount(productId, startDate, endDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="writer구조"><a href="#writer구조" class="headerlink" title="writer구조"></a>writer구조</h4><figure class="highlight java"><figcaption><span>batch-writer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestRankSummarySaveWriter</span> <span class="keyword">implements</span> <span class="title">ItemWriter</span>&lt;<span class="title">BestRankSummaryEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BestRankSummaryProvider bestRankSummaryProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;? extends BestRankSummaryEntity&gt; items)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        bestRankSummaryProvider.saveAll((List&lt;BestRankSummaryEntity&gt;) items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Batch-도전기-간단스-정리&quot;&gt;&lt;a href=&quot;#Spring-Batch-도전기-간단스-정리&quot; class=&quot;headerlink&quot; title=&quot;Spring Batch 도전기 (간단스 정리)&quot;&gt;&lt;/a&gt;Spring Batch 도전</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="Batch" scheme="https://codexdawn.github.io/categories/Batch/"/>
    
    
    <category term="Java,JPA,Spring,Batch" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring-Batch/"/>
    
    <category term="Batch" scheme="https://codexdawn.github.io/tags/Batch/"/>
    
    <category term="querydsl" scheme="https://codexdawn.github.io/tags/querydsl/"/>
    
  </entry>
  
  <entry>
    <title>jpa-work-2</title>
    <link href="https://codexdawn.github.io/2021/11/01/jpa-work-2/"/>
    <id>https://codexdawn.github.io/2021/11/01/jpa-work-2/</id>
    <published>2021-11-01T03:40:02.000Z</published>
    <updated>2021-11-01T04:50:07.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ManyToOne-다중-fetchJoin시-주의사항"><a href="#ManyToOne-다중-fetchJoin시-주의사항" class="headerlink" title="ManyToOne 다중 fetchJoin시 주의사항"></a>ManyToOne 다중 fetchJoin시 주의사항</h1><p>사건의 발단은 이렇다. 일단 OneToMany(컬렉션 조인) 로 fetchJoin은 2개이상은 어렵다. 이유는 컬렉션의 컬렉션으로 곱하기로 배가 되기때문에 MultiBagFetchException 떨어저셔서 불가능하다. (그래서 쿼리를 쪼개서 가져오던지 아님 projection처리를 개별로 해서 가져오던지 등의 방법으로 해결 한다. )<br>하지만 반대로 ManyToOne의 연관관계는 해당 이슈가 없기때문에 몇개를 fetchJoin해도 이슈는 없는것이 당연한 부분이다. 하지만 이상한 오류와 함께 나를 당혹시킨 에러가 있었으니.. </p><figure class="highlight java"><figcaption><span>문제의 코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ProductCategoryInfo&gt; <span class="title">findProductInfoByProductIdsAndPartnerId</span><span class="params">(List&lt;Long&gt; productIds, String partnerId)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dealJpaQueryFactory.select(projectionChartInfo())</span><br><span class="line">           .from(productEntity, productEntity)</span><br><span class="line">           .innerJoin(productEntity.detailCategory, categoryDivideEntity).fetchJoin()</span><br><span class="line">           .innerJoin(productEntity.detailCategory.smallCategory, categorySmallEntity).fetchJoin()</span><br><span class="line">           .where(productNosIn(productIds), partnerIdIs(partnerId))</span><br><span class="line">           .fetch();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>위 와 같이 다중 fetchJoin으로 해당 테이블의 프로젝션 정보를 모두 가져오려고 하였으나, 아래와 같은 오류로 실패하게 되었다. </p><blockquote><p>org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list [FromElement{explicit,not a collection join,fetch join,fetch non-lazy properties,classAlias=categorySmallEntity,role=com.wemakeprice.v.seller.domain.repository.jpa.deal.category.entity.CategoryDivideEntity.smallCategory,tableName=category_small,tableAlias=categorysm3_,origin=category_divide categorydi2_,columns={categorydi2_.scate_cd,className=com.wemakeprice.v.seller.domain.repository.jpa.deal.category.entity.CategorySmallEntity}}] [select productEntity<br>from com.wemakeprice.v.seller.domain.repository.jpa.deal.category.entity.ProductEntity productEntity<br>  inner join fetch productEntity.detailCategory as categoryDivideEntity<br>  inner join fetch productEntity.detailCategory.smallCategory as categorySmallEntity<br>where productEntity.productId in (?1) and productEntity.partnerId = ?2]; nested exception is java.lang.IllegalArgumentException: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list [FromElement{explicit,not a collection join,fetch join,fetch non-lazy properties,classAlias=categorySmallEntity,role=com.wemakeprice.v.seller.domain.repository.jpa.deal.category.entity.CategoryDivideEntity.smallCategory,tableName=category_small,tableAlias=categorysm3_,origin=category_divide categorydi2_,columns={categorydi2_.scate_cd,className=com.wemakeprice.v.seller.domain.repository.jpa.deal.category.entity.CategorySmallEntity}}] [select productEntity<br>from com.wemakeprice.v.seller.domain.repository.jpa.deal.category.entity.ProductEntity productEntity<br>  inner join fetch productEntity.detailCategory as categoryDivideEntity<br>  inner join fetch productEntity.detailCategory.smallCategory as categorySmallEntity<br>where productEntity.productId in (?1) and productEntity.partnerId = ?2]</p></blockquote><p>해당 이슈가 발생한 원인은 아주 간단한 곳에서 발생하였다. </p><figure class="highlight java"><figcaption><span>간단한해결코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ProductEntity&gt; <span class="title">testFindFetchJoin</span><span class="params">(List&lt;Long&gt; productIds, String partnerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dealJpaQueryFactory.selectFrom(productEntity)</span><br><span class="line">        .innerJoin(productEntity.detailCategory, categoryDivideEntity).fetchJoin()</span><br><span class="line">        .innerJoin(categoryDivideEntity.smallCategory, categorySmallEntity).fetchJoin()</span><br><span class="line">        .where(productNosIn(productIds), partnerIdIs(partnerId))</span><br><span class="line">        .fetch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>querydsl에서 테이블 join 구성시 발생한 이슈로 productEntity에서 categorySmallEntity를 참조할수 없어서 발생한 이슈이다. 참조의 참조로 가져오게 하지말고 실제 엔티티에서 직접 참조해서 가져오게 하는것이 맞다. 문제의 코드에서는 productEntity를 통해서 categoryDivideEntity를 거쳐서 categorySmallEntity를 참조하는건 실제적인 연관관계 주인이 아닌 productEntity로부터 참조하였기때문에 해당 이슈가 발생한것으로 판단된다. 그러므로 위와 같이 실제 연관관계 매핑되어있는 테이블로 직접 명시하여 쿼리를 짜야 위와같은 에러가 안날수있음 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ManyToOne-다중-fetchJoin시-주의사항&quot;&gt;&lt;a href=&quot;#ManyToOne-다중-fetchJoin시-주의사항&quot; class=&quot;headerlink&quot; title=&quot;ManyToOne 다중 fetchJoin시 주의사항&quot;&gt;&lt;/a&gt;Ma</summary>
      
    
    
    
    <category term="유레카or삽질" scheme="https://codexdawn.github.io/categories/%EC%9C%A0%EB%A0%88%EC%B9%B4or%EC%82%BD%EC%A7%88/"/>
    
    <category term="JPA" scheme="https://codexdawn.github.io/categories/JPA/"/>
    
    
    <category term="Java,JPA,Spring" scheme="https://codexdawn.github.io/tags/Java-JPA-Spring/"/>
    
    <category term="JPA" scheme="https://codexdawn.github.io/tags/JPA/"/>
    
    <category term="Fetch" scheme="https://codexdawn.github.io/tags/Fetch/"/>
    
    <category term="FetchJoin" scheme="https://codexdawn.github.io/tags/FetchJoin/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-13</title>
    <link href="https://codexdawn.github.io/2021/09/15/java-effective-13/"/>
    <id>https://codexdawn.github.io/2021/09/15/java-effective-13/</id>
    <published>2021-09-15T13:37:42.000Z</published>
    <updated>2021-12-30T06:16:47.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="clone-재정의는-주의해서-진행하라"><a href="#clone-재정의는-주의해서-진행하라" class="headerlink" title="clone 재정의는 주의해서 진행하라"></a>clone 재정의는 주의해서 진행하라</h1><h2 id="clone이-뭐지"><a href="#clone이-뭐지" class="headerlink" title="clone이 뭐지?"></a>clone이 뭐지?</h2><ul><li>객체의 복사본을 생성해서 반환하는 역할을 함 </li><li>자주 쓰인다고하는데, 솔직히 제대로 쓴걸 본적이 없음</li></ul><blockquote><p>clone을 사용했을때 아래 조건들은 모두 참이다. </p><p>x.clone() != x (O)<br>x.clone().getClass() == x.getClass() (O)<br>x.clone().equals(x) (O)</p></blockquote><h2 id="그럼-clone은-왜-조심해서-사용해야해"><a href="#그럼-clone은-왜-조심해서-사용해야해" class="headerlink" title="그럼 clone은 왜 조심해서 사용해야해?"></a>그럼 clone은 왜 조심해서 사용해야해?</h2><ul><li>복제하고자하는 타겟 클래스의 하위클래스에서 super.clone을 호출하면 잘못된 클래스의 객체가 만들어져 결국 하위 클래스의 clone메서드가 제대로 동작하지 않게됨. (class에 final이라면 괜찮음 - 확장 불가능한 불변클래스이기 때문)</li></ul><figure class="highlight java"><figcaption><span>가변상태를 참조하지 않는 클래스용 clone 메서드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PhoneNumber 클래스는 반드시 Cloneable을 구현한다고 추가해야함. </span></span><br><span class="line"><span class="comment">// PhoneNumber 클래스 전용으로 사용되는 clone이기에 super로 호출했을때 상위타입 혹은 Object형태로 들어오는 clone객체를 방지할수있음. </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (PhoneNumber) <span class="keyword">super</span>.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertioError(); <span class="comment">//일어날수없는 일 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>clone 메서드는 사실상 생성자와 같은 효과를 냄 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야함. </li><li>배열복제할때는 clone사용을 권장함. clone기능을 제대로 활용하는 유일한 참 조건임. </li><li>Cloneable 아키텍처는 가변 객체를 참조하는 필드는 final로 선언하라 는 일반 용법고 충돌되기때문에 clone사용시 final필드로 선언되어있음 반드시 제거해야함. </li><li>Stack클래스 처럼 내부에 elements 배열객체를 갖는 클래스는 원본이나 복제본중 하나가 수정되면 내용이 달라지기때문에 프로그램이 오동작하거나 NullPointerException이 발생할수있음, 따라서 elements배열의 clone을 재귀적으로 호출헤야함. (ex&gt; result.elements = elements.clone())</li></ul><h2 id="clone-메서드-사용하기-겁나-복잡한-대체-방법-없음"><a href="#clone-메서드-사용하기-겁나-복잡한-대체-방법-없음" class="headerlink" title="clone 메서드 사용하기 겁나 복잡한 대체 방법 없음?"></a>clone 메서드 사용하기 겁나 복잡한 대체 방법 없음?</h2><ul><li>Cloneable을 이미 구현한 클래스는 clone을 반드시 잘 구현해야한다. 하지만 그런 상황이 아니라면 <strong>복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공 할수 있음</strong> </li><li>복사생성자(변환생성자) : public Yum(Yum yum) {…}; </li><li>복사팩터리(변환팩터리) : public static Yum newInstance(Yum yum) {…};</li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>Cloneable은 왠만해서는 쓰지말고, 새로운 인터페이스를 만들때 역시 Cloneable을 확장해서는 안됨. 여러 사이드이펙트를 발생할 리스크가 큼 </li><li>final 클래스라면 큰 위험은 없지만 성능 최적화 관점에서 큰이슈 없을때만 가능하지 그외에는 그냥 사용하지 말자</li><li>복제기능은 생성자와 팩터리를 이용하는것이 갑이다 라는것이 결론이다. 단, 배열만 clone사용이 깔끔하다. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;clone-재정의는-주의해서-진행하라&quot;&gt;&lt;a href=&quot;#clone-재정의는-주의해서-진행하라&quot; class=&quot;headerlink&quot; title=&quot;clone 재정의는 주의해서 진행하라&quot;&gt;&lt;/a&gt;clone 재정의는 주의해서 진행하라&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="모든 객체의 공통 메서드" scheme="https://codexdawn.github.io/categories/%EB%AA%A8%EB%93%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B3%B5%ED%86%B5-%EB%A9%94%EC%84%9C%EB%93%9C/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
    <category term="clone" scheme="https://codexdawn.github.io/tags/clone/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-12</title>
    <link href="https://codexdawn.github.io/2021/09/15/java-effective-12/"/>
    <id>https://codexdawn.github.io/2021/09/15/java-effective-12/</id>
    <published>2021-09-15T12:37:51.000Z</published>
    <updated>2021-09-15T13:35:28.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="toString을-항상-재정의하라"><a href="#toString을-항상-재정의하라" class="headerlink" title="toString을 항상 재정의하라"></a>toString을 항상 재정의하라</h1><ul><li>toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고 , 그 클래스를 사용한 시스템은 디버깅하기 쉽다</li><li>실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다 </li><li>포맷을 명시하든 아니든 의도는 명확히 밝혀야한다. </li><li>유틸리티 클랫느는 toString을 제공할 이유가 없다. </li><li>대부분의 열거타입도 toString을 제공하니 굳이 재정의안해도 됨 </li><li>하위 클래스들이 공유해야할 문자열 표현이 추상 클래스라면 toString을 재정의 해줘야함 (예컨데 대다수의 컬렉션 구현체는 추상 컬렉션 클래스의 toString메서드를 상속함 ) </li><li>구글의 AutoValue는 toString 도 생성해줌 </li><li>toString은 결국 개발자들이 디버깅하고 손쉽게 정보를 파악하기 위한 옵션이다. </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;toString을-항상-재정의하라&quot;&gt;&lt;a href=&quot;#toString을-항상-재정의하라&quot; class=&quot;headerlink&quot; title=&quot;toString을 항상 재정의하라&quot;&gt;&lt;/a&gt;toString을 항상 재정의하라&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="모든 객체의 공통 메서드" scheme="https://codexdawn.github.io/categories/%EB%AA%A8%EB%93%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B3%B5%ED%86%B5-%EB%A9%94%EC%84%9C%EB%93%9C/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
  </entry>
  
  <entry>
    <title>java-effective-11</title>
    <link href="https://codexdawn.github.io/2021/09/15/java-effective-11/"/>
    <id>https://codexdawn.github.io/2021/09/15/java-effective-11/</id>
    <published>2021-09-15T07:42:17.000Z</published>
    <updated>2021-09-15T12:32:27.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="equals를-재정의하려거든-hashCode도-재정의하라"><a href="#equals를-재정의하려거든-hashCode도-재정의하라" class="headerlink" title="equals를 재정의하려거든 hashCode도 재정의하라"></a>equals를 재정의하려거든 hashCode도 재정의하라</h1><p>equals를 재정의하고 hashCode를 재정의 하지 않으면 어떻게됨? </p><ul><li>응. 사용못해.. 문제 발생해서 (Hash계열 컬렉션들은 모두 안됨 HashMap,HashSet.. )</li><li>hash 계열은 키값을 기준으로 탐색하기 때문에, equals할때 해당 key에 해당하는 value를 찾고자 할텐데,이때 동일한 key값 여부를 찾게됨. 하지만 equals만 정의해버리면 hash가 재정의 되어있지않기때문에 nullPointerException이 발생하게 됨.(즉, 논리적인 같은 객체는 같은 해시코드를 반환해야한다.) </li><li>가급적이면 IDE 혹은 AutoValue라이브러리 등 에서 정의해주는 부분을 그대로 사용하는것이 좋을듯함 </li></ul><figure class="highlight java"><figcaption><span>최악의 해시코드 - 잘되긴하지만 하지말자</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 해시코드로 정의하는것이 최악의 로직인 이유는? </p><ul><li>모든 객체에게 똑같은 값만 내어주기떄문에 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결 리스트 처럼 동작하게됨. 그 결과 평균시간이 O(1) 에서 O(N)으로 느려져서 객체가 많아지면 성능이 최악이됨 </li></ul><figure class="highlight java"><figcaption><span>전형적인 해시코드 - PhoneNumber객체기준</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = Short.hashCode(areaCode);</span><br><span class="line">result = <span class="number">31</span> * result + Short.hashCode(prefix);</span><br><span class="line">result = <span class="number">31</span> * result + Short.hashCOde(lineNum);</span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 코드에서 31을 곱하는 이유는 31이 홀수이면서 소수(Prime)이기때문인데, 짝수이면 오버플로우가 발생하면 정보를 잃게됨 </li><li>성능 높인다 치고 해시 코드를 계산할때 필수필드를 생략해서는 절대로 안된다. 속도는 빨라질지 몰라도 나중에 해시테이블 성능을 급격하게 안좋게 할수있다. 특정 필드만 키값이 몰리는 현상을 고루 분포해서 해시테이블을 관리할수도있기때문에 가급적 필수 필드들은 왠만하면 다 정의해주자. </li></ul><figure class="highlight java"><figcaption><span>해시코드 지연초기화 - 스레드 안정성 고려</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashCode; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">result = Short.hashCode(areaCode);</span><br><span class="line">result = <span class="number">31</span> * result + Short.hashCode(prefix);</span><br><span class="line">result = <span class="number">31</span> * result + Short.hashCOde(lineNum);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>클래스가 불변이고, 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기보다 캐싱하는 방식을 고려하는게 좋은데 이럴때 hashCode를 지연초기화 하면 좋다. </li><li>필드를 지연 초기화 하려면 스레드 안전하도록 만들어주도록 신경써야함 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;equals를-재정의하려거든-hashCode도-재정의하라&quot;&gt;&lt;a href=&quot;#equals를-재정의하려거든-hashCode도-재정의하라&quot; class=&quot;headerlink&quot; title=&quot;equals를 재정의하려거든 hashCode도 재정의하</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="Effective Java" scheme="https://codexdawn.github.io/categories/Effective-Java/"/>
    
    <category term="모든 객체의 공통 메서드" scheme="https://codexdawn.github.io/categories/%EB%AA%A8%EB%93%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B3%B5%ED%86%B5-%EB%A9%94%EC%84%9C%EB%93%9C/"/>
    
    
    <category term="Java,EffectiveJava" scheme="https://codexdawn.github.io/tags/Java-EffectiveJava/"/>
    
  </entry>
  
  <entry>
    <title>kotlin-basic-7</title>
    <link href="https://codexdawn.github.io/2021/09/06/kotlin-basic-7/"/>
    <id>https://codexdawn.github.io/2021/09/06/kotlin-basic-7/</id>
    <published>2021-09-06T08:26:50.000Z</published>
    <updated>2021-09-08T11:36:20.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="제네릭스"><a href="#제네릭스" class="headerlink" title="제네릭스"></a>제네릭스</h1><h2 id="제네릭-타입-파라미터"><a href="#제네릭-타입-파라미터" class="headerlink" title="제네릭 타입 파라미터"></a>제네릭 타입 파라미터</h2><ul><li>제네릭스를 사용하면 <strong>타입 파라미터(type paramet)</strong> 를 받는 타입을 정의 할수 있다. </li><li>제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 <strong>타입인자(type argument)</strong> 로 치환해야한다. </li><li>코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자를 타입추론 할수있다. </li></ul><h3 id="제네릭-함수와-프로퍼티"><a href="#제네릭-함수와-프로퍼티" class="headerlink" title="제네릭 함수와 프로퍼티"></a>제네릭 함수와 프로퍼티</h3><ul><li>확장 프로퍼티만 제네릭 하게 만들수있음. (일반 프로퍼티는 제네릭 사용 불가능)</li></ul><figure class="highlight kotlin"><figcaption><span>제네릭 함수와 프로퍼티</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">slice</span><span class="params">(indics:<span class="type">IntRange</span>)</span></span>: List&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">val</span> letters = (<span class="string">&#x27;a&#x27;</span>.. <span class="string">&#x27;z&#x27;</span>).toList()</span><br><span class="line">&gt;&gt; println(letters.slice&lt;<span class="built_in">Char</span>&gt;(<span class="number">0.</span><span class="number">.2</span>)) <span class="comment">//타입 인자를 명시적으로 지정 </span></span><br><span class="line">&gt;&gt;&gt; [a,b,c]</span><br><span class="line">&gt;&gt; println(letters.slice(<span class="number">10.</span><span class="number">.13</span>)) <span class="comment">// 컴파일러는 여기서 T가 Char라는 사실을 추론할수있게됨. </span></span><br><span class="line">&gt;&gt;&gt; [k,l,m,n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> authors = listOf(<span class="string">&quot;Dmitty&quot;</span>,<span class="string">&quot;Svetlana&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> readers = mutableListOf&lt;String&gt;(.....)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt; readers.filter&#123;it !<span class="keyword">in</span> authors&#125; </span><br></pre></td></tr></table></figure><h3 id="제네릭-클래스-선언"><a href="#제네릭-클래스-선언" class="headerlink" title="제네릭 클래스 선언"></a>제네릭 클래스 선언</h3><figure class="highlight kotlin"><figcaption><span>제네릭클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index:<span class="type">Int</span>)</span></span>: T <span class="comment">// 인터페이스 안에서 T를 일반 타입처럼 사용가능함  </span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="타입-파라미터-제약"><a href="#타입-파라미터-제약" class="headerlink" title="타입 파라미터 제약"></a>타입 파라미터 제약</h3><ul><li>타입 파라미터 제약은 클래스나 함수에 사용할수 있는 타입 인자를 제한하는 기능 (sum함수는 Number타입만 가능하지, String은 sum이 어렵다.)</li><li>타입 파라미터 제약을 하려면 제네릭타입에 상한으로 지정하면 됨 </li></ul><figure class="highlight kotlin"><figcaption><span>타입 파라미터 제약</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">max</span><span class="params">(first:<span class="type">T</span>, second:<span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> (first&gt;second) first <span class="keyword">else</span> second </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; println(max(<span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;java&quot;</span>)) <span class="comment">//문자열 비교는 알파벳순서로 비교, String은 Comparable&lt;String&gt;을 확장한다. 따라서 max사용가능 </span></span><br><span class="line">&gt;&gt;&gt; kotlin</span><br><span class="line">&gt;&gt; println(max(<span class="string">&quot;kotlin&quot;</span>, <span class="number">42</span>)) <span class="comment">// error남! 함수의 파라미터가 같은 T를 요구하기때문 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//타입 파라미터에 여러 제약 걸기 </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">ensureTrailingPeriod</span><span class="params">(seq:<span class="type">T</span>)</span></span> </span><br><span class="line"><span class="keyword">where</span> T: CharSequence, T: Appendable &#123;</span><br><span class="line"><span class="keyword">if</span>(!seq.endWith(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">seq.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">val</span> helloworld = StringBuilder(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&gt;&gt; ensureTrailingPeriod(helloworld)</span><br><span class="line">&gt;&gt; println(helloworld)</span><br><span class="line">&gt;&gt;&gt; Hello World. </span><br></pre></td></tr></table></figure><h3 id="타입-파라미터를-Null이-될수-없는-타입으로-한정"><a href="#타입-파라미터를-Null이-될수-없는-타입으로-한정" class="headerlink" title="타입 파라미터를 Null이 될수 없는 타입으로 한정"></a>타입 파라미터를 Null이 될수 없는 타입으로 한정</h3><ul><li>아무런 상한을 정하지 않은 타입 파라미터는 Any?를 상한으로 정한 파라미터와 같음 </li><li>Null 가능성을 제외한 아무런 제약도 필요없다면 Any? 대신 Any를 상한으로 사용해야함 </li></ul><h2 id="실행시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터"><a href="#실행시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터" class="headerlink" title="실행시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터"></a>실행시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터</h2><h3 id="실행시점의-제네릭-타입검사와-캐스트"><a href="#실행시점의-제네릭-타입검사와-캐스트" class="headerlink" title="실행시점의 제네릭: 타입검사와 캐스트"></a>실행시점의 제네릭: 타입검사와 캐스트</h3><ul><li>타입 소거 : 실행시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다. (JVM기준)</li></ul><p>if(value is List<String>) {….}<br>ERROR:Cannot check for instance of erased type </String></p><ul><li>위 와같이 실행시점에 어떤 값이 List인지는 구분할수있지만, List내 타입이 String인지 Person객체인지 알수없음. 에러내용에서 볼수있듯이 타입정보는 지워진다. 다만 저장해야하는 타입정보의 크기가 줄어들어서 전반적인 메모리 사용량이 줄어든다는 제네릭 타입 소거 나름의 장점이 있다고함. </li></ul><figure class="highlight kotlin"><figcaption><span>제네릭타입으로 타입캐스팅</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(c:<span class="type">Collection</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> intList = c <span class="keyword">as</span>? List&lt;<span class="built_in">Int</span>&gt; ?: IllegalArgumentException(<span class="string">&quot;List is expected&quot;</span>) <span class="comment">// 여기서 Unchecked cast: List&lt;*&gt; to List&lt;Int&gt; 경고 발생함 하지만 실행은 잘됨. </span></span><br><span class="line">println(intList.sum())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; printSum(listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&gt;&gt;&gt; <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; printSum(setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&gt;&gt;&gt; IllegalArgumentException: List <span class="keyword">is</span> expected</span><br><span class="line"></span><br><span class="line">&gt;&gt; printSum(listOf(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; ClassCastException: String cannot be cast to Number </span><br></pre></td></tr></table></figure><ul><li>코틀린 컴파일러는 안전하지 못한 is 검사는 금지하고 위험한 as캐스팅은 경고를 출력함 </li></ul><h3 id="실체화한-타입-파라미터를-사용한-함수-선언"><a href="#실체화한-타입-파라미터를-사용한-함수-선언" class="headerlink" title="실체화한 타입 파라미터를 사용한 함수 선언"></a>실체화한 타입 파라미터를 사용한 함수 선언</h3><ul><li>인라인함수를 사용하면 타입소거로 실행시점에 타입이 지워져서 타입을 확인하지 못하는 부분을 해소할수있음 </li><li>타입파라미터 앞에 <strong>reified</strong> 를 사용해야함  </li><li>inline함수에서 가능한이유는 컴파일러에서 인라인함수 본문을 구현한 바이트코드를 그 함수가 호출되는 모든지점에 삽입함. 컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입을 알수있다.  </li></ul><figure class="highlight kotlin"><figcaption><span>inline으로 실체화된 타입파라미터 확인</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isA</span><span class="params">(value:<span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T </span><br><span class="line">&gt;&gt; println(isA&lt;String&gt;(<span class="string">&quot;abc&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; <span class="literal">true</span> </span><br><span class="line">&gt;&gt; println(isA&lt;String&gt;(<span class="number">123</span>))</span><br><span class="line">&gt;&gt;&gt; <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Iterable<span class="type">&lt;*&gt;</span>.<span class="title">filterIsInstance</span><span class="params">()</span></span>: List&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> destination = mutableListOf&lt;T&gt;()</span><br><span class="line"><span class="keyword">for</span>(element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(element <span class="keyword">is</span> T) &#123;</span><br><span class="line">destination.add(element)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">val</span> items = listOf(<span class="string">&quot;one&quot;</span>,<span class="number">2</span>,<span class="string">&quot;three&quot;</span>)</span><br><span class="line">&gt;&gt; println(items.filterIsInstance&lt;String&gt;())</span><br><span class="line">&gt;&gt;&gt; [one,three]</span><br></pre></td></tr></table></figure><h3 id="실체화한-타입-파라미터로-클래스-참조-대신"><a href="#실체화한-타입-파라미터로-클래스-참조-대신" class="headerlink" title="실체화한 타입 파라미터로 클래스 참조 대신"></a>실체화한 타입 파라미터로 클래스 참조 대신</h3><figure class="highlight kotlin"><figcaption><span>클래스로더</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serviceImpl = ServiceLoader.load(Service::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="comment">//위 코드는 아래와 같이 인라인함수를 통해 축약가능 </span></span><br><span class="line"><span class="keyword">val</span> serviceImpl = loadService&lt;Service&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//loadService구현체</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">loadService</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ServiceLoader.load(T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="실체화한-타입-파라미터의-제약"><a href="#실체화한-타입-파라미터의-제약" class="headerlink" title="실체화한 타입 파라미터의 제약"></a>실체화한 타입 파라미터의 제약</h3><ol><li>실체화한 타입 파라미터를 사용할수있는 경우 </li></ol><ul><li>타입 검사와 캐스팅 (is,!is,as,as?)</li><li>리플렉션 API (::class)</li><li>코틀린 타입에 대응하는 Java.lang.Class얻기 (::class.java)</li><li>다른 함수를 호출할때 타입 인자로 사용 </li></ul><ol start="2"><li>사용할수없는경우 </li></ol><ul><li>타입 파라미터 클래스의 인스턴스 생성하기 </li><li>타입 파라미터 클래스의 동반 객체 메소드 호출하기 </li><li>실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입인자로 넘기기</li><li>클래스,프로퍼티,인라인 함수가 아닌 함수의 타입 파라미터를 reidied로 지정하기 </li></ul><h2 id="변성-제네릭과-하위-타입"><a href="#변성-제네릭과-하위-타입" class="headerlink" title="변성: 제네릭과 하위 타입"></a>변성: 제네릭과 하위 타입</h2><ul><li>변성(variance) : List<String> 와 List<Any>와 같이 기저 타입이 같고 타입인자가 다른 여러타입이 서로 어떤관계가 있는지 설명하는 개념 </Any></String></li></ul><h3 id="변성이-있는-이유-인자를-함수에-넘기기"><a href="#변성이-있는-이유-인자를-함수에-넘기기" class="headerlink" title="변성이 있는 이유: 인자를 함수에 넘기기"></a>변성이 있는 이유: 인자를 함수에 넘기기</h3><figure class="highlight kotlin"><figcaption><span>변성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printContent</span><span class="params">(list:<span class="type">List</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(list.joinToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAnswer</span><span class="params">(list:<span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    list.add(<span class="number">54</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">printContent(listOf(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;bac&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> strings = mutableListOf(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;bac&quot;</span>)</span><br><span class="line">    addAnswer(strings)</span><br><span class="line">    println(strings.maxBy&#123;it.length&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>printContent 함수는 인자를 List<Any>로 받았지만, List<String>의 타입인자가 Any는 String의 포함하는 하위타입이기때문에 에러가 안남 </String></Any></li><li>addAnswer 함수는 MutableListOf로 기존 정수형에서 string형태 값을 집어넣으려고 시도할수도있기때문에 해당 부분은 컴파일러가 예외를 발생시킴</li></ul><h3 id="클래스-타입-하위타입"><a href="#클래스-타입-하위타입" class="headerlink" title="클래스,타입,하위타입"></a>클래스,타입,하위타입</h3><ul><li>하위타입 : Int는 Number의 하위타입이다. 하지만 String은 Number의 하위타입이 아니다. </li><li>코틀린 컴파일러는 변수 대입이나 함수 인자 전달시 하위타입검사를 매번 수행함. </li><li>널이 될수 있는 타입은 널이 될수없는 타입보다 상위타입이다. 즉 Any 타입 보다 Any? 타입이 더 상위 타입이다. </li><li>무공변(invariant): 제네릭타입을 인스턴스화 할때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위타입관계가 성립하지 않는다. 예를들어 MutableList<A>,MutableList<B>가 존재하는데 A,B는 서로 다른타입이다. 그럼 MutableList<A>,MutableList<B>는 상.하위타입이 존재하지 않게된다. </B></A></B></A></li><li>자바에서는 모든 클래스가 무공변이다. </li></ul><h3 id="공변성-하위-타입관계를-유지"><a href="#공변성-하위-타입관계를-유지" class="headerlink" title="공변성 : 하위 타입관계를 유지"></a>공변성 : 하위 타입관계를 유지</h3><ul><li>공변성은 기본적으로 상.하 타입이 존재할 경우에만 할수있음 </li><li>공변성은 java에서 T extends Any 처럼 사용할때 공변성의 규칙을 가지고 사용할수있음</li><li>코틀린에서 공변성은 공변성을 갖을 타입 앞에 <strong>out</strong> 을 붙이는것이 특징이다. </li></ul><p>제네릭(타입 파리미터)에서의 out키워드의 용도 (제네릭에서의 공변성) </p><ul><li>공변성 : 하위타입관계가 유지됨 (상하위 타입 관계 식별가능)</li><li>사용제한 : T를 아웃 위치에서만 사용가능 (타입 파라미터는 반환타입에서만 사용해야함) </li><li>타입 파라미터가 공변적일때는 반환타입을 반드시 리턴할 필요가 없으며, List<T> 와 같이 타입 인자로도 리턴이 가능하다는걸 명심하자! 반드시 원형의 타입으로만 리턴할 필요는 없다는 이야기다. </T></li></ul><p>기타 참고해야할 타입파라미터의 공변</p><ul><li>생성자 파라미터는 인이나 아웃 어느쪽도 아님을 유의해야한다. </li><li>MutableList는 공변적 클래스로 선언이 불가능하다. </li></ul><h3 id="반공변성-뒤집힌-하위-타입-관계"><a href="#반공변성-뒤집힌-하위-타입-관계" class="headerlink" title="반공변성 : 뒤집힌 하위 타입 관계"></a>반공변성 : 뒤집힌 하위 타입 관계</h3><ul><li>반공변성 : 공변성을 거울에 비친 상이라 할수있음 (반대개념)</li><li>공변성은 out키워드를 사용하지만, 반공변성은 in키워드를 사용한다. </li><li>타입 파라미터 위치가 In위치에 있음 (함수의 반환타입이 아닌 함수 파라미터에 정의되어있음 )</li><li>공변성은 producer 변성을 가지고 반공변성은 consumer 변성을 가진다라고 표현하기도함. </li></ul><h3 id="사용-지점-변성-타입이-언급되는-지점에서-변성-지정"><a href="#사용-지점-변성-타입이-언급되는-지점에서-변성-지정" class="headerlink" title="사용 지점 변성: 타입이 언급되는 지점에서 변성 지정"></a>사용 지점 변성: 타입이 언급되는 지점에서 변성 지정</h3><ul><li>사용지점변성 : 자바에서는 타입 파라미터가 있는 타입을 사용할때마다 해당 타입 파라미터를 하위 타입이나 상위 타입중 어떤 타입으로 대치할 수 있는지 명시하는데, 이런 방식을 사용지점 방식이라함 </li></ul><figure class="highlight kotlin"><figcaption><span>사용지정변성 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printContent</span><span class="params">(list:<span class="type">List</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(list.joinToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeAnswer</span><span class="params">(list:<span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;)</span></span>: String &#123;</span><br><span class="line">    list.removeAt(list.size-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> list.joinToString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAnswer</span><span class="params">(list:<span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.add(<span class="string">&quot;mza&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">printContent(listOf(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;bac&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> strings = mutableListOf(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;zyaa&quot;</span>,<span class="string">&quot;xyz&quot;</span>)</span><br><span class="line">    println(removeAnswer(strings))</span><br><span class="line">    println(strings.maxBy&#123;it.length&#125;)</span><br><span class="line"></span><br><span class="line">println(addAnswer(strings))</span><br><span class="line">    println(strings.joinToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">컴파일 결과 </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; abc, bac</span><br><span class="line">&gt;&gt;&gt; abc, zyaa</span><br><span class="line">&gt;&gt;&gt; zyaa</span><br><span class="line">&gt;&gt;&gt; <span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; abc, zyaa, mza</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">copyData</span><span class="params">(source:<span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, destination:<span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123; </span><br><span class="line"><span class="comment">// 원본 리스트 원소 타입의 상위타입을 대상 리스트 원소 타입으로 허용한다.</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">destination.add(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>위 코드는 addAnswer메소드의 공변성을 지정한 케이스이며, 정상적으로 동작한다. 하지만 저기서 만약 사용하는 메서드가 add메소드를 사용하면 공변이 제대로 지정이 되지 않는다. add는 boolean으로 리턴하기때문에 안된다. 대신 in으로 지정하면 가능함. </li></ul><p>결론은 코틀린의 사용지점변성 선언은 자바의 한정 와일드카드와 똑같음. MutableList<out t> 는 자바 MutableList&lt;? extends T&gt; 와 같고 MutableList<in t> 는 자바 MutableList&lt;? super T&gt; 와 같다. </in></out></p><h3 id="스타-프로젝션-타입-인자-대신-사용"><a href="#스타-프로젝션-타입-인자-대신-사용" class="headerlink" title="스타 프로젝션 : 타입 인자 대신 * 사용"></a>스타 프로젝션 : 타입 인자 대신 * 사용</h3><figure class="highlight kotlin"><figcaption><span>스타프로젝션 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFirst</span><span class="params">(list:<span class="type">List</span>&lt;*&gt;)</span></span> &#123; <span class="comment">//모든 인자리스트를 받을수있음 </span></span><br><span class="line"><span class="keyword">if</span>(list.isNotEmpty()) &#123; <span class="comment">//isNotEmpty()에서는 제네릭 타입 파라미터를 사용하지 않는다. </span></span><br><span class="line">println(list.first()) <span class="comment">//first()는 이제 Any?를 반환하지만 여기서는 그 타입만으로도 충분하다 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; printFirst(listOf(<span class="string">&quot;enok&quot;</span>,<span class="string">&quot;jisung&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; enok </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;제네릭스&quot;&gt;&lt;a href=&quot;#제네릭스&quot; class=&quot;headerlink&quot; title=&quot;제네릭스&quot;&gt;&lt;/a&gt;제네릭스&lt;/h1&gt;&lt;h2 id=&quot;제네릭-타입-파라미터&quot;&gt;&lt;a href=&quot;#제네릭-타입-파라미터&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Study" scheme="https://codexdawn.github.io/categories/Study/"/>
    
    <category term="KotlinInAction" scheme="https://codexdawn.github.io/categories/KotlinInAction/"/>
    
    <category term="코틀린문법&amp;기초" scheme="https://codexdawn.github.io/categories/%EC%BD%94%ED%8B%80%EB%A6%B0%EB%AC%B8%EB%B2%95-%EA%B8%B0%EC%B4%88/"/>
    
    
    <category term="kotlin" scheme="https://codexdawn.github.io/tags/kotlin/"/>
    
    <category term="kotlininaction" scheme="https://codexdawn.github.io/tags/kotlininaction/"/>
    
    <category term="kotlin문법" scheme="https://codexdawn.github.io/tags/kotlin%EB%AC%B8%EB%B2%95/"/>
    
    <category term="제네릭스" scheme="https://codexdawn.github.io/tags/%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%8A%A4/"/>
    
  </entry>
  
</feed>
